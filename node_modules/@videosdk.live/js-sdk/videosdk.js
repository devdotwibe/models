(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 11:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chrome74 = void 0;
const sdpTransform = __webpack_require__(7363);
const Logger_1 = __webpack_require__(2994);
const enhancedEvents_1 = __webpack_require__(3953);
const ortc = __webpack_require__(8046);
const errors_1 = __webpack_require__(4893);
const scalabilityModes_1 = __webpack_require__(3303);
const sdpCommonUtils = __webpack_require__(5544);
const sdpUnifiedPlanUtils = __webpack_require__(5938);
const ortcUtils = __webpack_require__(4256);
const RemoteSdp_1 = __webpack_require__(1305);
const logger = new Logger_1.Logger('Chrome74');
const NAME = 'Chrome74';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome74 extends enhancedEvents_1.EnhancedEventEmitter {
    // Closed flag.
    _closed = false;
    // Handler direction.
    _direction;
    // Remote SDP handler.
    _remoteSdp;
    // Callback to request sending extended RTP capabilities on demand.
    _getSendExtendedRtpCapabilities;
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _forcedLocalDtlsRole;
    // RTCPeerConnection instance.
    _pc;
    // Map of RTCTransceivers indexed by MID.
    _mapMidTransceiver = new Map();
    // Local stream for sending.
    _sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _transportReady = false;
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return {
            name: NAME,
            factory: (options) => new Chrome74(options),
            getNativeRtpCapabilities: async () => {
                logger.debug('getNativeRtpCapabilities()');
                let pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                });
                try {
                    pc.addTransceiver('audio');
                    pc.addTransceiver('video');
                    const offer = await pc.createOffer();
                    try {
                        pc.close();
                    }
                    catch (error) { }
                    pc = undefined;
                    const sdpObject = sdpTransform.parse(offer.sdp);
                    const nativeRtpCapabilities = Chrome74.getLocalRtpCapabilities(sdpObject);
                    return nativeRtpCapabilities;
                }
                catch (error) {
                    try {
                        pc?.close();
                    }
                    catch (error2) { }
                    pc = undefined;
                    throw error;
                }
            },
            getNativeSctpCapabilities: async () => {
                logger.debug('getNativeSctpCapabilities()');
                return {
                    numStreams: SCTP_NUM_STREAMS,
                };
            },
        };
    }
    static getLocalRtpCapabilities(localSdpObject) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
            sdpObject: localSdpObject,
        });
        // Need to validate and normalize native RTP capabilities.
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        // libwebrtc supports NACK for OPUS but doesn't announce it.
        ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
        return nativeRtpCapabilities;
    }
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities, }) {
        super();
        logger.debug('constructor()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        });
        this._pc.addEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.addEventListener('icecandidateerror', this.onIceCandidateError);
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', this.onConnectionStateChange);
        }
        else {
            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
            this._pc.addEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        }
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        try {
            this._pc.close();
        }
        catch (error) { }
        this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
        this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
        this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        this.emit('@close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
            this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const nativeRtpCapabilities = Chrome74.getLocalRtpCapabilities(localSdpObject);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        // Generic sending RTP parameters.
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        // Generic sending RTP parameters suitable for the SDP remote answer.
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        let offerMediaObject;
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
            });
            offer = {
                type: 'offer',
                sdp: sdpTransform.write(localSdpObject),
            };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            // Hack for VP9 SVC.
            if (hackVp9Svc) {
                newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = {
            type: 'answer',
            sdp: sdpTransform.write(localSdpObject),
        };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver,
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    onIceGatheringStateChange = () => {
        this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
    };
    onIceCandidateError = (event) => {
        this.emit('@icecandidateerror', event);
    };
    onConnectionStateChange = () => {
        this.emit('@connectionstatechange', this._pc.connectionState);
    };
    onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
            case 'checking': {
                this.emit('@connectionstatechange', 'connecting');
                break;
            }
            case 'connected':
            case 'completed': {
                this.emit('@connectionstatechange', 'connected');
                break;
            }
            case 'failed': {
                this.emit('@connectionstatechange', 'failed');
                break;
            }
            case 'disconnected': {
                this.emit('@connectionstatechange', 'disconnected');
                break;
            }
            case 'closed': {
                this.emit('@connectionstatechange', 'closed');
                break;
            }
        }
    };
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome74 = Chrome74;


/***/ }),

/***/ 19:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3009), __webpack_require__(1025));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA256
	         * @property {number} iterations The number of iterations to perform. Default: 250000
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA256,
	            iterations: 250000
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));

/***/ }),

/***/ 25:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),

/***/ 76:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
__webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports.s$ = __webpack_unused_export__ = __webpack_unused_export__ = exports.pF = __webpack_unused_export__ = __webpack_unused_export__ = void 0;
const debug_1 = __webpack_require__(7833);
__webpack_unused_export__ = debug_1.default;
/**
 * Expose all types.
 */
/* unused reexport */ __webpack_require__(8057);
/**
 * Expose mediasoup-client version.
 */
__webpack_unused_export__ = '3.15.5';
/**
 * Expose Device class and device detector helpers.
 */
var Device_1 = __webpack_require__(6004);
Object.defineProperty(exports, "pF", ({ enumerable: true, get: function () { return Device_1.Device; } }));
__webpack_unused_export__ = ({ enumerable: true, get: function () { return Device_1.detectDevice; } });
__webpack_unused_export__ = ({ enumerable: true, get: function () { return Device_1.detectDeviceAsync; } });
/**
 * Expose parseScalabilityMode() function.
 */
var scalabilityModes_1 = __webpack_require__(3303);
Object.defineProperty(exports, "s$", ({ enumerable: true, get: function () { return scalabilityModes_1.parse; } }));
/**
 * Expose all ORTC functions.
 */
/* unused reexport */ __webpack_require__(8046);
/**
 * Expose enhanced events.
 */
/* unused reexport */ __webpack_require__(3953);
/**
 * Expose FakeHandler.
 */
var FakeHandler_1 = __webpack_require__(2731);
__webpack_unused_export__ = ({ enumerable: true, get: function () { return FakeHandler_1.FakeHandler; } });
/**
 * Expose test/fakeParameters utils.
 */
/* unused reexport */ __webpack_require__(5248);


/***/ }),

/***/ 296:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ _slicedToArray)
});

;// ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

;// ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
var unsupportedIterableToArray = __webpack_require__(7800);
;// ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

;// ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || (0,unsupportedIterableToArray/* default */.A)(r, e) || _nonIterableRest();
}


/***/ }),

/***/ 328:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
__webpack_require__(8624);
module.exports = self.fetch.bind(self);


/***/ }),

/***/ 388:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ _possibleConstructorReturn)
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(2284);
;// ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

;// ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(t, e) {
  if (e && ("object" == (0,esm_typeof/* default */.A)(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}


/***/ }),

/***/ 467:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _asyncToGenerator)
/* harmony export */ });
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}


/***/ }),

/***/ 477:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 482:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));

/***/ }),

/***/ 579:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(3738)["default"]);
function _regeneratorValues(e) {
  if (null != e) {
    var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"],
      r = 0;
    if (t) return t.call(e);
    if ("function" == typeof e.next) return e;
    if (!isNaN(e.length)) return {
      next: function next() {
        return e && r >= e.length && (e = void 0), {
          value: e && e[r++],
          done: !e
        };
      }
    };
  }
  throw new TypeError(_typeof(e) + " is not iterable");
}
module.exports = _regeneratorValues, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 736:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(6585);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(/\s+/g, ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 754:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),

/***/ 816:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ toPropertyKey)
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(2284);
;// ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function toPrimitive(t, r) {
  if ("object" != (0,esm_typeof/* default */.A)(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != (0,esm_typeof/* default */.A)(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

;// ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == (0,esm_typeof/* default */.A)(i) ? i : i + "";
}


/***/ }),

/***/ 867:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReactNative106 = void 0;
const sdpTransform = __webpack_require__(7363);
const enhancedEvents_1 = __webpack_require__(3953);
const Logger_1 = __webpack_require__(2994);
const ortc = __webpack_require__(8046);
const errors_1 = __webpack_require__(4893);
const scalabilityModes_1 = __webpack_require__(3303);
const RemoteSdp_1 = __webpack_require__(1305);
const sdpCommonUtils = __webpack_require__(5544);
const sdpUnifiedPlanUtils = __webpack_require__(5938);
const ortcUtils = __webpack_require__(4256);
const logger = new Logger_1.Logger('ReactNative106');
const NAME = 'ReactNative106';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class ReactNative106 extends enhancedEvents_1.EnhancedEventEmitter {
    // Closed flag.
    _closed = false;
    // Handler direction.
    _direction;
    // Remote SDP handler.
    _remoteSdp;
    // Callback to request sending extended RTP capabilities on demand.
    _getSendExtendedRtpCapabilities;
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _forcedLocalDtlsRole;
    // RTCPeerConnection instance.
    _pc;
    // Map of RTCTransceivers indexed by MID.
    _mapMidTransceiver = new Map();
    // Local stream for sending.
    _sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _transportReady = false;
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return {
            name: NAME,
            factory: (options) => new ReactNative106(options),
            getNativeRtpCapabilities: async () => {
                logger.debug('getNativeRtpCapabilities()');
                let pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                });
                try {
                    pc.addTransceiver('audio');
                    pc.addTransceiver('video');
                    const offer = await pc.createOffer();
                    try {
                        pc.close();
                    }
                    catch (error) { }
                    pc = undefined;
                    const sdpObject = sdpTransform.parse(offer.sdp);
                    const nativeRtpCapabilities = ReactNative106.getLocalRtpCapabilities(sdpObject);
                    return nativeRtpCapabilities;
                }
                catch (error) {
                    try {
                        pc?.close();
                    }
                    catch (error2) { }
                    pc = undefined;
                    throw error;
                }
            },
            getNativeSctpCapabilities: async () => {
                logger.debug('getNativeSctpCapabilities()');
                return {
                    numStreams: SCTP_NUM_STREAMS,
                };
            },
        };
    }
    static getLocalRtpCapabilities(localSdpObject) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
            sdpObject: localSdpObject,
        });
        // Need to validate and normalize native RTP capabilities.
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        // libwebrtc supports NACK for OPUS but doesn't announce it.
        ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
        return nativeRtpCapabilities;
    }
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities, }) {
        super();
        logger.debug('constructor()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        });
        this._pc.addEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.addEventListener('icecandidateerror', this.onIceCandidateError);
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', this.onConnectionStateChange);
        }
        else {
            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
            this._pc.addEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        }
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Free/dispose native MediaStream but DO NOT free/dispose native
        // MediaStreamTracks (that is parent's business).
        // @ts-expect-error --- Proprietary API in react-native-webrtc.
        this._sendStream.release(/* releaseTracks */ false);
        // Close RTCPeerConnection.
        try {
            this._pc.close();
        }
        catch (error) { }
        this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
        this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
        this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        this.emit('@close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
            this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const nativeRtpCapabilities = ReactNative106.getLocalRtpCapabilities(localSdpObject);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        // Generic sending RTP parameters.
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        // Generic sending RTP parameters suitable for the SDP remote answer.
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        // Special case for VP9 with SVC.
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        let offerMediaObject;
        if (encodings &&
            encodings.length === 1 &&
            layers.spatialLayers > 1 &&
            sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
            logger.debug('send() | enabling legacy simulcast for VP9 SVC');
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: layers.spatialLayers,
            });
            offer = {
                type: 'offer',
                sdp: sdpTransform.write(localSdpObject),
            };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        // NOTE: We cannot read generated MID on iOS react-native-webrtc 111.0.0
        // because transceiver.mid is not available until setRemoteDescription()
        // is called, so this is best effort.
        // Issue: https://github.com/react-native-webrtc/react-native-webrtc/issues/1404
        // NOTE: So let's fill MID in sendingRtpParameters later.
        // NOTE: This is fixed in react-native-webrtc 111.0.3.
        let localId = transceiver.mid ?? undefined;
        if (!localId) {
            logger.warn('send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround');
        }
        // Set MID.
        // NOTE: As per above, it could be unset yet.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            // Hack for VP9 SVC.
            if (hackVp9Svc) {
                newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Follow up of iOS react-native-webrtc 111.0.0 issue told above. Now yes,
        // we can read generated MID (if not done above) and fill sendingRtpParameters.
        // NOTE: This is fixed in react-native-webrtc 111.0.3 so this block isn't
        // needed starting from that version.
        if (!localId) {
            localId = transceiver.mid;
            sendingRtpParameters.mid = localId;
        }
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        if (this._closed) {
            return;
        }
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = {
            type: 'answer',
            sdp: sdpTransform.write(localSdpObject),
        };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver,
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    onIceGatheringStateChange = () => {
        this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
    };
    onIceCandidateError = (event) => {
        this.emit('@icecandidateerror', event);
    };
    onConnectionStateChange = () => {
        this.emit('@connectionstatechange', this._pc.connectionState);
    };
    onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
            case 'checking': {
                this.emit('@connectionstatechange', 'connecting');
                break;
            }
            case 'connected':
            case 'completed': {
                this.emit('@connectionstatechange', 'connected');
                break;
            }
            case 'failed': {
                this.emit('@connectionstatechange', 'failed');
                break;
            }
            case 'disconnected': {
                this.emit('@connectionstatechange', 'disconnected');
                break;
            }
            case 'closed': {
                this.emit('@connectionstatechange', 'closed');
                break;
            }
        }
    };
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.ReactNative106 = ReactNative106;


/***/ }),

/***/ 878:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FakeEvent = void 0;
// NOTE: Do not use our FakeEventTarget type inside this class, otherwise TS
// will complain because "Property 'listeners' is missing in type 'EventTarget'
// but required in type 'FakeEventTarget'".
class FakeEvent {
    /**
     * Constants.
     */
    NONE = 0;
    CAPTURING_PHASE = 1;
    AT_TARGET = 2;
    BUBBLING_PHASE = 3;
    /**
     * Members.
     */
    type;
    bubbles;
    cancelable;
    defaultPrevented = false;
    composed = false;
    currentTarget = null;
    // Not implemented.
    eventPhase = this.NONE;
    isTrusted = true;
    target = null;
    timeStamp = 0;
    // Deprecated.
    cancelBubble = false;
    returnValue = true;
    srcElement = null;
    constructor(type, options = {}) {
        this.type = type;
        this.bubbles = options.bubbles ?? false;
        this.cancelable = options.cancelable ?? false;
    }
    preventDefault() {
        if (this.cancelable) {
            this.defaultPrevented = true;
        }
    }
    /**
     * Not implemented.
     */
    stopPropagation() { }
    /**
     * Not implemented.
     */
    stopImmediatePropagation() { }
    /**
     * Not implemented.
     */
    composedPath() {
        return [];
    }
    /**
     * Not implemented.
     * @deprecated
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    initEvent(type, bubbles, cancelable) {
        // Not implemented.
    }
}
exports.FakeEvent = FakeEvent;


/***/ }),

/***/ 887:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var regenerator = __webpack_require__(6993);
var regeneratorAsyncIterator = __webpack_require__(1791);
function _regeneratorAsyncGen(r, e, t, o, n) {
  return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
}
module.exports = _regeneratorAsyncGen, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 955:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),

/***/ 1025:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),

/***/ 1305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoteSdp = void 0;
const sdpTransform = __webpack_require__(7363);
const Logger_1 = __webpack_require__(2994);
const MediaSection_1 = __webpack_require__(3471);
const DD_CODECS = ['av1', 'h264'];
const logger = new Logger_1.Logger('RemoteSdp');
class RemoteSdp {
    // Remote ICE parameters.
    _iceParameters;
    // Remote ICE candidates.
    _iceCandidates;
    // Remote DTLS parameters.
    _dtlsParameters;
    // Remote SCTP parameters.
    _sctpParameters;
    // Parameters for plain RTP (no SRTP nor DTLS no BUNDLE).
    _plainRtpParameters;
    // MediaSection instances with same order as in the SDP.
    _mediaSections = [];
    // MediaSection indices indexed by MID.
    _midToIndex = new Map();
    // First MID.
    _firstMid;
    // SDP object.
    _sdpObject;
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, }) {
        this._iceParameters = iceParameters;
        this._iceCandidates = iceCandidates;
        this._dtlsParameters = dtlsParameters;
        this._sctpParameters = sctpParameters;
        this._plainRtpParameters = plainRtpParameters;
        this._sdpObject = {
            version: 0,
            origin: {
                address: '0.0.0.0',
                ipVer: 4,
                netType: 'IN',
                sessionId: '10000',
                sessionVersion: 0,
                username: 'mediasoup-client',
            },
            name: '-',
            timing: { start: 0, stop: 0 },
            media: [],
        };
        // If ICE parameters are given, add ICE-Lite indicator.
        if (iceParameters?.iceLite) {
            this._sdpObject.icelite = 'ice-lite';
        }
        // If DTLS parameters are given, assume WebRTC and BUNDLE.
        if (dtlsParameters) {
            this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' };
            // NOTE: We take the latest fingerprint.
            const numFingerprints = this._dtlsParameters.fingerprints.length;
            this._sdpObject.fingerprint = {
                type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
                hash: dtlsParameters.fingerprints[numFingerprints - 1].value,
            };
            this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }];
        }
        // If there are plain RPT parameters, override SDP origin.
        if (plainRtpParameters) {
            this._sdpObject.origin.address = plainRtpParameters.ip;
            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
        }
    }
    updateIceParameters(iceParameters) {
        logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);
        this._iceParameters = iceParameters;
        this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;
        for (const mediaSection of this._mediaSections) {
            mediaSection.setIceParameters(iceParameters);
        }
    }
    updateDtlsRole(role) {
        logger.debug('updateDtlsRole() [role:%s]', role);
        this._dtlsParameters.role = role;
        for (const mediaSection of this._mediaSections) {
            mediaSection.setDtlsRole(role);
        }
    }
    /**
     * Set session level a=extmap-allow-mixed attibute.
     */
    setSessionExtmapAllowMixed() {
        logger.debug('setSessionExtmapAllowMixed()');
        this._sdpObject.extmapAllowMixed = 'extmap-allow-mixed';
    }
    getNextMediaSectionIdx() {
        // If a closed media section is found, return its index.
        for (let idx = 0; idx < this._mediaSections.length; ++idx) {
            const mediaSection = this._mediaSections[idx];
            if (mediaSection.closed) {
                return { idx, reuseMid: mediaSection.mid };
            }
        }
        // If no closed media section is found, return next one.
        return { idx: this._mediaSections.length };
    }
    send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            plainRtpParameters: this._plainRtpParameters,
            offerMediaObject,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
        });
        const mediaObject = mediaSection.getObject();
        // Remove Dependency Descriptor extension unless there is support for
        // the codec in mediasoup.
        const ddCodec = mediaObject.rtp.find(rtp => DD_CODECS.includes(rtp.codec.toLowerCase()));
        if (!ddCodec) {
            mediaObject.ext = mediaObject.ext?.filter(extmap => extmap.uri !==
                'https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension');
        }
        // Unified-Plan with closed media section replacement.
        if (reuseMid) {
            this._replaceMediaSection(mediaSection, reuseMid);
        }
        // Unified-Plan or Plan-B with different media kind.
        else if (!this._midToIndex.has(mediaSection.mid)) {
            this._addMediaSection(mediaSection);
        }
        // Plan-B with same media kind.
        else {
            this._replaceMediaSection(mediaSection);
        }
    }
    receive({ mid, kind, offerRtpParameters, streamId, trackId, }) {
        // Allow both 1 byte and 2 bytes length header extensions since
        // mediasoup can send both at any time.
        this.setSessionExtmapAllowMixed();
        const mediaSection = new MediaSection_1.OfferMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            plainRtpParameters: this._plainRtpParameters,
            mid,
            kind,
            offerRtpParameters,
            streamId,
            trackId,
        });
        // Let's try to recycle a closed media section (if any).
        // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
        const oldMediaSection = this._mediaSections.find(m => m.closed);
        if (oldMediaSection) {
            this._replaceMediaSection(mediaSection, oldMediaSection.mid);
        }
        else {
            this._addMediaSection(mediaSection);
        }
    }
    pauseMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.pause();
    }
    resumeSendingMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.resume();
    }
    resumeReceivingMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.resume();
    }
    disableMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.disable();
    }
    /**
     * Closes media section. Returns true if the given MID corresponds to a m
     * section that has been indeed closed. False otherwise.
     *
     * NOTE: Closing the first m section is a pain since it invalidates the bundled
     * transport, so instead closing it we just disable it.
     */
    closeMediaSection(mid) {
        const mediaSection = this._findMediaSection(mid);
        // NOTE: Closing the first m section is a pain since it invalidates the
        // bundled transport, so let's avoid it.
        if (mid === this._firstMid) {
            logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);
            this.disableMediaSection(mid);
            return false;
        }
        mediaSection.close();
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
        return true;
    }
    muxMediaSectionSimulcast(mid, encodings) {
        const mediaSection = this._findMediaSection(mid);
        mediaSection.muxSimulcastStreams(encodings);
        this._replaceMediaSection(mediaSection);
    }
    sendSctpAssociation({ offerMediaObject, }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            offerMediaObject,
        });
        this._addMediaSection(mediaSection);
    }
    receiveSctpAssociation() {
        const mediaSection = new MediaSection_1.OfferMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            mid: 'datachannel',
            kind: 'application',
        });
        this._addMediaSection(mediaSection);
    }
    getSdp() {
        // Increase SDP version.
        this._sdpObject.origin.sessionVersion++;
        return sdpTransform.write(this._sdpObject);
    }
    _addMediaSection(newMediaSection) {
        if (!this._firstMid) {
            this._firstMid = newMediaSection.mid;
        }
        // Add to the vector.
        this._mediaSections.push(newMediaSection);
        // Add to the map.
        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
        // Add to the SDP object.
        this._sdpObject.media.push(newMediaSection.getObject());
        // Regenerate BUNDLE mids.
        this._regenerateBundleMids();
    }
    _replaceMediaSection(newMediaSection, reuseMid) {
        // Store it in the map.
        if (typeof reuseMid === 'string') {
            const idx = this._midToIndex.get(reuseMid);
            if (idx === undefined) {
                throw new Error(`no media section found for reuseMid '${reuseMid}'`);
            }
            const oldMediaSection = this._mediaSections[idx];
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the map.
            this._midToIndex.delete(oldMediaSection.mid);
            this._midToIndex.set(newMediaSection.mid, idx);
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
            // Regenerate BUNDLE mids.
            this._regenerateBundleMids();
        }
        else {
            const idx = this._midToIndex.get(newMediaSection.mid);
            if (idx === undefined) {
                throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
            }
            // Replace the index in the vector with the new media section.
            this._mediaSections[idx] = newMediaSection;
            // Update the SDP object.
            this._sdpObject.media[idx] = newMediaSection.getObject();
        }
    }
    _findMediaSection(mid) {
        const idx = this._midToIndex.get(mid);
        if (idx === undefined) {
            throw new Error(`no media section found with mid '${mid}'`);
        }
        return this._mediaSections[idx];
    }
    _regenerateBundleMids() {
        if (!this._dtlsParameters) {
            return;
        }
        this._sdpObject.groups[0].mids = this._mediaSections
            .filter((mediaSection) => !mediaSection.closed)
            .map((mediaSection) => mediaSection.mid)
            .join(' ');
    }
}
exports.RemoteSdp = RemoteSdp;


/***/ }),

/***/ 1380:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3240));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                var Wil;
	                var Wih;

	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    Wih = Wi.high = M[offset + i * 2]     | 0;
	                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    Wil = gamma0l + Wi7l;
	                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    Wil = Wil + gamma1l;
	                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    Wil = Wil + Wi16l;
	                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));

/***/ }),

/***/ 1396:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3240), __webpack_require__(6440), __webpack_require__(5503), __webpack_require__(754), __webpack_require__(4725), __webpack_require__(4636), __webpack_require__(5471), __webpack_require__(3009), __webpack_require__(6308), __webpack_require__(1380), __webpack_require__(9557), __webpack_require__(5953), __webpack_require__(8056), __webpack_require__(1025), __webpack_require__(19), __webpack_require__(9506), __webpack_require__(7165), __webpack_require__(2169), __webpack_require__(6939), __webpack_require__(6372), __webpack_require__(3797), __webpack_require__(8454), __webpack_require__(2073), __webpack_require__(4905), __webpack_require__(482), __webpack_require__(2155), __webpack_require__(8124), __webpack_require__(25), __webpack_require__(955), __webpack_require__(7628), __webpack_require__(7193), __webpack_require__(6298), __webpack_require__(2696), __webpack_require__(3128));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),

/***/ 1765:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clone = clone;
exports.generateRandomNumber = generateRandomNumber;
exports.deepFreeze = deepFreeze;
/**
 * Clones the given value.
 */
function clone(value) {
    if (value === undefined) {
        return undefined;
    }
    else if (Number.isNaN(value)) {
        return NaN;
    }
    else if (typeof structuredClone === 'function') {
        // Available in Node >= 18.
        return structuredClone(value);
    }
    else {
        return JSON.parse(JSON.stringify(value));
    }
}
/**
 * Generates a random positive integer.
 */
function generateRandomNumber() {
    return Math.round(Math.random() * 10000000);
}
/**
 * Make an object or array recursively immutable.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze.
 */
function deepFreeze(data) {
    // Retrieve the property names defined on object.
    const propNames = Reflect.ownKeys(data);
    // Freeze properties before freezing self.
    for (const name of propNames) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const value = data[name];
        if ((value && typeof value === 'object') || typeof value === 'function') {
            deepFreeze(value);
        }
    }
    return Object.freeze(data);
}


/***/ }),

/***/ 1791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var OverloadYield = __webpack_require__(5172);
var regeneratorDefine = __webpack_require__(5546);
function AsyncIterator(t, e) {
  function n(r, o, i, f) {
    try {
      var c = t[r](o),
        u = c.value;
      return u instanceof OverloadYield ? e.resolve(u.v).then(function (t) {
        n("next", t, i, f);
      }, function (t) {
        n("throw", t, i, f);
      }) : e.resolve(u).then(function (t) {
        c.value = t, i(c);
      }, function (t) {
        return n("throw", t, i, f);
      });
    } catch (t) {
      f(t);
    }
  }
  var r;
  this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function () {
    return this;
  })), regeneratorDefine(this, "_invoke", function (t, o, i) {
    function f() {
      return new e(function (e, r) {
        n(t, i, e, r);
      });
    }
    return r = r ? r.then(f, f) : f();
  }, !0);
}
module.exports = AsyncIterator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 1803:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ed: () => (/* binding */ getAdaptivePrefferedLayers),
/* harmony export */   sg: () => (/* binding */ debounce),
/* harmony export */   v7: () => (/* binding */ computeVideoEncodings)
/* harmony export */ });
/* unused harmony exports presets169, presets43, presetsScreenShare, defaultSimulcastPresets169, defaultSimulcastPresets43, computeDefaultScreenShareSimulcastPresets, determineAppropriateEncoding, presetsForResolution, defaultSimulcastLayers, sortPresets, isVideoInView */
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4467);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(296);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9027);


function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

var videoPresets169 = {};
var videoPresets43 = {};
var screenPresets = {};
for (var key in _config__WEBPACK_IMPORTED_MODULE_2__/* .config */ .$.videoProfiles) {
  if (_config__WEBPACK_IMPORTED_MODULE_2__/* .config */ .$.videoProfiles[key].aspectRatio == "oneSixNine") {
    videoPresets169[key] = _config__WEBPACK_IMPORTED_MODULE_2__/* .config */ .$.videoProfiles[key];
    videoPresets169[key].encoding = {
      maxBitrate: videoPresets169[key].bitRate,
      maxFramerate: videoPresets169[key].frameRate
    };
  }
  if (_config__WEBPACK_IMPORTED_MODULE_2__/* .config */ .$.videoProfiles[key].aspectRatio == "fourThree") {
    videoPresets43[key] = _config__WEBPACK_IMPORTED_MODULE_2__/* .config */ .$.videoProfiles[key];
    videoPresets43[key].encoding = {
      maxBitrate: videoPresets43[key].bitRate,
      maxFramerate: videoPresets43[key].frameRate
    };
  }
}
for (var key in _config__WEBPACK_IMPORTED_MODULE_2__/* .config */ .$.screenShareProfiles) {
  screenPresets[key] = _config__WEBPACK_IMPORTED_MODULE_2__/* .config */ .$.screenShareProfiles[key];
  screenPresets[key].encoding = {
    maxBitrate: screenPresets[key].bitRate,
    maxFramerate: screenPresets[key].frameRate
  };
}
var presets169 = Object.values(videoPresets169);
var presets43 = Object.values(videoPresets43);
var presetsScreenShare = Object.values(screenPresets);

/* @internal */
var defaultSimulcastPresets169 = [videoPresets169.h180p_w320p, videoPresets169.h360p_w640p];

/* @internal */
var defaultSimulcastPresets43 = [videoPresets43.h180p_w240p, videoPresets43.h360p_w480p];

/* @internal */
var computeDefaultScreenShareSimulcastPresets = function computeDefaultScreenShareSimulcastPresets(fromPreset) {
  var layers = [{
    scaleResolutionDownBy: 2,
    fps: 3
  }];
  return layers.map(function (t) {
    var _fromPreset$encoding$;
    return {
      width: Math.floor(fromPreset.width / t.scaleResolutionDownBy),
      height: Math.floor(fromPreset.height / t.scaleResolutionDownBy),
      encodings: {
        maxBitrate: Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_fromPreset$encoding$ = fromPreset.encoding.maxFramerate) !== null && _fromPreset$encoding$ !== void 0 ? _fromPreset$encoding$ : 30) / t.fps)))),
        maxFramerate: t.fps
      }
    };
  });
};
var videoRids = ["q", "h", "f"];

/* @internal */
function computeVideoEncodings(isScreenShare, actualWidth, actualHeight, encoderConfig, options, isRNiOS) {
  var videoEncoding = options && options.videoEncoding;
  if (isScreenShare) {
    videoEncoding = options && options.screenShareEncoding;
  }
  var useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;

  // if ((!videoEncoding && !useSimulcast) || !width || !height) {
  //   // when we aren't simulcasting, will need to return a single encoding without
  //   // capping bandwidth. we always require a encoding for dynacast
  //   return [{}];
  // }

  if (!videoEncoding) {
    // find the right encoding based on width/height
    videoEncoding = determineAppropriateEncoding(isScreenShare, actualWidth, actualHeight, encoderConfig);
  }
  if (!useSimulcast) {
    return [videoEncoding];
  }
  var videoProfile = _config__WEBPACK_IMPORTED_MODULE_2__/* .config */ .$.videoProfiles[encoderConfig];
  var width = actualWidth ? actualWidth : videoProfile === null || videoProfile === void 0 ? void 0 : videoProfile.width;
  var height = actualHeight ? actualHeight : videoProfile === null || videoProfile === void 0 ? void 0 : videoProfile.height;
  var original = {
    width: width,
    height: height,
    encoding: {
      maxBitrate: videoEncoding.maxBitrate,
      maxFramerate: videoEncoding.maxFramerate
    }
  };
  var presets = [];
  if (isScreenShare) {
    presets = defaultSimulcastLayers(isScreenShare, original);
  } else {
    presets = defaultSimulcastLayers(isScreenShare, original);
  }
  var midPreset;
  var lowPreset = presets[0];
  if (presets.length > 1) {
    var _presets = presets;
    var _presets2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(_presets, 2);
    midPreset = _presets2[1];
  }

  // NOTE:
  //   1. Ordering of these encodings is important. Chrome seems
  //      to use the index into encodings to decide which layer
  //      to disable when CPU constrained.
  //      So encodings should be ordered in increasing spatial
  //      resolution order.
  //   2. ion-sfu translates rids into layers. So, all encodings
  //      should have the base layer `q` and then more added
  //      based on other conditions.
  var size = Math.max(width, height);
  if (size >= 960 && midPreset) {
    return encodingsFromPresets(width, height, [lowPreset, midPreset, original], isRNiOS);
  }
  if (size >= 480) {
    return encodingsFromPresets(width, height, [lowPreset, original], isRNiOS);
  }
  return encodingsFromPresets(width, height, [original], isRNiOS);
}

/* @internal */
function determineAppropriateEncoding(isScreenShare, width, height, encoderConfig) {
  var videoProfile = _config__WEBPACK_IMPORTED_MODULE_2__/* .config */ .$.videoProfiles[encoderConfig];
  var presets = presetsForResolution(isScreenShare, width ? width : videoProfile === null || videoProfile === void 0 ? void 0 : videoProfile.width, height ? height : videoProfile === null || videoProfile === void 0 ? void 0 : videoProfile.height, encoderConfig);
  var encoding = presets[0].encoding;

  // handle portrait by swapping dimensions
  var size = Math.max(width, height);
  for (var i = 0; i < presets.length; i += 1) {
    var preset = presets[i];
    encoding = preset.encoding;
    if (videoProfile) {
      if (preset.width == videoProfile.width && preset.height == videoProfile.height && preset.encoding.maxBitrate == videoProfile.encoding.maxBitrate) {
        break;
      }
    } else {
      if (preset.width >= size) {
        break;
      }
    }
  }
  return encoding;
}

/* @internal */
function presetsForResolution(isScreenShare, width, height) {
  if (isScreenShare) {
    return presetsScreenShare;
  }
  var aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {
    return presets169;
  }
  return presets43;
}

/* @internal */
function defaultSimulcastLayers(isScreenShare, original) {
  if (isScreenShare) {
    var defaultScreen = computeDefaultScreenShareSimulcastPresets(original);
  }
  var width = original.width,
    height = original.height;
  var aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {
    return defaultSimulcastPresets169;
  }
  return defaultSimulcastPresets43;
}

// presets should be ordered by low, medium, high
function encodingsFromPresets(width, height, presets, isRNiOS) {
  var encodings = [];
  presets.forEach(function (preset, idx) {
    if (idx >= videoRids.length) {
      return;
    }
    var maxFramerate = isRNiOS ? null : {
      maxFramerate: preset.encoding.maxFramerate
    };
    var size = Math.min(width, height);
    var rid = videoRids[idx];
    var encoding = _objectSpread({
      rid: rid,
      scaleResolutionDownBy: size / Math.min(preset.width, preset.height),
      maxBitrate: preset.encoding.maxBitrate
    }, maxFramerate);
    encodings.push(encoding);
  });
  return encodings;
}

/** @internal */
function sortPresets(presets) {
  if (!presets) return;
  return presets.sort(function (a, b) {
    var aEnc = a.encoding;
    var bEnc = b.encoding;
    if (aEnc.maxBitrate > bEnc.maxBitrate) {
      return 1;
    }
    if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;
    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {
      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;
    }
    return 0;
  });
}

/**
 * Validates the simulcast `encodings` array extracting the resolution scalings
 * array.
 * ref. https://www.w3.org/TR/webrtc/#rtp-media-api
 *
 * @param {*} encodings
 * @returns the resolution scalings array
 */
function getResolutionScalings(encodings) {
  var resolutionScalings = [];
  if (!encodings || encodings.length == 0) return;

  // SVC encodings
  if (encodings.length === 1) {
    // const { spatialLayers } =
    // mediasoupClient.parseScalabilityMode(encodings[0].scalabilityMode);

    var spatialLayers = 3;
    for (var i = 0; i < spatialLayers; i++) {
      resolutionScalings.push(Math.pow(2, spatialLayers - i - 1));
    }
    return resolutionScalings;
  }

  // Simulcast encodings
  var scaleResolutionDownByDefined = false;
  encodings.forEach(function (encoding) {
    if (encoding.scaleResolutionDownBy !== undefined) {
      // at least one scaleResolutionDownBy is defined
      scaleResolutionDownByDefined = true;
      // scaleResolutionDownBy must be >= 1.0
      resolutionScalings.push(Math.max(1.0, encoding.scaleResolutionDownBy));
    } else {
      // If encodings contains any encoding whose scaleResolutionDownBy
      // attribute is defined, set any undefined scaleResolutionDownBy
      // of the other encodings to 1.0.
      resolutionScalings.push(1.0);
    }
  });

  // If the scaleResolutionDownBy attribues of sendEncodings are
  // still undefined, initialize each encoding's scaleResolutionDownBy
  // to 2^(length of sendEncodings - encoding index - 1).
  if (!scaleResolutionDownByDefined) {
    encodings.forEach(function (encoding, index) {
      resolutionScalings[index] = Math.pow(2, encodings.length - index - 1);
    });
  }
  return resolutionScalings;
}

/** @internal */
function getAdaptivePrefferedLayers(consumer, viewportWidth, viewportHeight) {
  if (!consumer) {
    return {};
  }
  var id = consumer.id;
  var _consumer$appData = consumer.appData,
    width = _consumer$appData.width,
    height = _consumer$appData.height,
    encodings = _consumer$appData.encodings;
  try {
    var resolutionScalings = getResolutionScalings(encodings);
    if (!resolutionScalings) {
      return {};
    }
    var resolutions = resolutionScalings.map(function (scaling) {
      return {
        width: width / scaling,
        height: height / scaling
      };
    });
    var sortedResolutions = resolutions.sort(function (a, b) {
      return a.width - b.width;
    });
    var newPreferredSpatialLayer = sortedResolutions.findIndex(function (res) {
      return res.width >= viewportWidth && res.height >= viewportHeight;
    });
    if (newPreferredSpatialLayer === -1) {
      newPreferredSpatialLayer = sortedResolutions.length - 1;
    }
    var newPreferredTemporalLayer = consumer.temporalLayers ? consumer.temporalLayers : 2;
    if (newPreferredSpatialLayer === 0 && newPreferredTemporalLayer > 0) {
      var lowestLevelWidth = width / resolutionScalings[0];
      var lowestLevelHeight = height / resolutionScalings[0];
      if (viewportWidth < lowestLevelWidth * 0.5 && viewportHeight < lowestLevelHeight * 0.5) {
        newPreferredTemporalLayer -= 1;
      }
      if (newPreferredTemporalLayer > 0 && viewportWidth < lowestLevelWidth * 0.25 && viewportHeight < lowestLevelHeight * 0.25) {
        newPreferredTemporalLayer -= 1;
      }
    }
    return {
      consumerId: id,
      newPreferredSpatialLayer: Math.max(0, newPreferredSpatialLayer),
      newPreferredTemporalLayer: Math.max(0, newPreferredTemporalLayer)
    };
  } catch (error) {
    return {};
  }
}
function debounce(func, delay) {
  var timeout;
  return function () {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      return func.apply(_this, args);
    }, delay);
  };
}
function isVideoInView(rect) {
  var windowHeight = window.innerHeight || document.documentElement.clientHeight;
  var windowWidth = window.innerWidth || document.documentElement.clientWidth;
  var verticallyInView = rect.top < windowHeight && rect.bottom > 0;
  var horizontallyInView = rect.left < windowWidth && rect.right > 0;
  return verticallyInView && horizontallyInView;
}

/***/ }),

/***/ 1806:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $Q: () => (/* binding */ E2EE_FLAG),
/* harmony export */   T4: () => (/* binding */ KEY_PROVIDER_DEFAULTS),
/* harmony export */   Ts: () => (/* binding */ SUPPORTED_AUDIO_MIME_TYPES),
/* harmony export */   ue: () => (/* binding */ SUPPORTED_VIDEO_MIME_TYPES)
/* harmony export */ });
/* unused harmony exports ENCRYPTION_ALGORITHM, DECRYPTION_FAILURE_TOLERANCE, UNENCRYPTED_BYTES, IV_LENGTH, SALT, MAX_SIF_COUNT, MAX_SIF_DURATION */
var ENCRYPTION_ALGORITHM = 'AES-GCM';
// How many consecutive frames can fail decrypting before a particular key gets marked as invalid
var DECRYPTION_FAILURE_TOLERANCE = 10;
// We copy the first bytes of the VP8 payload unencrypted.
// For keyframes this is 10 bytes, for non-keyframes (delta) 3. See
//   https://tools.ietf.org/html/rfc6386#section-9.1
// This allows the bridge to continue detecting keyframes (only one byte needed in the JVB)
// and is also a bit easier for the VP8 decoder (i.e. it generates funny garbage pictures
// instead of being unable to decode).
// This is a bit for show and we might want to reduce to 1 unconditionally in the final version.
//
// For audio (where frame.type is not set) we do not encrypt the opus TOC byte:
//   https://tools.ietf.org/html/rfc6716#section-3.1
var UNENCRYPTED_BYTES = {
  key: 10,
  delta: 3,
  audio: 1,
  // frame.type is not set on audio, so this is set manually
  empty: 0
};
/* We use a 12 byte bit IV. This is signalled in plain together with the
 packet. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters */
var IV_LENGTH = 12;
// flag set to indicate that e2ee has been setup for sender/receiver;
var E2EE_FLAG = 'vk_e2ee';
var SALT = 'VideoSDKEncryptionRatchetSalt';
var KEY_PROVIDER_DEFAULTS = {
  sharedKey: false,
  ratchetSalt: SALT,
  ratchetWindowSize: 0,
  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
  keyringSize: 16,
  discardFrameWhenCryptorNotReady: false
};
var MAX_SIF_COUNT = 100;
var MAX_SIF_DURATION = 2000;
var SUPPORTED_VIDEO_MIME_TYPES = ['vp8', 'vp9', 'h264', 'av1'];
var SUPPORTED_AUDIO_MIME_TYPES = ['opus'];

/***/ }),

/***/ 1853:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  CameraDeviceInfo: () => (/* reexport */ CameraDeviceInfo),
  DeviceInfo: () => (/* reexport */ DeviceInfo),
  ExternalE2EEKeyProvider: () => (/* reexport */ KeyProvider/* ExternalE2EEKeyProvider */.l),
  MicrophoneDeviceInfo: () => (/* reexport */ MicrophoneDeviceInfo),
  VideoSDK: () => (/* binding */ VideoSDK),
  ZujoSDK: () => (/* binding */ ZujoSDK)
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(2284);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(467);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__(3029);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__(2901);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(4467);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(4756);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);
// EXTERNAL MODULE: ./node_modules/bowser/es5.js
var es5 = __webpack_require__(6880);
var es5_default = /*#__PURE__*/__webpack_require__.n(es5);
;// ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      (0,defineProperty/* default */.A)(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

;// ./node_modules/redux/es/redux.js


/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

// Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
function miniKindOf(val) {
  if (val === void 0) return 'undefined';
  if (val === null) return 'null';
  var type = typeof val;

  switch (type) {
    case 'boolean':
    case 'string':
    case 'number':
    case 'symbol':
    case 'function':
      {
        return type;
      }
  }

  if (Array.isArray(val)) return 'array';
  if (isDate(val)) return 'date';
  if (isError(val)) return 'error';
  var constructorName = ctorName(val);

  switch (constructorName) {
    case 'Symbol':
    case 'Promise':
    case 'WeakMap':
    case 'WeakSet':
    case 'Map':
    case 'Set':
      return constructorName;
  } // other


  return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
}

function ctorName(val) {
  return typeof val.constructor === 'function' ? val.constructor.name : null;
}

function isError(val) {
  return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
}

function isDate(val) {
  if (val instanceof Date) return true;
  return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
}

function kindOf(val) {
  var typeOfVal = typeof val;

  if (false) // removed by dead control flow
{}

  return typeOfVal;
}

/**
 * @deprecated
 *
 * **We recommend using the `configureStore` method
 * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
 *
 * Redux Toolkit is our recommended approach for writing Redux logic today,
 * including store setup, reducers, data fetching, and more.
 *
 * **For more details, please read this Redux docs page:**
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * `configureStore` from Redux Toolkit is an improved version of `createStore` that
 * simplifies setup and helps avoid common bugs.
 *
 * You should not be using the `redux` core package by itself today, except for learning purposes.
 * The `createStore` method from the core `redux` package will not be removed, but we encourage
 * all users to migrate to using Redux Toolkit for all Redux code.
 *
 * If you want to use `createStore` without this visual deprecation warning, use
 * the `legacy_createStore` import instead:
 *
 * `import { legacy_createStore as createStore} from 'redux'`
 *
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error( true ? formatProdErrorMessage(0) : 0);
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error( true ? formatProdErrorMessage(1) : 0);
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error( true ? formatProdErrorMessage(2) : 0);
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(3) : 0);
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error( true ? formatProdErrorMessage(4) : 0);
    }

    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(5) : 0);
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error( true ? formatProdErrorMessage(6) : 0);
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error( true ? formatProdErrorMessage(7) : 0);
    }

    if (typeof action.type === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(8) : 0);
    }

    if (isDispatching) {
      throw new Error( true ? formatProdErrorMessage(9) : 0);
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error( true ? formatProdErrorMessage(10) : 0);
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error( true ? formatProdErrorMessage(11) : 0);
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
/**
 * Creates a Redux store that holds the state tree.
 *
 * **We recommend using `configureStore` from the
 * `@reduxjs/toolkit` package**, which replaces `createStore`:
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

var legacy_createStore = (/* unused pure expression or super */ null && (createStore));

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(12) : 0);
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error( true ? formatProdErrorMessage(13) : 0);
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (false) // removed by dead control flow
{}

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (false) // removed by dead control flow
{}

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (false) // removed by dead control flow
{ var warningMessage; }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var actionType = action && action.type;
        throw new Error( true ? formatProdErrorMessage(14) : 0);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error( true ? formatProdErrorMessage(16) : 0);
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error( true ? formatProdErrorMessage(15) : 0);
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}



;// ./node_modules/redux-thunk/es/index.js
/** A function that accepts a potential "extra argument" value to be injected later,
 * and returns an instance of the thunk middleware that uses that value
 */
function createThunkMiddleware(extraArgument) {
  // Standard Redux middleware definition pattern:
  // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware
  var middleware = function middleware(_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        // The thunk middleware looks for any functions that were passed to `store.dispatch`.
        // If this "action" is really a function, call it and return the result.
        if (typeof action === 'function') {
          // Inject the store's `dispatch` and `getState` methods, as well as any "extra arg"
          return action(dispatch, getState, extraArgument);
        } // Otherwise, pass the action down the middleware chain as usual


        return next(action);
      };
    };
  };

  return middleware;
}

var thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version
// with whatever "extra arg" they want to inject into their thunks

thunk.withExtraArgument = createThunkMiddleware;
/* harmony default export */ const es = (thunk);
// EXTERNAL MODULE: ./node_modules/random-string/lib/random-string.js
var random_string = __webpack_require__(2211);
var random_string_default = /*#__PURE__*/__webpack_require__.n(random_string);
;// ./src/lib/redux/reducers/room.js

function room_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? room_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : room_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var initialState = {
  url: null,
  state: 'new',
  // new/connecting/connected/disconnected/closed,
  activeSpeakerId: null,
  statsPeerId: null,
  faceDetection: false
};
var room = function room() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case 'SET_ROOM_URL':
      {
        var url = action.payload.url;
        return _objectSpread(_objectSpread({}, state), {}, {
          url: url
        });
      }
    case 'SET_ROOM_STATE':
      {
        var roomState = action.payload.state;
        if (roomState === 'connected') return _objectSpread(_objectSpread({}, state), {}, {
          state: roomState
        });else return _objectSpread(_objectSpread({}, state), {}, {
          state: roomState,
          activeSpeakerId: null,
          statsPeerId: null
        });
      }
    case 'SET_ROOM_ACTIVE_SPEAKER':
      {
        var peerId = action.payload.peerId;
        return _objectSpread(_objectSpread({}, state), {}, {
          activeSpeakerId: peerId
        });
      }
    case 'SET_ROOM_STATS_PEER_ID':
      {
        var _peerId = action.payload.peerId;
        if (state.statsPeerId === _peerId) return _objectSpread(_objectSpread({}, state), {}, {
          statsPeerId: null
        });
        return _objectSpread(_objectSpread({}, state), {}, {
          statsPeerId: _peerId
        });
      }
    case 'SET_FACE_DETECTION':
      {
        var flag = action.payload;
        return _objectSpread(_objectSpread({}, state), {}, {
          faceDetection: flag
        });
      }
    case 'REMOVE_PEER':
      {
        var _peerId2 = action.payload.peerId;
        var newState = _objectSpread({}, state);
        if (_peerId2 && _peerId2 === state.activeSpeakerId) newState.activeSpeakerId = null;
        if (_peerId2 && _peerId2 === state.statsPeerId) newState.statsPeerId = null;
        return newState;
      }
    default:
      return state;
  }
};
/* harmony default export */ const reducers_room = (room);
;// ./src/lib/redux/reducers/me.js

function me_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function me_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? me_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : me_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var me_initialState = {
  id: null,
  displayName: null,
  displayNameSet: false,
  device: null,
  canSendMic: false,
  canSendWebcam: false,
  canChangeWebcam: false,
  webcamInProgress: false,
  shareInProgress: false,
  audioOnly: false,
  audioOnlyInProgress: false,
  audioMuted: false,
  restartIceInProgress: false
};
var me = function me() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : me_initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case 'SET_ROOM_STATE':
      {
        var roomState = action.payload.state;
        if (roomState === 'closed') {
          return me_objectSpread(me_objectSpread({}, state), {}, {
            webcamInProgress: false,
            shareInProgress: false,
            audioOnly: false,
            audioOnlyInProgress: false,
            audioMuted: false,
            restartIceInProgress: false
          });
        } else {
          return state;
        }
      }
    case 'SET_ME':
      {
        var _action$payload = action.payload,
          peerId = _action$payload.peerId,
          displayName = _action$payload.displayName,
          displayNameSet = _action$payload.displayNameSet,
          device = _action$payload.device;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          id: peerId,
          displayName: displayName,
          displayNameSet: displayNameSet,
          device: device
        });
      }
    case 'SET_MEDIA_CAPABILITIES':
      {
        var _action$payload2 = action.payload,
          canSendMic = _action$payload2.canSendMic,
          canSendWebcam = _action$payload2.canSendWebcam;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          canSendMic: canSendMic,
          canSendWebcam: canSendWebcam
        });
      }
    case 'SET_CAN_CHANGE_WEBCAM':
      {
        var canChangeWebcam = action.payload;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          canChangeWebcam: canChangeWebcam
        });
      }
    case 'SET_WEBCAM_IN_PROGRESS':
      {
        var flag = action.payload.flag;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          webcamInProgress: flag
        });
      }
    case 'SET_SHARE_IN_PROGRESS':
      {
        var _flag = action.payload.flag;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          shareInProgress: _flag
        });
      }
    case 'SET_DISPLAY_NAME':
      {
        var _displayName = action.payload.displayName;

        // Be ready for undefined displayName (so keep previous one).
        if (!_displayName) _displayName = state.displayName;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          displayName: _displayName,
          displayNameSet: true
        });
      }
    case 'SET_AUDIO_ONLY_STATE':
      {
        var enabled = action.payload.enabled;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          audioOnly: enabled
        });
      }
    case 'SET_AUDIO_ONLY_IN_PROGRESS':
      {
        var _flag2 = action.payload.flag;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          audioOnlyInProgress: _flag2
        });
      }
    case 'SET_AUDIO_MUTED_STATE':
      {
        var _enabled = action.payload.enabled;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          audioMuted: _enabled
        });
      }
    case 'SET_RESTART_ICE_IN_PROGRESS':
      {
        var _flag3 = action.payload.flag;
        return me_objectSpread(me_objectSpread({}, state), {}, {
          restartIceInProgress: _flag3
        });
      }
    default:
      return state;
  }
};
/* harmony default export */ const reducers_me = (me);
;// ./src/lib/redux/reducers/producers.js

function producers_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function producers_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? producers_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : producers_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var producers_initialState = {};
var producers = function producers() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : producers_initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case 'SET_ROOM_STATE':
      {
        var roomState = action.payload.state;
        if (roomState === 'closed') return {};else return state;
      }
    case 'ADD_PRODUCER':
      {
        var producer = action.payload.producer;
        return producers_objectSpread(producers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, producer.id, producer));
      }
    case 'REMOVE_PRODUCER':
      {
        var producerId = action.payload.producerId;
        var newState = producers_objectSpread({}, state);
        delete newState[producerId];
        return newState;
      }
    case 'SET_PRODUCER_PAUSED':
      {
        var _producerId = action.payload.producerId;
        var _producer = state[_producerId];
        var newProducer = producers_objectSpread(producers_objectSpread({}, _producer), {}, {
          paused: true
        });
        return producers_objectSpread(producers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _producerId, newProducer));
      }
    case 'SET_PRODUCER_RESUMED':
      {
        var _producerId2 = action.payload.producerId;
        var _producer2 = state[_producerId2];
        var _newProducer = producers_objectSpread(producers_objectSpread({}, _producer2), {}, {
          paused: false
        });
        return producers_objectSpread(producers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _producerId2, _newProducer));
      }
    case 'SET_PRODUCER_TRACK':
      {
        var _action$payload = action.payload,
          _producerId3 = _action$payload.producerId,
          track = _action$payload.track;
        var _producer3 = state[_producerId3];
        var _newProducer2 = producers_objectSpread(producers_objectSpread({}, _producer3), {}, {
          track: track
        });
        return producers_objectSpread(producers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _producerId3, _newProducer2));
      }
    case 'SET_PRODUCER_SCORE':
      {
        var _action$payload2 = action.payload,
          _producerId4 = _action$payload2.producerId,
          score = _action$payload2.score;
        var _producer4 = state[_producerId4];
        if (!_producer4) return state;
        var _newProducer3 = producers_objectSpread(producers_objectSpread({}, _producer4), {}, {
          score: score
        });
        return producers_objectSpread(producers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _producerId4, _newProducer3));
      }
    default:
      {
        return state;
      }
  }
};
/* harmony default export */ const reducers_producers = (producers);
;// ./src/lib/redux/reducers/dataProducers.js

function dataProducers_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function dataProducers_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? dataProducers_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : dataProducers_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var dataProducers_initialState = {};
var dataProducers = function dataProducers() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : dataProducers_initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case 'SET_ROOM_STATE':
      {
        var roomState = action.payload.state;
        if (roomState === 'closed') return {};else return state;
      }
    case 'ADD_DATA_PRODUCER':
      {
        var dataProducer = action.payload.dataProducer;
        return dataProducers_objectSpread(dataProducers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, dataProducer.id, dataProducer));
      }
    case 'REMOVE_DATA_PRODUCER':
      {
        var dataProducerId = action.payload.dataProducerId;
        var newState = dataProducers_objectSpread({}, state);
        delete newState[dataProducerId];
        return newState;
      }
    default:
      {
        return state;
      }
  }
};
/* harmony default export */ const reducers_dataProducers = (dataProducers);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules
var toConsumableArray = __webpack_require__(5458);
;// ./src/lib/redux/reducers/peers.js


function peers_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function peers_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? peers_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : peers_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var peers_initialState = {};
var peers = function peers() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : peers_initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case "SET_ROOM_STATE":
      {
        var roomState = action.payload.state;
        if (roomState === "closed") return {};else return state;
      }
    case "ADD_PEER":
      {
        var peer = action.payload.peer;
        return peers_objectSpread(peers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, peer.id, peer));
      }
    case "REMOVE_PEER":
      {
        var peerId = action.payload.peerId;
        var newState = peers_objectSpread({}, state);
        delete newState[peerId];
        return newState;
      }
    case "SET_PEER_DISPLAY_NAME":
      {
        var _action$payload = action.payload,
          displayName = _action$payload.displayName,
          _peerId = _action$payload.peerId;
        var _peer = state[_peerId];
        if (!_peer) throw new Error("no Peer found");
        var newPeer = peers_objectSpread(peers_objectSpread({}, _peer), {}, {
          displayName: displayName
        });
        return peers_objectSpread(peers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, newPeer.id, newPeer));
      }
    case "ADD_CONSUMER":
      {
        var _action$payload2 = action.payload,
          consumer = _action$payload2.consumer,
          _peerId2 = _action$payload2.peerId;
        var _peer2 = state[_peerId2];
        if (!_peer2) return peers_objectSpread({}, state);
        var newConsumers = [].concat((0,toConsumableArray/* default */.A)(_peer2.consumers), [consumer.id]);
        var _newPeer = peers_objectSpread(peers_objectSpread({}, _peer2), {}, {
          consumers: newConsumers
        });
        return peers_objectSpread(peers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _newPeer.id, _newPeer));
      }
    case "REMOVE_CONSUMER":
      {
        var _action$payload3 = action.payload,
          consumerId = _action$payload3.consumerId,
          _peerId3 = _action$payload3.peerId;
        var _peer3 = state[_peerId3];

        // NOTE: This means that the Peer was closed before, so it's ok.
        if (!_peer3) return state;
        var idx = _peer3.consumers.indexOf(consumerId);
        if (idx === -1) return peers_objectSpread({}, state);
        var _newConsumers = _peer3.consumers.slice();
        _newConsumers.splice(idx, 1);
        var _newPeer2 = peers_objectSpread(peers_objectSpread({}, _peer3), {}, {
          consumers: _newConsumers
        });
        return peers_objectSpread(peers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _newPeer2.id, _newPeer2));
      }
    case "ADD_DATA_CONSUMER":
      {
        var _action$payload4 = action.payload,
          dataConsumer = _action$payload4.dataConsumer,
          _peerId4 = _action$payload4.peerId;

        // special case for bot DataConsumer.
        if (!_peerId4) return state;
        var _peer4 = state[_peerId4];
        if (!_peer4) return peers_objectSpread({}, state);
        var newDataConsumers = [].concat((0,toConsumableArray/* default */.A)(_peer4.dataConsumers), [dataConsumer.id]);
        var _newPeer3 = peers_objectSpread(peers_objectSpread({}, _peer4), {}, {
          dataConsumers: newDataConsumers
        });
        return peers_objectSpread(peers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _newPeer3.id, _newPeer3));
      }
    case "REMOVE_DATA_CONSUMER":
      {
        var _action$payload5 = action.payload,
          dataConsumerId = _action$payload5.dataConsumerId,
          _peerId5 = _action$payload5.peerId;

        // special case for bot DataConsumer.
        if (!_peerId5) return state;
        var _peer5 = state[_peerId5];

        // NOTE: This means that the Peer was closed before, so it's ok.
        if (!_peer5) return state;
        var _idx = _peer5.dataConsumers.indexOf(dataConsumerId);
        if (_idx === -1) {
          return peers_objectSpread({}, state);
        }
        var _newDataConsumers = _peer5.dataConsumers.slice();
        _newDataConsumers.splice(_idx, 1);
        var _newPeer4 = peers_objectSpread(peers_objectSpread({}, _peer5), {}, {
          dataConsumers: _newDataConsumers
        });
        return peers_objectSpread(peers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _newPeer4.id, _newPeer4));
      }
    default:
      {
        return state;
      }
  }
};
/* harmony default export */ const reducers_peers = (peers);
;// ./src/lib/redux/reducers/consumers.js

function consumers_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function consumers_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? consumers_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : consumers_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var consumers_initialState = {};
var consumers = function consumers() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : consumers_initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case "SET_ROOM_STATE":
      {
        var roomState = action.payload.state;
        if (roomState === "closed") return {};else return state;
      }
    case "ADD_CONSUMER":
      {
        var consumer = action.payload.consumer;
        return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, consumer.id, consumer));
      }
    case "REMOVE_CONSUMER":
      {
        var consumerId = action.payload.consumerId;
        var newState = consumers_objectSpread({}, state);
        delete newState[consumerId];
        return newState;
      }
    case "SET_CONSUMER_PAUSED":
      {
        var _action$payload = action.payload,
          _consumerId = _action$payload.consumerId,
          originator = _action$payload.originator;
        var _consumer = state[_consumerId];
        var newConsumer;
        if (originator === "local") newConsumer = consumers_objectSpread(consumers_objectSpread({}, _consumer), {}, {
          locallyPaused: true,
          paused: true
        });else newConsumer = consumers_objectSpread(consumers_objectSpread({}, _consumer), {}, {
          remotelyPaused: true,
          paused: true
        });
        return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _consumerId, newConsumer));
      }
    case "SET_CONSUMER_RESUMED":
      {
        var _action$payload2 = action.payload,
          _consumerId2 = _action$payload2.consumerId,
          _originator = _action$payload2.originator;
        var _consumer2 = state[_consumerId2];
        var _newConsumer;
        if (_originator === "local") _newConsumer = consumers_objectSpread(consumers_objectSpread({}, _consumer2), {}, {
          locallyPaused: false,
          paused: false
        });else _newConsumer = consumers_objectSpread(consumers_objectSpread({}, _consumer2), {}, {
          remotelyPaused: false,
          paused: false
        });
        return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _consumerId2, _newConsumer));
      }
    case "SET_CONSUMER_CURRENT_LAYERS":
      {
        var _action$payload3 = action.payload,
          _consumerId3 = _action$payload3.consumerId,
          spatialLayer = _action$payload3.spatialLayer,
          temporalLayer = _action$payload3.temporalLayer;
        var _consumer3 = state[_consumerId3];
        var _newConsumer2 = consumers_objectSpread(consumers_objectSpread({}, _consumer3), {}, {
          currentSpatialLayer: spatialLayer,
          currentTemporalLayer: temporalLayer
        });
        return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _consumerId3, _newConsumer2));
      }
    case "SET_CONSUMER_PREFERRED_LAYERS":
      {
        var _action$payload4 = action.payload,
          _consumerId4 = _action$payload4.consumerId,
          _spatialLayer = _action$payload4.spatialLayer,
          _temporalLayer = _action$payload4.temporalLayer;
        var _consumer4 = state[_consumerId4];
        var _newConsumer3 = consumers_objectSpread(consumers_objectSpread({}, _consumer4), {}, {
          preferredSpatialLayer: _spatialLayer,
          preferredTemporalLayer: _temporalLayer
        });
        return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _consumerId4, _newConsumer3));
      }
    case "SET_CONSUMER_PRIORITY":
      {
        var _action$payload5 = action.payload,
          _consumerId5 = _action$payload5.consumerId,
          priority = _action$payload5.priority;
        var _consumer5 = state[_consumerId5];
        var _newConsumer4 = consumers_objectSpread(consumers_objectSpread({}, _consumer5), {}, {
          priority: priority
        });
        return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _consumerId5, _newConsumer4));
      }
    case "SET_CONSUMER_TRACK":
      {
        var _action$payload6 = action.payload,
          _consumerId6 = _action$payload6.consumerId,
          track = _action$payload6.track;
        var _consumer6 = state[_consumerId6];
        var _newConsumer5 = consumers_objectSpread(consumers_objectSpread({}, _consumer6), {}, {
          track: track
        });
        return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _consumerId6, _newConsumer5));
      }
    case "SET_CONSUMER_SCORE":
      {
        var _action$payload7 = action.payload,
          _consumerId7 = _action$payload7.consumerId,
          score = _action$payload7.score;
        var _consumer7 = state[_consumerId7];
        if (!_consumer7) return state;
        var _newConsumer6 = consumers_objectSpread(consumers_objectSpread({}, _consumer7), {}, {
          score: score
        });
        return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, _consumerId7, _newConsumer6));
      }
    default:
      {
        return state;
      }
  }
};
/* harmony default export */ const reducers_consumers = (consumers);
;// ./src/lib/redux/reducers/dataConsumers.js

function dataConsumers_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function dataConsumers_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? dataConsumers_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : dataConsumers_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var dataConsumers_initialState = {};
var dataConsumers = function dataConsumers() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : dataConsumers_initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case 'SET_ROOM_STATE':
      {
        var roomState = action.payload.state;
        if (roomState === 'closed') return {};else return state;
      }
    case 'ADD_DATA_CONSUMER':
      {
        var dataConsumer = action.payload.dataConsumer;
        return dataConsumers_objectSpread(dataConsumers_objectSpread({}, state), {}, (0,defineProperty/* default */.A)({}, dataConsumer.id, dataConsumer));
      }
    case 'REMOVE_DATA_CONSUMER':
      {
        var dataConsumerId = action.payload.dataConsumerId;
        var newState = dataConsumers_objectSpread({}, state);
        delete newState[dataConsumerId];
        return newState;
      }
    default:
      {
        return state;
      }
  }
};
/* harmony default export */ const reducers_dataConsumers = (dataConsumers);
;// ./src/lib/redux/reducers/notifications.js

var notifications_initialState = [];
var notifications = function notifications() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : notifications_initialState;
  var action = arguments.length > 1 ? arguments[1] : undefined;
  switch (action.type) {
    case 'ADD_NOTIFICATION':
      {
        var notification = action.payload.notification;
        return [].concat((0,toConsumableArray/* default */.A)(state), [notification]);
      }
    case 'REMOVE_NOTIFICATION':
      {
        var notificationId = action.payload.notificationId;
        return state.filter(function (notification) {
          return notification.id !== notificationId;
        });
      }
    case 'REMOVE_ALL_NOTIFICATIONS':
      {
        return [];
      }
    default:
      return state;
  }
};
/* harmony default export */ const reducers_notifications = (notifications);
;// ./src/lib/redux/reducers/index.js









var reducers = combineReducers({
  room: reducers_room,
  me: reducers_me,
  producers: reducers_producers,
  dataProducers: reducers_dataProducers,
  peers: reducers_peers,
  consumers: reducers_consumers,
  dataConsumers: reducers_dataConsumers,
  notifications: reducers_notifications
});
/* harmony default export */ const redux_reducers = (reducers);
// EXTERNAL MODULE: ./src/lib/RoomClient.js + 46 modules
var RoomClient = __webpack_require__(1919);
;// ./node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js
function _objectDestructuringEmpty(t) {
  if (null == t) throw new TypeError("Cannot destructure " + t);
}

// EXTERNAL MODULE: ./node_modules/events/events.js
var events = __webpack_require__(7007);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 3 modules
var slicedToArray = __webpack_require__(296);
;// ./src/store.js


var _require = __webpack_require__(1919),
  store_RoomClient = _require["default"];
var StoreState = /*#__PURE__*/(0,createClass/* default */.A)(function StoreState() {
  (0,classCallCheck/* default */.A)(this, StoreState);
  /** @type {RoomClient} */
  this.roomClient = null;
});
var Singleton = /*#__PURE__*/function () {
  function Singleton() {
    (0,classCallCheck/* default */.A)(this, Singleton);
    if (!Singleton.instance) Singleton.instance = new StoreState();
  }

  /**
   * @returns {StoreState}
   */
  return (0,createClass/* default */.A)(Singleton, [{
    key: "getInstance",
    value: function getInstance() {
      return Singleton.instance;
    }
  }]);
}();
var singleton = new Singleton();
Object.freeze(singleton);
var Store = singleton.getInstance();
;// ./src/stream.js





var EV_STATE = "state";
var Stream = /*#__PURE__*/function () {
  function Stream(producerOrConsumer) {
    (0,classCallCheck/* default */.A)(this, Stream);
    /**
     * Create a new stream with details from producer Or consumer
     * @param {any} producerOrConsumer
     */
    (0,defineProperty/* default */.A)(this, "pausedBy", void 0);
    /**
     * @type {string}
     */
    this.id = producerOrConsumer.id;

    /**
     * @type {"audio" | "video" | "share" | "shareAudio"}
     */
    this.kind = producerOrConsumer.track.kind;
    this.codec = producerOrConsumer.codec;

    /**
     * @type {MediaStreamTrack}
     */
    this.track = producerOrConsumer.track;
    this.producerOrConsumer = producerOrConsumer.instance;
    if (producerOrConsumer.appData && producerOrConsumer.appData.share === true && producerOrConsumer.track.kind === "video") {
      this.kind = "share";
    }
    if (producerOrConsumer.appData && producerOrConsumer.appData.share === true && producerOrConsumer.track.kind === "audio") {
      this.kind = "shareAudio";
    }
    this.rtpSender = producerOrConsumer.rtpSender;
    this.rtpReceiver = producerOrConsumer.rtpReceiver;
    /*
      codec: "VP8"
      deviceLabel: "Integrated Camera (04f2:b604)"
      id: "6511a8f9-9b14-4dc4-b95a-934caa30aa88"
      paused: false
      rtpParameters: {codecs: Array(2), headerExtensions: Array(7), encodings: Array(1), rtcp: {…}, mid: "1"}
      track: MediaStreamTrack {
        contentHint: ""
        enabled: true
        id: "14288047-6dfd-45fe-923d-2108ff3a0704"
        kind: "video"
        label: "Integrated Camera (04f2:b604)"
        muted: false
        onended: null
        onmute: null
        onunmute: null
        readyState: "live"
      }
      type: "front"
    */
    this.eventEmitter = new events();
  }
  return (0,createClass/* default */.A)(Stream, [{
    key: "pause",
    value: function pause() {
      Store.roomClient._pauseConsumer(this.producerOrConsumer);
    }
  }, {
    key: "resume",
    value: function resume() {
      Store.roomClient._resumeConsumer(this.producerOrConsumer);
    }
  }, {
    key: "handleStateChanged",
    value: function handleStateChanged(_ref) {
      var state = _ref.state,
        streamId = _ref.streamId;
      this.eventEmitter.emit(EV_STATE, {
        state: state,
        timestamp: new Date().getTime()
      });
    }
  }, {
    key: "paused",
    get: function get() {
      return this.producerOrConsumer.paused;
    }

    /**
    * Add event listener
    * @param {EV_STATE} eventType
    * @param {Function} listener Callback function
    */
  }, {
    key: "on",
    value: function on(eventType, listener) {
      switch (eventType) {
        case EV_STATE:
          this.eventEmitter.on(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type from STREAM onn");
          // removed by dead control flow

      }
    }
    /**
    * Add event listener
    * @param {EV_STATE} eventType
    * @param {Function} listener Callback function
    */
  }, {
    key: "off",
    value: function off(eventType, listener) {
      switch (eventType) {
        case EV_STATE:
          this.eventEmitter.off(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type from STREAM off");
          // removed by dead control flow

      }
    }
  }]);
}();

// EXTERNAL MODULE: ./src/lib/sdkCapabilities.js
var sdkCapabilities = __webpack_require__(1803);
;// ./src/participant.js






function participant_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function participant_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? participant_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : participant_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }




var EV_STREAM_ENABLED = "stream-enabled";
var EV_STREAM_DISABLED = "stream-disabled";
var EV_MEDIA_STATUS_CHANGED = "media-status-changed";
var EV_VIDEO_QUALITY_CHANGED = "video-quality-changed";
var EV_STREAM_PAUSED = "stream-paused";
var EV_STREAM_RESUMED = "stream-resumed";
var EV_PRODUCER_ADDED = "producer-added";
var EV_PRODUCER_REMOVED = "producer-removed";
var EV_CONSUMER_ADDED = "consumer-added";
var EV_CONSUMER_REMOVED = "consumer-removed";
var EV_E2EE_STATE_CHANGE = "e2ee-state-change";
var Participant = /*#__PURE__*/function () {
  /**
   * Create a new participant with details from peer
   * @param {any} peer
   */
  function Participant(peer) {
    var _this = this;
    (0,classCallCheck/* default */.A)(this, Participant);
    /**
     *
     * @param {{height?: number, width?: number}} options
     * @returns {Promise<string?>}
     */
    (0,defineProperty/* default */.A)(this, "captureImage", /*#__PURE__*/(0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2() {
      var _ref2,
        desrHeight,
        desrWidth,
        streams,
        _iterator,
        _step,
        _loop,
        _ret,
        _args3 = arguments,
        _t3,
        _t4;
      return regenerator_default().wrap(function (_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _ref2 = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {}, desrHeight = _ref2.height, desrWidth = _ref2.width;
            _context3.prev = 1;
            streams = (0,toConsumableArray/* default */.A)(_this.streams.values());
            _iterator = _createForOfIteratorHelper(streams);
            _context3.prev = 2;
            _loop = /*#__PURE__*/regenerator_default().mark(function _loop() {
              var stream, track, video, canvas, myPromise, _t2;
              return regenerator_default().wrap(function (_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    stream = _step.value;
                    if (!(stream.kind == "video")) {
                      _context2.next = 4;
                      break;
                    }
                    _context2.prev = 1;
                    track = new MediaStream();
                    track.addTrack(stream.track);
                    video = document.createElement("video");
                    video.srcObject = track;
                    video.playsInline = true;
                    canvas = document.createElement("canvas");
                    canvas.id = "canvasId";
                    _context2.next = 2;
                    return new Promise(function (resolve, reject) {
                      video.addEventListener("loadeddata", /*#__PURE__*/(0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee() {
                        var videoWidth, videoHeight, ratio, x, y, url, _t;
                        return regenerator_default().wrap(function (_context) {
                          while (1) switch (_context.prev = _context.next) {
                            case 0:
                              videoWidth = video.videoWidth, videoHeight = video.videoHeight;
                              ratio = 16 / 9;
                              if ((desrHeight === undefined || desrHeight === null) && (desrWidth === undefined || desrWidth === null)) {
                                desrHeight = videoHeight;
                                desrWidth = videoWidth;
                              }
                              if (desrHeight != undefined || desrHeight != null) {
                                if (desrHeight <= 0 || desrHeight > videoHeight) {
                                  desrHeight = videoHeight;
                                }
                              }
                              if (desrWidth != undefined || desrWidth != null) {
                                if (desrWidth <= 0 || desrWidth > videoWidth) {
                                  desrWidth = videoWidth;
                                }
                              }
                              if (desrHeight === undefined || desrHeight === null) {
                                desrHeight = desrWidth / ratio;
                              }
                              if (desrWidth === undefined || desrWidth === null) {
                                desrWidth = desrHeight * ratio;
                              }
                              canvas.width = desrWidth;
                              canvas.height = desrHeight;
                              _context.prev = 1;
                              _context.next = 2;
                              return video.play();
                            case 2:
                              document.body.appendChild(video);
                              x = (canvas.width - videoWidth * ratio) / 2;
                              y = (canvas.height - videoHeight * ratio) / 2;
                              canvas.getContext("2d").clearRect(0, 0, x / 2, y / 2);
                              canvas.getContext("2d").drawImage(video, 0, 0);
                              url = canvas.toDataURL("image/jpeg").split(";base64,")[1];
                              document.body.appendChild(canvas);
                              document.body.removeChild(canvas);
                              document.body.removeChild(video);
                              resolve(url);
                              _context.next = 4;
                              break;
                            case 3:
                              _context.prev = 3;
                              _t = _context["catch"](1);
                              reject(_t);
                              console.log("error in video", _t);
                            case 4:
                            case "end":
                              return _context.stop();
                          }
                        }, _callee, null, [[1, 3]]);
                      })));
                    });
                  case 2:
                    myPromise = _context2.sent;
                    return _context2.abrupt("return", {
                      v: myPromise
                    });
                  case 3:
                    _context2.prev = 3;
                    _t2 = _context2["catch"](1);
                    console.error("err on image capture", _t2);
                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }, _loop, null, [[1, 3]]);
            });
            _iterator.s();
          case 3:
            if ((_step = _iterator.n()).done) {
              _context3.next = 6;
              break;
            }
            return _context3.delegateYield(_loop(), "t0", 4);
          case 4:
            _ret = _context3.t0;
            if (!_ret) {
              _context3.next = 5;
              break;
            }
            return _context3.abrupt("return", _ret.v);
          case 5:
            _context3.next = 3;
            break;
          case 6:
            _context3.next = 8;
            break;
          case 7:
            _context3.prev = 7;
            _t3 = _context3["catch"](2);
            _iterator.e(_t3);
          case 8:
            _context3.prev = 8;
            _iterator.f();
            return _context3.finish(8);
          case 9:
            throw new Error("Camera must be on to capture an image");
          case 10:
            _context3.prev = 10;
            _t4 = _context3["catch"](1);
            console.error("Error in captureImage::", _t4);
            if (Store.roomClient._videosdkLogs) {
              Store.roomClient._videosdkLogs.pushLogs({
                logText: "Error on image capture",
                logType: "ERROR",
                attributes: {
                  error: _t4.message
                }
              });
            }
          case 11:
          case "end":
            return _context3.stop();
        }
      }, _callee2, null, [[1, 10], [2, 7, 8, 9]]);
    })));
    /**
     * @type {string}
     */
    this.id = peer.id;
    /**
     * @type {string}
     */
    this.displayName = peer.displayName;
    /**
     * @type {Map<string, Stream>}
     */
    this.streams = new Map();
    /**
     * @type {"low" | "med" | "high"}
     */
    this.quality = "low";
    /**
     * @type {"low" | "med" | "high"}
     */
    this.screenShareQuality = "high";
    /**
     * @type {boolean}
     */
    this.local = peer.local || false;
    /**
     * @type {{cam:boolean, share: boolean}}
     */
    this.pinState = {
      cam: false,
      share: false
    };
    /**
     * @type {boolean}
     */
    this.webcamOn = false;
    /**
     * @type {boolean}
     */
    this.micOn = false;

    /**
     * @type {"SEND_AND_RECV" | "SIGNALLING_ONLY" | "RECV_ONLY"}
     */
    this.mode = peer.mode;
    /**
     * @type {object}
     */
    this.metaData = peer.metaData;
    this.eventEmitter = new events.EventEmitter();
    this.participantVideoElements = new Map();
    this.participantAudioElements = new Map();
    this.videoVisible = false;
    this.height = null;
    this.width = null;
    this.resizeObserver = null;
  }

  // set this Pin State
  return (0,createClass/* default */.A)(Participant, [{
    key: "_setPinState",
    value: function _setPinState(obj) {
      if (obj.cam != undefined) {
        this.pinState.cam = obj.cam;
      }
      if (obj.share != undefined) {
        this.pinState.share = obj.share;
      }
    }
  }, {
    key: "remove",
    value: function remove() {
      Store.roomClient.removePeer(this.id);
    }
  }, {
    key: "enableMic",
    value: function enableMic() {
      Store.roomClient.enablePeerMic(this.id);
    }
  }, {
    key: "disableMic",
    value: function disableMic() {
      Store.roomClient.disablePeerMic(this.id);
    }
  }, {
    key: "enableWebcam",
    value: function enableWebcam() {
      Store.roomClient.enablePeerWebcam(this.id);
    }
  }, {
    key: "disableWebcam",
    value: function disableWebcam() {
      Store.roomClient.disablePeerWebcam(this.id);
    }
  }, {
    key: "getTransportStats",
    value: function getTransportStats() {
      return Store.roomClient.getTransportRemoteStats({
        participantId: this.id
      });
    }
  }, {
    key: "handleStreamStateChanged",
    value: function handleStreamStateChanged(_ref4) {
      var state = _ref4.state,
        peerId = _ref4.peerId,
        streamId = _ref4.streamId;
      var stream = this.streams.get(streamId);
      if (stream == null) return;
      if (stream.kind === "video" || stream.kind === "share") {
        stream.handleStateChanged({
          state: state,
          streamId: streamId
        });
      }
    }
  }, {
    key: "addStream",
    value: function addStream(stream) {
      if (!stream) {
        console.warn("Attempted to add null/undefined stream");
        return;
      }
      this.streams.set(stream.id, stream);

      // Set video quality for non-local video streams
      if (stream.kind === "video" && !this.local) {
        Store.roomClient.setConsumerQuality(stream.id, this.quality);
      }
      var mediaStream = new MediaStream();
      mediaStream.addTrack(stream.track);
      try {
        // Handle video and screen share streams
        if (["video", "share"].includes(stream.kind)) {
          var videoElement = this.participantVideoElements.get(stream.kind);
          if (videoElement) {
            var defaultStyles = {
              display: "block",
              objectFit: stream.kind === "share" ? "contain" : "cover",
              width: "100%"
            };
            Object.assign(videoElement.style, defaultStyles);
            videoElement.srcObject = mediaStream;
            videoElement.play()["catch"](function (error) {
              console.error("Failed to play ".concat(stream.kind, " stream:"), error);
            });

            // Only resume video streams if visible or if it's a share stream
            if (stream.kind === "share" || stream.kind === "video" && this.videoVisible) {
              stream.resume();
            }
          }
        }

        // Handle audio streams
        if ((stream.kind === "audio" || stream.kind === "shareAudio") && !this.local) {
          var audioElement = this.participantAudioElements.get(stream.kind);
          if (audioElement) {
            audioElement.srcObject = mediaStream;
            audioElement.play()["catch"](function (error) {
              console.error("Failed to play ".concat(stream.kind, " audio:"), error);
            });
          }
        }

        // Emit stream enabled event
        this.eventEmitter.emit(EV_STREAM_ENABLED, stream);

        // Update viewport for non-local video streams
        if (stream.kind === "video" && !this.local && this.height && this.width) {
          this.setViewPort(this.width, this.height);
        }
      } catch (error) {
        console.error("Error in addStream:", error);
      }
    }
  }, {
    key: "updateStream",
    value: function updateStream(stream) {
      this.streams.set(stream.id, stream);
      this.eventEmitter.emit(EV_STREAM_ENABLED, stream);
    }
  }, {
    key: "deleteStream",
    value: function deleteStream(streamId) {
      var stream = this.streams.get(streamId);
      if (stream == null) return;
      this.streams["delete"](streamId);
      var elementMappings = {
        video: {
          collection: this.participantVideoElements,
          type: "video"
        },
        share: {
          collection: this.participantVideoElements,
          type: "share"
        },
        audio: {
          collection: this.participantAudioElements,
          type: "audio"
        },
        shareAudio: {
          collection: this.participantAudioElements,
          type: "shareAudio"
        }
      };
      var mapping = elementMappings[stream.kind];
      if (mapping) {
        var element = mapping.collection.get(mapping.type);
        if (element) {
          element.style.display = "none";
        }
      }
      this.eventEmitter.emit(EV_STREAM_DISABLED, stream);
      return stream;
    }
  }, {
    key: "streamResumed",
    value: function streamResumed(streamId) {
      var stream = this.streams.get(streamId);
      if (stream == null) return;

      // if (stream.kind === "video" && this.participantVideoElements.get("video")) {
      //   const initialEntry = this.participantVideoElements
      //     .get("video")
      //     ?.parentElement.getBoundingClientRect();
      //   console.log("initialEntry", initialEntry);

      //   const isInitiallyVisible = initialEntry
      //     ? isVideoInView(initialEntry)
      //     : false;

      //   console.log("isInitiallyVisible", isInitiallyVisible);

      //   // if (!isInitiallyVisible) {
      //   //   this.videoVisible = false;
      //   //   stream.pause();
      //   // }
      // }
    }
  }, {
    key: "streamPaused",
    value: function streamPaused(streamId) {
      var stream = this.streams.get(streamId);
      if (stream == null) return;
    }
  }, {
    key: "updateParticipantMediaState",
    value: function updateParticipantMediaState(kind, state) {
      if (kind == "audio") {
        this.micOn = state;
      } else if (kind == "video") {
        this.webcamOn = state;
      }
      this.eventEmitter.emit(EV_MEDIA_STATUS_CHANGED, {
        peerId: this.id,
        kind: kind,
        newStatus: state
      });
    }
  }, {
    key: "handleParticipantPause",
    value: function handleParticipantPause(data) {
      if (data !== null && data !== void 0 && data.consumerId) {
        var stream = this.streams.get(data.consumerId);
        if (stream) {
          stream.pausedBy = "SUB_MANAGER";
        } else {
          console.warn("Stream with consumerId ".concat(data.consumerId, " not found."));
        }
      }
      this.eventEmitter.emit(EV_STREAM_PAUSED, {
        kind: data === null || data === void 0 ? void 0 : data.kind,
        reason: data === null || data === void 0 ? void 0 : data.reason
      });
    }
  }, {
    key: "handleParticipantResume",
    value: function handleParticipantResume(data) {
      if (data !== null && data !== void 0 && data.consumerId) {
        var stream = this.streams.get(data.consumerId);
        if (stream) {
          stream.pausedBy = undefined;
        } else {
          console.warn("Stream with consumerId ".concat(data.consumerId, " not found."));
        }
      }
      this.eventEmitter.emit(EV_STREAM_RESUMED, {
        kind: data === null || data === void 0 ? void 0 : data.kind,
        reason: data === null || data === void 0 ? void 0 : data.reason
      });
    }
  }, {
    key: "handleE2EEStateChange",
    value: function handleE2EEStateChange(data) {
      data === null || data === void 0 || delete data.peerId;
      this.eventEmitter.emit(EV_E2EE_STATE_CHANGE, data);
    }
  }, {
    key: "videoQualityChanged",
    value: function videoQualityChanged(prevQuality, currentQuality) {
      this.eventEmitter.emit(EV_VIDEO_QUALITY_CHANGED, {
        peerId: this.id,
        prevQuality: prevQuality,
        currentQuality: currentQuality
      });
    }

    /**
     *
     * @param {"low" | "med" | 'high'} quality
     */
  }, {
    key: "setQuality",
    value: function setQuality(quality) {
      if (this.local) return;
      // only run this in browsers (where `document` exists)
      if (typeof document !== "undefined" && this.resizeObserver) {
        var videoContainer = document.querySelector("#f-".concat(this.id));
        if (videoContainer) {
          this.resizeObserver.unobserve(videoContainer);
        }
      }
      this.quality = quality;
      var entries = (0,toConsumableArray/* default */.A)(this.streams.entries());
      entries.forEach(function (entry) {
        var stream = entry[1];
        if (stream.kind === "video") {
          Store.roomClient.setConsumerQuality(stream.id, quality);
        }
      });
    }

    /**
     *
     * @param {"low" | "med" | 'high'} quality
     */
  }, {
    key: "setScreenShareQuality",
    value: function setScreenShareQuality(quality) {
      if (this.local) return;
      this.screenShareQuality = quality;
      this.streams.forEach(function (stream) {
        if (stream.kind === "share") {
          Store.roomClient.setConsumerScreenShareQuality(stream.id, quality);
        }
      });
    }

    /**
     *
     * @param {number} width
     * @param {number} height
     */
  }, {
    key: "setViewPort",
    value: function setViewPort(width, height) {
      var entries = (0,toConsumableArray/* default */.A)(this.streams.entries());
      entries.forEach(function (entry) {
        var stream = entry[1];
        if (stream.kind === "video") {
          Store.roomClient.setViewPort(stream.producerOrConsumer, width, height);
        }
      });
    }

    /**
     * @param {"SHARE_AND_CAM" | "CAM" | "SHARE"} type
     */
  }, {
    key: "pin",
    value: function pin(type) {
      switch (type) {
        case "SHARE_AND_CAM":
        case undefined:
          this._setPinState({
            cam: true,
            share: true
          });
          break;
        case "CAM":
          this._setPinState({
            cam: true
          });
          break;
        case "SHARE":
          this._setPinState({
            share: true
          });
          break;
        default:
          throw new Error("Unknown pin type");
      }

      // call roomclient with updated pin state
      Store.roomClient.pinStateChange({
        peerId: this.id,
        state: this.pinState
      });
    }

    /**
     * @param {"SHARE_AND_CAM" | "CAM" | "SHARE"} type
     */
  }, {
    key: "unpin",
    value: function unpin(type) {
      switch (type) {
        case "SHARE_AND_CAM":
        case undefined:
          //if undefined then unset;
          this._setPinState({
            cam: false,
            share: false
          });
          break;
        case "CAM":
          this._setPinState({
            cam: false
          });
          break;
        case "SHARE":
          this._setPinState({
            share: false
          });
          break;
        default:
          throw new Error("Unknown unpin type");
      }

      //call roomClient with update pinState and peerId;
      Store.roomClient.pinStateChange({
        peerId: this.id,
        state: this.pinState
      });
    }

    /**
     *@param {{meetingId: string, payload: string, token:string }} options
     */
  }, {
    key: "switchTo",
    value: (function () {
      var _switchTo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee3(_ref5) {
        var meetingId, payload, token;
        return regenerator_default().wrap(function (_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              meetingId = _ref5.meetingId, payload = _ref5.payload, token = _ref5.token;
              _context4.next = 1;
              return Store.roomClient.switchPeerRoom({
                peerId: this.id,
                roomId: meetingId,
                payload: payload,
                token: token
              });
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee3, this);
      }));
      function switchTo(_x) {
        return _switchTo.apply(this, arguments);
      }
      return switchTo;
    }())
  }, {
    key: "getVideoStats",
    value: function () {
      var _getVideoStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee4() {
        var entries, _iterator2, _step2, _step2$value, streamId, stream, _t5;
        return regenerator_default().wrap(function (_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!this.local) {
                _context5.next = 2;
                break;
              }
              _context5.next = 1;
              return Store.roomClient.getVideoRemoteStats();
            case 1:
              return _context5.abrupt("return", _context5.sent);
            case 2:
              entries = (0,toConsumableArray/* default */.A)(this.streams.entries());
              _iterator2 = _createForOfIteratorHelper(entries);
              _context5.prev = 3;
              _iterator2.s();
            case 4:
              if ((_step2 = _iterator2.n()).done) {
                _context5.next = 7;
                break;
              }
              _step2$value = (0,slicedToArray/* default */.A)(_step2.value, 2), streamId = _step2$value[0], stream = _step2$value[1];
              if (!(stream.kind == "video")) {
                _context5.next = 6;
                break;
              }
              _context5.next = 5;
              return Store.roomClient.getConsumerRemoteStats(streamId);
            case 5:
              return _context5.abrupt("return", _context5.sent);
            case 6:
              _context5.next = 4;
              break;
            case 7:
              _context5.next = 9;
              break;
            case 8:
              _context5.prev = 8;
              _t5 = _context5["catch"](3);
              _iterator2.e(_t5);
            case 9:
              _context5.prev = 9;
              _iterator2.f();
              return _context5.finish(9);
            case 10:
            case "end":
              return _context5.stop();
          }
        }, _callee4, this, [[3, 8, 9, 10]]);
      }));
      function getVideoStats() {
        return _getVideoStats.apply(this, arguments);
      }
      return getVideoStats;
    }()
  }, {
    key: "getShareStats",
    value: function () {
      var _getShareStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee5() {
        var entries, _iterator3, _step3, _step3$value, streamId, stream, _t6;
        return regenerator_default().wrap(function (_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (!this.local) {
                _context6.next = 2;
                break;
              }
              _context6.next = 1;
              return Store.roomClient.getShareRemoteStats();
            case 1:
              return _context6.abrupt("return", _context6.sent);
            case 2:
              entries = (0,toConsumableArray/* default */.A)(this.streams.entries());
              _iterator3 = _createForOfIteratorHelper(entries);
              _context6.prev = 3;
              _iterator3.s();
            case 4:
              if ((_step3 = _iterator3.n()).done) {
                _context6.next = 7;
                break;
              }
              _step3$value = (0,slicedToArray/* default */.A)(_step3.value, 2), streamId = _step3$value[0], stream = _step3$value[1];
              if (!(stream.kind == "share")) {
                _context6.next = 6;
                break;
              }
              _context6.next = 5;
              return Store.roomClient.getConsumerRemoteStats(streamId);
            case 5:
              return _context6.abrupt("return", _context6.sent);
            case 6:
              _context6.next = 4;
              break;
            case 7:
              _context6.next = 9;
              break;
            case 8:
              _context6.prev = 8;
              _t6 = _context6["catch"](3);
              _iterator3.e(_t6);
            case 9:
              _context6.prev = 9;
              _iterator3.f();
              return _context6.finish(9);
            case 10:
            case "end":
              return _context6.stop();
          }
        }, _callee5, this, [[3, 8, 9, 10]]);
      }));
      function getShareStats() {
        return _getShareStats.apply(this, arguments);
      }
      return getShareStats;
    }()
  }, {
    key: "getShareAudioStats",
    value: function () {
      var _getShareAudioStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee6() {
        var entries, _iterator4, _step4, _step4$value, streamId, stream, _t7;
        return regenerator_default().wrap(function (_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!this.local) {
                _context7.next = 2;
                break;
              }
              _context7.next = 1;
              return Store.roomClient.getShareAudioRemoteStats();
            case 1:
              return _context7.abrupt("return", _context7.sent);
            case 2:
              entries = (0,toConsumableArray/* default */.A)(this.streams.entries());
              _iterator4 = _createForOfIteratorHelper(entries);
              _context7.prev = 3;
              _iterator4.s();
            case 4:
              if ((_step4 = _iterator4.n()).done) {
                _context7.next = 7;
                break;
              }
              _step4$value = (0,slicedToArray/* default */.A)(_step4.value, 2), streamId = _step4$value[0], stream = _step4$value[1];
              if (!(stream.kind == "shareAudio")) {
                _context7.next = 6;
                break;
              }
              _context7.next = 5;
              return Store.roomClient.getConsumerRemoteStats(streamId);
            case 5:
              return _context7.abrupt("return", _context7.sent);
            case 6:
              _context7.next = 4;
              break;
            case 7:
              _context7.next = 9;
              break;
            case 8:
              _context7.prev = 8;
              _t7 = _context7["catch"](3);
              _iterator4.e(_t7);
            case 9:
              _context7.prev = 9;
              _iterator4.f();
              return _context7.finish(9);
            case 10:
            case "end":
              return _context7.stop();
          }
        }, _callee6, this, [[3, 8, 9, 10]]);
      }));
      function getShareAudioStats() {
        return _getShareAudioStats.apply(this, arguments);
      }
      return getShareAudioStats;
    }()
  }, {
    key: "getAudioStats",
    value: function () {
      var _getAudioStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee7() {
        var entries, _iterator5, _step5, _step5$value, streamId, stream, _t8;
        return regenerator_default().wrap(function (_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              if (this.micOn) {
                _context8.next = 1;
                break;
              }
              return _context8.abrupt("return", []);
            case 1:
              if (!this.local) {
                _context8.next = 3;
                break;
              }
              _context8.next = 2;
              return Store.roomClient.getAudioRemoteStats();
            case 2:
              return _context8.abrupt("return", _context8.sent);
            case 3:
              entries = (0,toConsumableArray/* default */.A)(this.streams.entries());
              _iterator5 = _createForOfIteratorHelper(entries);
              _context8.prev = 4;
              _iterator5.s();
            case 5:
              if ((_step5 = _iterator5.n()).done) {
                _context8.next = 8;
                break;
              }
              _step5$value = (0,slicedToArray/* default */.A)(_step5.value, 2), streamId = _step5$value[0], stream = _step5$value[1];
              if (!(stream.kind == "audio")) {
                _context8.next = 7;
                break;
              }
              _context8.next = 6;
              return Store.roomClient.getConsumerRemoteStats(streamId);
            case 6:
              return _context8.abrupt("return", _context8.sent);
            case 7:
              _context8.next = 5;
              break;
            case 8:
              _context8.next = 10;
              break;
            case 9:
              _context8.prev = 9;
              _t8 = _context8["catch"](4);
              _iterator5.e(_t8);
            case 10:
              _context8.prev = 10;
              _iterator5.f();
              return _context8.finish(10);
            case 11:
            case "end":
              return _context8.stop();
          }
        }, _callee7, this, [[4, 9, 10, 11]]);
      }));
      function getAudioStats() {
        return _getAudioStats.apply(this, arguments);
      }
      return getAudioStats;
    }()
  }, {
    key: "consumeMicStreams",
    value: function consumeMicStreams() {
      Store.roomClient.consumeMicStreams(this.id);
    }
  }, {
    key: "consumeWebcamStreams",
    value: function consumeWebcamStreams() {
      Store.roomClient.consumeWebcamStreams(this.id);
    }
  }, {
    key: "stopConsumingWebcamStreams",
    value: function stopConsumingWebcamStreams() {
      Store.roomClient.stopConsumingWebcamStreams(this.id);
    }
  }, {
    key: "stopConsumingMicStreams",
    value: function stopConsumingMicStreams() {
      Store.roomClient.stopConsumingMicStreams(this.id);
    }
  }, {
    key: "renderVideo",
    value: function renderVideo(_ref6) {
      var _this2 = this;
      var _ref6$type = _ref6.type,
        type = _ref6$type === void 0 ? "video" : _ref6$type,
        _ref6$maxQuality = _ref6.maxQuality,
        maxQuality = _ref6$maxQuality === void 0 ? "auto" : _ref6$maxQuality,
        _ref6$videostyle = _ref6.videostyle,
        videostyle = _ref6$videostyle === void 0 ? {} : _ref6$videostyle,
        _ref6$containerStyle = _ref6.containerStyle,
        containerStyle = _ref6$containerStyle === void 0 ? {} : _ref6$containerStyle;
      var videoStream;
      for (var _i = 0, _arr = (0,toConsumableArray/* default */.A)(this.streams.values()); _i < _arr.length; _i++) {
        var stream = _arr[_i];
        if (stream.kind == type) {
          videoStream = new MediaStream();
          videoStream.addTrack(stream.track);
        }
      }
      if (this.participantVideoElements.get(type)) {
        if (videoStream) {
          var videoElement = this.participantVideoElements.get(type);
          if (videoElement) {
            videoElement.srcObject = videoStream;
            videoElement.play()["catch"](function (error) {
              return console.error("videoElem.play() failed", error);
            });
          }
        }
        return this.participantVideoElements.get(type);
      }
      try {
        // Create container div for both video types
        var containerDiv = document.createElement("div");
        containerDiv.classList.add("video-container", "participant-video-".concat(this.id));
        containerDiv.setAttribute("id", "f-".concat(this.id).concat(type === "share" ? "-share" : ""));
        containerDiv.style.setProperty("position", "relative");
        Object.assign(containerDiv.style, containerStyle);
        var _videoElement = document.createElement("video");
        _videoElement.setAttribute("id", "v-".concat(this.id).concat(type === "share" ? "-share" : ""));
        _videoElement.setAttribute("playsinline", "");
        _videoElement.setAttribute("webkit-playsinline", "");
        _videoElement.setAttribute("x5-playsinline", "");
        _videoElement.playsinline = true;
        _videoElement.muted = true;
        _videoElement.autoplay = true;
        _videoElement.onerror = function (err) {
          console.log(err, "participant video error");
        };

        // Set different default objectFit based on type
        Object.assign(_videoElement.style, participant_objectSpread({
          width: "100%",
          height: "100%",
          objectFit: type === "share" ? "contain" : "cover"
        }, videostyle));
        if (videoStream) {
          _videoElement.srcObject = videoStream;
          _videoElement.play().then(function (val) {
            console.log("videoElem.play() success", val);
          })["catch"](function (error) {
            return console.error("videoElem.play() failed", error);
          });
        }
        containerDiv.appendChild(_videoElement);
        this.participantVideoElements.set(type, _videoElement);
        this.videoVisible = false;

        // Only add observers for non-local, regular video
        if (!this.local && type === "video") {
          // Throttled IntersectionObserver callback
          var throttledIntersectionCallback = (0,sdkCapabilities/* debounce */.sg)(function (entries) {
            if (entries.length == 0) {
              return;
            }
            var entry = entries[entries.length - 1];
            if (entry.intersectionRatio > 0) {
              _this2.videoVisible = true;
              for (var _i2 = 0, _arr2 = (0,toConsumableArray/* default */.A)(_this2.streams.values()); _i2 < _arr2.length; _i2++) {
                var _stream = _arr2[_i2];
                if (_stream.kind == "video" && _stream.pausedBy !== "SUB_MANAGER" && _stream.paused) {
                  _stream.resume();
                }
              }
            } else {
              _this2.videoVisible = false;
              for (var _i3 = 0, _arr3 = (0,toConsumableArray/* default */.A)(_this2.streams.values()); _i3 < _arr3.length; _i3++) {
                var _stream2 = _arr3[_i3];
                if (_stream2.kind == "video") {
                  _stream2.pause();
                }
              }
            }
          }, 500); // Throttle to 500ms
          var observerOptions = {
            root: null,
            rootMargin: "0px",
            threshold: 0
          };
          var observer = new IntersectionObserver(throttledIntersectionCallback, observerOptions);
          observer.observe(containerDiv);
          if (maxQuality == "auto" && type === "video") {
            // Throttled ResizeObserver callback
            var throttledResizeCallback = (0,sdkCapabilities/* debounce */.sg)(function (entries) {
              var _entries$0$contentRec = entries[0].contentRect,
                width = _entries$0$contentRec.width,
                height = _entries$0$contentRec.height;
              if (width > 0 && height > 0) {
                _this2.height = height;
                _this2.width = width;
                _this2.setViewPort(width, height);
              }
            }, 500); // Throttle to 500ms

            var resizeObserver = new ResizeObserver(throttledResizeCallback);
            resizeObserver.observe(containerDiv);
            this.resizeObserver = resizeObserver;
          }
        }
        if (type === "video" && maxQuality !== "auto" && !this.local) {
          this.setQuality(maxQuality);
        }
        return containerDiv;
      } catch (exce) {
        console.log("Render video Exception", exce);
      }
    }
  }, {
    key: "renderAudio",
    value: function renderAudio(_ref7) {
      var _ref7$type = _ref7.type,
        type = _ref7$type === void 0 ? "audio" : _ref7$type;
      // Early return for local participant
      if (this.local) return null;
      try {
        // Check if audio element already exists
        if (this.participantAudioElements.get(type)) {
          var existingAudio = this.participantAudioElements.get(type);

          // Update stream if available
          var _audioStream = this.getAudioStream(type);
          if (_audioStream) {
            if (existingAudio) {
              existingAudio.srcObject = _audioStream;
              existingAudio.play()["catch"](function (error) {
                return console.error("Failed to play existing audio:", error);
              });
            }
          }
          return existingAudio;
        }

        // Create new audio element
        var audioElement = document.createElement("audio");
        audioElement.setAttribute("id", "a-".concat(this.id, "-").concat(type));
        audioElement.autoplay = false;
        audioElement.playsInline = true;
        audioElement.controls = false;
        audioElement.style.display = "none";

        // Set up error handling
        audioElement.onerror = function (err) {
          return console.log("Audio element error:", err);
        };

        // Set up audio stream if available
        var audioStream = this.getAudioStream(type);
        if (audioStream) {
          audioElement.srcObject = audioStream;
          audioElement.play()["catch"](function (error) {
            return console.error("Failed to play new audio:", error);
          });
        }

        // Store reference to audio element
        this.participantAudioElements.set(type, audioElement);
        return audioElement;
      } catch (error) {
        console.error("Render audio exception:", error);
        return null;
      }
    }

    /* @internal */
    // Helper method to get audio stream
  }, {
    key: "getAudioStream",
    value: function getAudioStream() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "audio";
      var stream = (0,toConsumableArray/* default */.A)(this.streams.values()).find(function (stream) {
        return stream.kind === type;
      });
      if (stream) {
        var audioStream = new MediaStream();
        audioStream.addTrack(stream.track);
        stream.resume();
        return audioStream;
      }
      return null;
    }
  }, {
    key: "addProducer",
    value: function addProducer(producer) {
      this.eventEmitter.emit(EV_PRODUCER_ADDED, producer);
    }
  }, {
    key: "removeProducer",
    value: function removeProducer(producerId) {
      this.eventEmitter.emit(EV_PRODUCER_REMOVED, producerId);
    }
  }, {
    key: "addConsumer",
    value: function addConsumer(consumer) {
      this.eventEmitter.emit(EV_CONSUMER_ADDED, consumer);
    }
  }, {
    key: "removeConsumer",
    value: function removeConsumer(consumerId) {
      this.eventEmitter.emit(EV_CONSUMER_REMOVED, consumerId);
    }

    /**
     * Add event listener
     * @param {EV_STREAM_ENABLED | EV_STREAM_DISABLED | EV_MEDIA_STATUS_CHANGED} eventType
     * @param {Function} listener Callback function
     */
  }, {
    key: "on",
    value: function on(eventType, listener) {
      switch (eventType) {
        case EV_STREAM_ENABLED:
        case EV_STREAM_DISABLED:
        case EV_MEDIA_STATUS_CHANGED:
        case EV_VIDEO_QUALITY_CHANGED:
        case EV_STREAM_PAUSED:
        case EV_STREAM_RESUMED:
        case EV_PRODUCER_ADDED:
        case EV_PRODUCER_REMOVED:
        case EV_CONSUMER_ADDED:
        case EV_CONSUMER_REMOVED:
        case EV_E2EE_STATE_CHANGE:
          this.eventEmitter.on(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type from participant onn");
          // removed by dead control flow

      }
    }

    /**
     * Remove event listener
     * @param {EV_STREAM_ENABLED | EV_STREAM_DISABLED | EV_MEDIA_STATUS_CHANGED} eventType
     * @param {Function} listener Callback function
     */
  }, {
    key: "off",
    value: function off(eventType, listener) {
      switch (eventType) {
        case EV_STREAM_ENABLED:
        case EV_STREAM_DISABLED:
        case EV_MEDIA_STATUS_CHANGED:
        case EV_VIDEO_QUALITY_CHANGED:
        case EV_STREAM_PAUSED:
        case EV_STREAM_RESUMED:
        case EV_PRODUCER_ADDED:
        case EV_PRODUCER_REMOVED:
        case EV_CONSUMER_ADDED:
        case EV_CONSUMER_REMOVED:
        case EV_E2EE_STATE_CHANGE:
          this.eventEmitter.off(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type from participant off");
          // removed by dead control flow

      }
    }
  }]);
}();

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js + 1 modules
var possibleConstructorReturn = __webpack_require__(388);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(3954);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__(5501);
;// ./src/constants/character.js
var CharacterState = {
  CHARACTER_SPEAKING: "CHARACTER_SPEAKING",
  CHARACTER_THINKING: "CHARACTER_THINKING",
  CHARACTER_LISTENING: "CHARACTER_LISTENING"
};
var CharacterMode = {
  TEXT: "text",
  CO_PILOT: "co_pilot",
  AUTO_PILOT: "auto_pilot",
  VISION_PILOT: "vision_pilot"
};
// EXTERNAL MODULE: ./src/constants/modes.js
var modes = __webpack_require__(2107);
;// ./src/character.js








function _callSuper(t, o, e) { return o = (0,getPrototypeOf/* default */.A)(o), (0,possibleConstructorReturn/* default */.A)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0,getPrototypeOf/* default */.A)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }




var character_EV_STREAM_ENABLED = "stream-enabled";
var character_EV_STREAM_DISABLED = "stream-disabled";
var EV_CHARACTER_JOINED = "character-joined";
var EV_CHARACTER_LEFT = "character-left";
var character_EV_MEDIA_STATUS_CHANGED = "media-status-changed";
var character_EV_VIDEO_QUALITY_CHANGED = "video-quality-changed";
var EV_CHARACTER_STATE_CHANGED = "character-state-changed";
var EV_CHARACTER_MESSAGE = "character-message";
var EV_USER_MESSAGE = "user-message";
var EV_ON_DATA = "data";
var EV_ON_ERROR = "error";
var _characterRole = /*#__PURE__*/new WeakMap();
var _characterMode = /*#__PURE__*/new WeakMap();
var _knowledgeBases = /*#__PURE__*/new WeakMap();
var _language = /*#__PURE__*/new WeakMap();
var _interactionId = /*#__PURE__*/new WeakMap();
var _state = /*#__PURE__*/new WeakMap();
var _roomClient = /*#__PURE__*/new WeakMap();
var _Character_brand = /*#__PURE__*/new WeakSet();
var Character = /*#__PURE__*/function (_Participant) {
  /**
   * Create a new character participant
   * @param {Object} config - The character object containing properties.
   * @param {string} [config.id] - Indicates participantId of character.
   * @param {string} [config.characterRole] - Role of the character.
   * @param {"text" | "co_pilot" | "auto_pilot" | "vision_pilot"} [config.characterMode] - Mode of the character.
   * @param {string[]} [config.knowledgeBases] - Array of knowledge bases associated with the character. (Optional)
   * @param {string} [config.displayName] - name of the character. (Optional)
   * @param {string} [config.interactionId] - The character's interaction ID.
   * @param {"CHARACTER_SPEAKING" | "CHARACTER_THINKING" | "CHARACTER_LISTENING"} config.state - The character's interaction ID.
   * @param {RoomClient} config.roomClient - Internal Room Client
   */
  function Character(config) {
    var _this;
    (0,classCallCheck/* default */.A)(this, Character);
    _this = _callSuper(this, Character, [{
      id: config.id,
      displayName: config.displayName,
      mode: modes/* modes */.nI.SEND_AND_RECV,
      metaData: config.metaData
    }]);
    /**
     * @description update state.
     * @returns {void}
     */
    _classPrivateMethodInitSpec(_this, _Character_brand);
    // Role of the Character
    _classPrivateFieldInitSpec(_this, _characterRole, void 0);
    // Mode of the Interaction character.
    _classPrivateFieldInitSpec(_this, _characterMode, void 0);
    // Array of knowledge bases associated with the character.
    _classPrivateFieldInitSpec(_this, _knowledgeBases, void 0);
    // language of character
    _classPrivateFieldInitSpec(_this, _language, void 0);
    // The character will continue interaction based on the interaction ID.
    _classPrivateFieldInitSpec(_this, _interactionId, void 0);
    // Current State of Character.
    _classPrivateFieldInitSpec(_this, _state, void 0);
    // Room Client
    _classPrivateFieldInitSpec(_this, _roomClient, void 0);
    (0,defineProperty/* default */.A)(_this, "captureImage", /*#__PURE__*/(0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee() {
      var _ref2,
        desrHeight,
        desrWidth,
        _args = arguments;
      return regenerator_default().wrap(function (_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, desrHeight = _ref2.height, desrWidth = _ref2.width;
            throw new Error("captureImage method is not supported on character");
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })));
    _classPrivateFieldSet(_interactionId, _this, config.interactionId || null);
    // OR
    _this.id = config.id || null;
    _classPrivateFieldSet(_characterRole, _this, config.characterRole);
    _classPrivateFieldSet(_characterMode, _this, config.characterMode);
    _classPrivateFieldSet(_knowledgeBases, _this, config.knowledgeBases || []);
    _this.displayName = config.displayName;
    _classPrivateFieldSet(_language, _this, config.language);

    // manage
    _classPrivateFieldSet(_state, _this, config.state || CharacterState.CHARACTER_LISTENING);
    _classPrivateFieldSet(_roomClient, _this, config.roomClient);
    return _this;
  }

  /**
   * @description Initiates the character's participation in a meeting.
   * @returns {Promise<void>}
   */
  (0,inherits/* default */.A)(Character, _Participant);
  return (0,createClass/* default */.A)(Character, [{
    key: "join",
    value: (function () {
      var _join = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2() {
        var res;
        return regenerator_default().wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 1;
              return _classPrivateFieldGet(_roomClient, this).joinCharacter({
                interactionId: _classPrivateFieldGet(_interactionId, this),
                characterId: this.id,
                characterRole: _classPrivateFieldGet(_characterRole, this),
                // optional
                displayName: this.displayName,
                // optional
                characterMode: _classPrivateFieldGet(_characterMode, this),
                // optional
                knowledgeBases: _classPrivateFieldGet(_knowledgeBases, this),
                // optional
                language: _classPrivateFieldGet(_language, this),
                // optional
                metaData: this.metaData
              });
            case 1:
              res = _context2.sent;
              if (res) {
                this.id = res.characterId;
                this.displayName = res.displayName;
                _classPrivateFieldSet(_characterMode, this, res.characterMode);
                _classPrivateFieldSet(_characterRole, this, res.characterRole);
                _classPrivateFieldSet(_interactionId, this, res.interactionId);
                _classPrivateFieldSet(_knowledgeBases, this, res.knowledgeBases);
                _classPrivateFieldSet(_language, this, res.language);
                _classPrivateFieldGet(_roomClient, this)._eventEmitter.emit("INIT_CHARACTER", this);
              }
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function join() {
        return _join.apply(this, arguments);
      }
      return join;
    }()
    /**
     * @description Removes the character from the ongoing meeting.
     * @returns {Promise<void>}
     */
    )
  }, {
    key: "leave",
    value: (function () {
      var _leave = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee3() {
        return regenerator_default().wrap(function (_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 1;
              return _classPrivateFieldGet(_roomClient, this).removeCharacter();
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function leave() {
        return _leave.apply(this, arguments);
      }
      return leave;
    }())
  }, {
    key: "remove",
    value: function () {
      var _remove = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee4() {
        return regenerator_default().wrap(function (_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              throw new Error("remove method is not supported on character");
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function remove() {
        return _remove.apply(this, arguments);
      }
      return remove;
    }()
    /**
     * @description Send Message to Character AI
     * @param {string} text - text to complete
     * @returns {Promise<void>}
     */
  }, {
    key: "sendMessage",
    value: (function () {
      var _sendMessage = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee5(text) {
        return regenerator_default().wrap(function (_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 1;
              return _classPrivateFieldGet(_roomClient, this).sendCharacterMessage({
                interactionId: _classPrivateFieldGet(_interactionId, this),
                text: text
              });
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function sendMessage(_x) {
        return _sendMessage.apply(this, arguments);
      }
      return sendMessage;
    }()
    /**
     * @description character state changed handler
     * @private
     * @param {object} data - payload of character state
     * @returns {Promise<void>}
     */
    )
  }, {
    key: "handleCharacterStateChanged",
    value: function handleCharacterStateChanged(data) {
      if (Object.keys(CharacterState).includes(data.status)) {
        _assertClassBrand(_Character_brand, this, _updateState).call(this, data.status);
        this.eventEmitter.emit(EV_CHARACTER_STATE_CHANGED, data);
      }
    }

    /**
     * @description character text handler
     * @private
     * @param {object} data - payload of character text
     * @returns {Promise<void>}
     */
  }, {
    key: "handleCharacterMessage",
    value: function handleCharacterMessage(data) {
      this.eventEmitter.emit(EV_CHARACTER_MESSAGE, data);
    }

    /**
     * @description interrupts character
     * @returns {Promise<void>}
     */
  }, {
    key: "interrupt",
    value: (function () {
      var _interrupt = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee6() {
        return regenerator_default().wrap(function (_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 1;
              return _classPrivateFieldGet(_roomClient, this).interruptCharacter({
                interactionId: _classPrivateFieldGet(_interactionId, this)
              });
            case 1:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function interrupt() {
        return _interrupt.apply(this, arguments);
      }
      return interrupt;
    }()
    /**
     * @description user text handler
     * @private
     * @param {object} data - payload of user text
     * @returns {Promise<void>}
     */
    )
  }, {
    key: "handleUserMessage",
    value: function handleUserMessage(data) {
      this.eventEmitter.emit(EV_USER_MESSAGE, data);
    }

    /**
     * @description on character data
     * @private
     * @param {object} data - payload of character data
     * @returns {Promise<void>}
     */
  }, {
    key: "handleCharacterData",
    value: function handleCharacterData(config) {
      var topic = config.topic,
        data = config.data;
      this.eventEmitter.emit(EV_ON_DATA, topic, data);
    }
  }, {
    key: "handleCharacterError",
    value: function handleCharacterError(config) {
      var data = config.data;
      var errorListenerCount = this.eventEmitter.listenerCount(EV_ON_ERROR);
      if (errorListenerCount > 0) {
        this.eventEmitter.emit(EV_ON_ERROR, data);
      }
    }
  }, {
    key: "enableMic",
    value: function enableMic() {
      _classPrivateFieldGet(_roomClient, this).enablePeerMic(this.id);
    }
  }, {
    key: "disableMic",
    value: function disableMic() {
      _classPrivateFieldGet(_roomClient, this).disablePeerMic(this.id);
    }
  }, {
    key: "enableWebcam",
    value: function enableWebcam() {
      _classPrivateFieldGet(_roomClient, this).enablePeerWebcam(this.id);
    }
  }, {
    key: "disableWebcam",
    value: function disableWebcam() {
      _classPrivateFieldGet(_roomClient, this).disablePeerWebcam(this.id);
    }
  }, {
    key: "updateStream",
    value: function updateStream(stream) {
      throw new Error("updateStream method is not supported on character");
    }
  }, {
    key: "switchTo",
    value: function () {
      var _switchTo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee7(_ref3) {
        var meetingId, payload, token;
        return regenerator_default().wrap(function (_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              meetingId = _ref3.meetingId, payload = _ref3.payload, token = _ref3.token;
              throw new Error("switchTo method is not supported on character");
            case 1:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));
      function switchTo(_x2) {
        return _switchTo.apply(this, arguments);
      }
      return switchTo;
    }()
    /**
     * @param {"SHARE_AND_CAM" | "CAM" | "SHARE"} type
     */
  }, {
    key: "pin",
    value: function pin(type) {
      throw new Error("pin method is not supported on character");
    }
    /**
     * Add event listener
     * @param {EV_STREAM_ENABLED | EV_STREAM_DISABLED | EV_CHARACTER_JOINED | EV_CHARACTER_LEFT | EV_MEDIA_STATUS_CHANGED | EV_VIDEO_QUALITY_CHANGED | EV_CHARACTER_STATE_CHANGED | EV_CHARACTER_MESSAGE | EV_USER_MESSAGE | EV_ON_DATA | EV_ON_ERROR} eventType
     * @param {Function} listener Callback function
     */
  }, {
    key: "on",
    value: function on(eventType, listener) {
      switch (eventType) {
        case character_EV_STREAM_ENABLED:
        case character_EV_STREAM_DISABLED:
        case EV_CHARACTER_JOINED:
        case EV_CHARACTER_LEFT:
        case character_EV_MEDIA_STATUS_CHANGED:
        case character_EV_VIDEO_QUALITY_CHANGED:
        case EV_CHARACTER_STATE_CHANGED:
        case EV_CHARACTER_MESSAGE:
        case EV_USER_MESSAGE:
        case EV_ON_DATA:
        case EV_ON_ERROR:
          this.eventEmitter.on(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type");
          // removed by dead control flow

      }
    }

    /**
     * Remove event listener
     * @param {EV_STREAM_ENABLED | EV_STREAM_DISABLED | EV_CHARACTER_JOINED | EV_CHARACTER_LEFT | EV_MEDIA_STATUS_CHANGED | EV_VIDEO_QUALITY_CHANGED | EV_CHARACTER_STATE_CHANGED | EV_CHARACTER_MESSAGE | EV_USER_MESSAGE | EV_ON_DATA | EV_ON_ERROR} eventType
     * @param {Function} listener Callback function
     */
  }, {
    key: "off",
    value: function off(eventType, listener) {
      switch (eventType) {
        case character_EV_STREAM_ENABLED:
        case character_EV_STREAM_DISABLED:
        case EV_CHARACTER_JOINED:
        case EV_CHARACTER_LEFT:
        case character_EV_MEDIA_STATUS_CHANGED:
        case character_EV_VIDEO_QUALITY_CHANGED:
        case EV_CHARACTER_STATE_CHANGED:
        case EV_CHARACTER_MESSAGE:
        case EV_USER_MESSAGE:
        case EV_ON_DATA:
        case EV_ON_ERROR:
          this.eventEmitter.off(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type");
          // removed by dead control flow

      }
    }
  }, {
    key: "state",
    get: function get() {
      return _classPrivateFieldGet(_state, this);
    }
  }, {
    key: "knowledgeBases",
    get: function get() {
      return _classPrivateFieldGet(_knowledgeBases, this);
    }
  }, {
    key: "characterMode",
    get: function get() {
      return _classPrivateFieldGet(_characterMode, this);
    }
  }, {
    key: "characterRole",
    get: function get() {
      return _classPrivateFieldGet(_characterRole, this);
    }
  }, {
    key: "interactionId",
    get: function get() {
      return _classPrivateFieldGet(_interactionId, this);
    }
  }, {
    key: "language",
    get: function get() {
      return _classPrivateFieldGet(_language, this);
    }
  }]);
}(Participant);
function _updateState(status) {
  _classPrivateFieldSet(_state, this, status);
}

;// ./src/connectionParticipant.js




function connectionParticipant_classPrivateFieldInitSpec(e, t, a) { connectionParticipant_checkPrivateRedeclaration(e, t), t.set(e, a); }
function connectionParticipant_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function connectionParticipant_classPrivateFieldGet(s, a) { return s.get(connectionParticipant_assertClassBrand(s, a)); }
function connectionParticipant_classPrivateFieldSet(s, a, r) { return s.set(connectionParticipant_assertClassBrand(s, a), r), r; }
function connectionParticipant_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }

var _connectionRoomId = /*#__PURE__*/new WeakMap();
var ConnectionParticipant = /*#__PURE__*/function () {
  function ConnectionParticipant(_ref, connectionRoomId) {
    var id = _ref.id,
      displayName = _ref.displayName;
    (0,classCallCheck/* default */.A)(this, ConnectionParticipant);
    connectionParticipant_classPrivateFieldInitSpec(this, _connectionRoomId, void 0);
    /**
     * @type {string}
     */
    this.id = id;
    /**
     * @type {string}
     */
    this.displayName = displayName;
    /**
     * @type {string}
     */
    connectionParticipant_classPrivateFieldSet(_connectionRoomId, this, connectionRoomId);
  }

  /**
   *@param {{meetingId: string, payload: string, token:string }} options
   */
  return (0,createClass/* default */.A)(ConnectionParticipant, [{
    key: "switchTo",
    value: (function () {
      var _switchTo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(_ref2) {
        var meetingId, payload, token;
        return regenerator_default().wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              meetingId = _ref2.meetingId, payload = _ref2.payload, token = _ref2.token;
              _context.next = 1;
              return Store.roomClient.connectionSwitchPeerRoom({
                roomId: meetingId,
                connectionRoomId: connectionParticipant_classPrivateFieldGet(_connectionRoomId, this),
                payload: payload,
                peerId: this.id,
                token: token
              });
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function switchTo(_x) {
        return _switchTo.apply(this, arguments);
      }
      return switchTo;
    }())
  }]);
}();

;// ./src/connectionMeeting.js







var EV_PARTICIPANT_JOINED = "participant-joined";
var EV_PARTICIPANT_LEFT = "participant-left";
var EV_DATA = "data";
var ConnectionMeeting = /*#__PURE__*/function () {
  function ConnectionMeeting(roomId, peers) {
    var _this = this;
    (0,classCallCheck/* default */.A)(this, ConnectionMeeting);
    this.eventEmitter = new events.EventEmitter();

    /**
     * @type {string}
     */
    this.id = roomId;

    /**
     * @type {Map<string, ConnectionParticipant>}
     */
    this.participants = new Map();
    peers.forEach(function (peer) {
      _this.participants.set(peer.id, new ConnectionParticipant(peer, _this.id));
    });
  }
  return (0,createClass/* default */.A)(ConnectionMeeting, [{
    key: "participantJoin",
    value: function participantJoin(peer) {
      var connectionParticipant = new ConnectionParticipant(peer, this.id);
      this.participants.set(peer.id, connectionParticipant);
      this.eventEmitter.emit(EV_PARTICIPANT_JOINED, connectionParticipant);
    }
  }, {
    key: "participantLeft",
    value: function participantLeft(peerId) {
      this.participants["delete"](peerId);
      this.eventEmitter.emit(EV_PARTICIPANT_LEFT, peerId);
    }

    /**
     *
     * @param {string} message
     */
  }, {
    key: "sendChatMessage",
    value: function sendChatMessage(message) {
      Store.roomClient.connectionSendChatMessage({
        roomId: this.id,
        message: message
      });
    }
  }, {
    key: "sendChatMessageEvent",
    value: function sendChatMessageEvent(_ref) {
      var participantId = _ref.participantId,
        message = _ref.message;
      this.eventEmitter.emit(EV_DATA, {
        participantId: participantId,
        message: message
      });
    }
  }, {
    key: "end",
    value: function () {
      var _end = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee() {
        return regenerator_default().wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 1;
              return Store.roomClient.connectionEndMeeting({
                roomId: this.id
              });
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function end() {
        return _end.apply(this, arguments);
      }
      return end;
    }()
    /**
     * Add event listener
     * @param {EV_PARTICIPANT_JOINED | EV_PARTICIPANT_LEFT | EV_DATA} eventType
     * @param {Function} listener Callback function
     */
  }, {
    key: "on",
    value: function on(eventType, listener) {
      switch (eventType) {
        case EV_PARTICIPANT_JOINED:
        case EV_PARTICIPANT_LEFT:
        case EV_DATA:
          this.eventEmitter.on(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type");
          // removed by dead control flow

      }
    }

    /**
     * Remove event listener
     * @param {EV_PARTICIPANT_JOINED | EV_PARTICIPANT_LEFT | EV_DATA} eventType
     * @param {Function} listener Callback function
     */
  }, {
    key: "off",
    value: function off(eventType, listener) {
      switch (eventType) {
        case EV_PARTICIPANT_JOINED:
        case EV_PARTICIPANT_LEFT:
        case EV_DATA:
          this.eventEmitter.off(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type");
          // removed by dead control flow

      }
    }
  }]);
}();

;// ./src/connection.js




var Connection = /*#__PURE__*/function () {
  function Connection(_ref) {
    var roomId = _ref.roomId,
      peers = _ref.peers,
      payload = _ref.payload;
    (0,classCallCheck/* default */.A)(this, Connection);
    /**
     * @type {string}
     */
    this.id = roomId;
    /**
     * @type {string}
     */
    this.payload = payload;
    this.meeting = new ConnectionMeeting(roomId, peers);
  }
  return (0,createClass/* default */.A)(Connection, [{
    key: "close",
    value: function close() {
      Store.roomClient.closeConnection(this.id);
    }
  }]);
}();

;// ./src/meeting.js







function meeting_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function meeting_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? meeting_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : meeting_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

function meeting_classPrivateMethodInitSpec(e, a) { meeting_checkPrivateRedeclaration(e, a), a.add(e); }
function meeting_classPrivateFieldInitSpec(e, t, a) { meeting_checkPrivateRedeclaration(e, t), t.set(e, a); }
function meeting_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function meeting_classPrivateFieldGet(s, a) { return s.get(meeting_assertClassBrand(s, a)); }
function meeting_classPrivateFieldSet(s, a, r) { return s.set(meeting_assertClassBrand(s, a), r), r; }
function meeting_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }








var EV_ERROR = "error";
var EV_MEETING_JOINED = "meeting-joined";
var EV_MEETING_LEFT = "meeting-left";
var EV_PARTICIPANT_MODE_CHANGED = "participant-mode-changed";
var meeting_EV_PARTICIPANT_JOINED = "participant-joined";
var meeting_EV_PARTICIPANT_LEFT = "participant-left";
var EV_SPEAKER_CHANGED = "speaker-changed";
var EV_PRESENTER_CHANGED = "presenter-changed";
var EV_MAIN_PARTICIPANT_CHANGED = "main-participant-changed";
var meeting_EV_DATA = "data";
var EV_ENTRY_REQUESTED = "entry-requested";
var EV_ENTRY_RESPONDED = "entry-responded";
var EV_RECORDING_STATE_CHANGED = "recording-state-changed";
var EV_RECORDING_STARTED = "recording-started";
var EV_RECORDING_STOPPED = "recording-stopped";
var EV_LIVESTREAM_STATE_CHANGED = "livestream-state-changed";
var EV_LIVESTREAM_STARTED = "livestream-started";
var EV_LIVESTREAM_STOPPED = "livestream-stopped";
var EV_HLS_STATE_CHANGED = "hls-state-changed";
var EV_HLS_STARTED = "hls-started";
var EV_HLS_STOPPED = "hls-stopped";
var EV_WHITEBOARD_STARTED = "whiteboard-started";
var EV_WHITEBOARD_STOPPED = "whiteboard-stopped";
var EV_VIDEO_STATE_CHANGED = "video-state-changed";
var EV_VIDEO_SEEKED = "video-seeked";
var EV_MIC_REQUESTED = "mic-requested";
var EV_WEBCAM_REQUESTED = "webcam-requested";
var meeting_EV_STREAM_ENABLED = "stream-enabled";
var meeting_EV_STREAM_DISABLED = "stream-disabled";
var EV_PIN_STATE_CHANGED = "pin-state-changed";
var EV_CONNECTION_OPEN = "connection-open";
var EV_CONNECTION_CLOSE = "connection-close";
var EV_SWITCH_MEETING = "switch-meeting";
var EV_MEETING_STATE_CHANGE = "meeting-state-changed";
var EV_QUALITY_LIMITATION = "quality-limitation";
var EV_ALL_STREAMS_PAUSED = "paused-all-streams";
var EV_ALL_STREAMS_RESUMED = "resumed-all-streams";
var EV_TRANSCRIPTION_STATE_CHANGED = "transcription-state-changed";
var EV_TRANSCRIPTION_TEXT = "transcription-text";
var meeting_EV_CHARACTER_JOINED = "character-joined";
var meeting_EV_CHARACTER_LEFT = "character-left";
var EV_MEDIA_RELAY_STARTED = 'media-relay-started';
var EV_MEDIA_RELAY_STOPPED = 'media-relay-stopped';
var EV_MEDIA_RELAY_ERROR = 'media-relay-error';
var EV_MEDIA_RELAY_REQUEST_RESPONSE = 'media-relay-request-response';
var EV_MEDIA_RELAY_REQUEST_RECEIVED = 'media-relay-request-received';
var _topicEventEmitter = /*#__PURE__*/new WeakMap();
var _Meeting_brand = /*#__PURE__*/new WeakSet();
var Meeting = /*#__PURE__*/function () {
  /**
   * Create a new meeting with id
   * @param {string} meetingId
   * @param {Participant} localParticipant
   * @param {RoomClient} roomClient
   */
  function Meeting(meetingId, localParticipant, roomClient) {
    var _this = this;
    (0,classCallCheck/* default */.A)(this, Meeting);
    meeting_classPrivateMethodInitSpec(this, _Meeting_brand);
    meeting_classPrivateFieldInitSpec(this, _topicEventEmitter, void 0);
    (0,defineProperty/* default */.A)(this, "pubSub", {
      /**
       * Publish message to a topic
       *
       * @param {String} topic
       * @param {String} message
       * @param {{ persist: boolean, sendOnly: Array<String> }} options
       * @param {object} payload
       */

      publish: function () {
        var _publish = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(topic, message, options, payload) {
          return regenerator_default().wrap(function (_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(payload != undefined)) {
                  _context.next = 1;
                  break;
                }
                if (!((0,esm_typeof/* default */.A)(payload) != "object")) {
                  _context.next = 1;
                  break;
                }
                throw new Error("\"payload\" can only be object.");
              case 1:
                _context.next = 2;
                return _this.roomClient.pubsubPublish(topic, message, options, payload);
              case 2:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function publish(_x, _x2, _x3, _x4) {
          return _publish.apply(this, arguments);
        }
        return publish;
      }(),
      /**
       * Subscribe to message on a topic
       *
       * @param {String} topic
       * @param {Function} callback
       */
      subscribe: function () {
        var _subscribe = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2(topic, callback) {
          var messageArr;
          return regenerator_default().wrap(function (_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                if (!meeting_classPrivateFieldGet(_topicEventEmitter, _this).listeners(topic).includes(callback)) {
                  _context2.next = 1;
                  break;
                }
                return _context2.abrupt("return");
              case 1:
                _context2.next = 2;
                return _this.roomClient.pubsubSubscribe(topic);
              case 2:
                messageArr = _context2.sent;
                meeting_classPrivateFieldGet(_topicEventEmitter, _this).on(topic, callback);
                return _context2.abrupt("return", messageArr);
              case 3:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function subscribe(_x5, _x6) {
          return _subscribe.apply(this, arguments);
        }
        return subscribe;
      }(),
      /**
       * Unsubscribe from messages on a topic
       *
       * @param {String} topic
       * @param {Function} callback
       */
      unsubscribe: function () {
        var _unsubscribe = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee3(topic, callback) {
          return regenerator_default().wrap(function (_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                meeting_classPrivateFieldGet(_topicEventEmitter, _this).off(topic, callback);

                //if all listeners are removed then  call unsubscribe;
                if (!(meeting_classPrivateFieldGet(_topicEventEmitter, _this).listeners(topic).length == 0)) {
                  _context3.next = 1;
                  break;
                }
                _context3.next = 1;
                return _this.roomClient.pubsubUnsubscribe(topic);
              case 1:
              case "end":
                return _context3.stop();
            }
          }, _callee3);
        }));
        function unsubscribe(_x7, _x8) {
          return _unsubscribe.apply(this, arguments);
        }
        return unsubscribe;
      }()
    });
    /**
     *
     * @param {{base64Data: string, token: string, fileName: string}} options
     * @returns {Promise<string?>}
     */
    (0,defineProperty/* default */.A)(this, "uploadBase64File", /*#__PURE__*/function () {
      var _ref2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee4(_ref) {
        var base64Data, token, fileName, url, requestBody, apiResponse, responseData, _t;
        return regenerator_default().wrap(function (_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              base64Data = _ref.base64Data, token = _ref.token, fileName = _ref.fileName;
              _context4.prev = 1;
              if (!(!base64Data || !token || !fileName)) {
                _context4.next = 2;
                break;
              }
              throw new Error("please provide base64Data, token and fileName");
            case 2:
              url = "https://".concat(_this.baseUrl, "/base64-upload?roomId=").concat(_this.id);
              requestBody = {
                fileName: fileName,
                base64Data: base64Data
              };
              _context4.next = 3;
              return fetch(url, {
                method: "POST",
                body: JSON.stringify(requestBody),
                headers: {
                  "Content-Type": "application/json",
                  Authorization: token
                }
              });
            case 3:
              apiResponse = _context4.sent;
              _context4.next = 4;
              return apiResponse.json();
            case 4:
              responseData = _context4.sent;
              return _context4.abrupt("return", responseData.url);
            case 5:
              _context4.prev = 5;
              _t = _context4["catch"](1);
              console.error("Error while Uploading Base64 File::", _t);
              if (_this.roomClient._videosdkLogs) {
                _this.roomClient._videosdkLogs.pushLogs({
                  logText: "Error while Uploading Base64 File",
                  logType: "ERROR",
                  attributes: {
                    error: _t.message
                  }
                });
              }
            case 6:
            case "end":
              return _context4.stop();
          }
        }, _callee4, null, [[1, 5]]);
      }));
      return function (_x9) {
        return _ref2.apply(this, arguments);
      };
    }());
    /**
     *
     * @param {{url: string, token: string}} options
     * @returns {Promise<string?>}
     */
    (0,defineProperty/* default */.A)(this, "fetchBase64File", /*#__PURE__*/function () {
      var _ref4 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee5(_ref3) {
        var url, token, res, binaryData, base64Data, _t2;
        return regenerator_default().wrap(function (_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              url = _ref3.url, token = _ref3.token;
              _context5.prev = 1;
              if (!(!url || !token)) {
                _context5.next = 2;
                break;
              }
              throw new Error("please provide url and token");
            case 2:
              _context5.next = 3;
              return fetch(url, {
                headers: {
                  Authorization: token
                }
              });
            case 3:
              res = _context5.sent;
              _context5.next = 4;
              return res.arrayBuffer();
            case 4:
              binaryData = _context5.sent;
              //converting array buffer to string
              base64Data = window.btoa(new Uint8Array(binaryData).reduce(function (data, _byte) {
                return data + String.fromCharCode(_byte);
              }, ""));
              return _context5.abrupt("return", base64Data);
            case 5:
              _context5.prev = 5;
              _t2 = _context5["catch"](1);
              console.error("Error while fetching Base64 File::", _t2);
              if (_this.roomClient._videosdkLogs) {
                _this.roomClient._videosdkLogs.pushLogs({
                  logText: "Error while fetching Base64 File",
                  logType: "ERROR",
                  attributes: {
                    error: _t2.message
                  }
                });
              }
            case 6:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[1, 5]]);
      }));
      return function (_x0) {
        return _ref4.apply(this, arguments);
      };
    }());
    /**
     * @type {string}
     */
    this.id = meetingId;
    this.roomClient = roomClient;
    /**
     * @type {string}
     */
    this.activeSpeakerId = null;
    /**
     * @type {string}
     */
    this.activePresenterId = null;
    /**
     * @type {string}
     */
    this.mainParticipantId = null;
    /**
     * @type {Map<string, Connection>}
     */
    this.connections = new Map();

    /**
     * @type {Participant}
     */
    this.localParticipant = localParticipant;

    /**
     * @type {Map<string, Participant>}
     */
    this.participants = new Map();

    /**
     * @type {Map<string, Character>}
     */
    this.characters = new Map();
    /**
     * @type {string}
     */
    this.baseUrl = null;
    /**
     * @type {string}
     */
    this.livestreamState = "LIVESTREAM_STOPPED";
    /**
     * @type {string}
     */
    this.recordingState = "RECORDING_STOPPED";
    /**
     * @type {string}
     */
    this.hlsState = "HLS_STOPPED";
    /**
     * @type {string}
     */
    this.transcriptionState = "TRANSCRIPTION_STOPPED";
    /**
     * @type {Object}
     */
    this.hlsUrls = {
      downstreamUrl: null,
      playbackHlsUrl: null,
      livestreamUrl: null
    };
    this.messages = [];
    this.eventEmitter = new events.EventEmitter();
    meeting_classPrivateFieldSet(_topicEventEmitter, this, new events.EventEmitter());
    this.eventEmitter.setMaxListeners(9999);
    meeting_classPrivateFieldGet(_topicEventEmitter, this).setMaxListeners(9999);
    this.roomClient.on("ERROR", function (d) {
      return _this.handleError(d);
    });
    this.roomClient.on("ADD_PEER", function (d) {
      return _this.handlePeerAdd(d);
    });
    this.roomClient.on("REMOVE_PEER", function (d) {
      return _this.handlePeerRemove(d);
    });
    this.roomClient.on("STREAM_STATE_CHANGED", function (d) {
      return _this.handleStreamState(d);
    });
    this.roomClient.on("ADD_PRODUCER", function (d) {
      return _this.handleProducerAdd(d);
    });
    this.roomClient.on("UPDATE_PRODUCER", function (d) {
      return _this.handleUpdateProducer(d);
    });
    this.roomClient.on("REMOVE_PRODUCER", function (d) {
      return _this.handleProducerRemove(d);
    });
    this.roomClient.on("ADD_CONSUMER", function (d) {
      return _this.handleConsumerAdd(d);
    });
    this.roomClient.on("REMOVE_CONSUMER", function (d) {
      return _this.handleConsumerRemove(d);
    });
    this.roomClient.on("CONSUMER_RESUMED", function (d) {
      return _this.handleConsumerResume(d);
    });
    this.roomClient.on("CONSUMER_PAUSED", function (d) {
      return _this.handleConsumerPause(d);
    });
    this.roomClient.on("PARTICIPANT_MEDIA_STATE_CHANGED", function (d) {
      return _this.handleParticipantMediaStateChanged(d);
    });
    this.roomClient.on("DATA", function (d) {
      return _this.handleNewChatMessage(d);
    });
    this.roomClient.on("SET_ROOM_ACTIVE_SPEAKER", function (d) {
      return _this.handleSpeakerChange(d);
    });
    this.roomClient.on("ENTRY_REQUESTED", function (d) {
      return _this.handleEntryRequested(d);
    });
    this.roomClient.on("ENTRY_RESPONDED", function (d) {
      return _this.handleEntryResponded(d);
    });
    this.roomClient.on("MEETING_JOINED", function (d) {
      return _this.handleMeetingJoined(d);
    });
    this.roomClient.on("MEETING_LEFT", function (d) {
      return _this.handleMeetingLeft(d);
    });
    this.roomClient.on("RECORDING_STATE_CHANGED", function (d) {
      _this.handleRecordingStateChanged(d);
    });
    this.roomClient.on("RECORDING_STARTED", function (d) {
      return _this.handleRecordingStarted(d);
    });
    this.roomClient.on("RECORDING_STOPPED", function (d) {
      return _this.handleRecordingStopped(d);
    });
    this.roomClient.on("LIVESTREAM_STATE_CHANGED", function (d) {
      _this.handleLivestreamStateChanged(d);
    });
    this.roomClient.on("LIVESTREAM_STARTED", function (d) {
      return _this.handleLivestreamStarted(d);
    });
    this.roomClient.on("LIVESTREAM_STOPPED", function (d) {
      return _this.handleLivestreamStopped(d);
    });
    this.roomClient.on("HLS_STATE_CHANGED", function (d) {
      _this.handleHlsStateChanged(d);
    });
    this.roomClient.on("HLS_STARTED", function (d) {
      _this.handleHlsStarted(d);
    });
    this.roomClient.on("HLS_STOPPED", function (d) {
      _this.handleHlsStopped(d);
    });
    this.roomClient.on("TRANSCRIPTION_STATE_CHANGED", function (d) {
      _this.handleTranscriptionStateChanged(d);
    });
    this.roomClient.on("TRANSCRIPTION_TEXT", function (d) {
      _this.handleTranscriptionText(d);
    });
    this.roomClient.on("SUB_MANAGER_RESUMED", function (d) {
      _this.handleParticipantResumeBySubManager(d);
    });
    this.roomClient.on("SUB_MANAGER_PAUSED", function (d) {
      _this.handleParticipantPausedBySubManager(d);
    });
    this.roomClient.on("WHITEBOARD_STARTED", function (d) {
      return _this.handleWhiteboardStarted(d);
    });
    this.roomClient.on("WHITEBOARD_STOPPED", function (d) {
      return _this.handleWhiteboardStopped(d);
    });
    this.roomClient.on("VIDEO_STATE_CHANGED", function (d) {
      return _this.handleVideoStateChanged(d);
    });
    this.roomClient.on("VIDEO_SEEKED", function (d) {
      return _this.handleVideoSeeked(d);
    });
    this.roomClient.on("PIN_STATE_CHANGED", function (d) {
      _this.handlePinStateChanged(d);
    });
    this.roomClient.on("MIC_REQUESTED", function (d) {
      return _this.handleMicRequested(d);
    });
    this.roomClient.on("WEBCAM_REQUESTED", function (d) {
      return _this.handleWebcamRequested(d);
    });
    this.roomClient.on("CONNECTION_OPEN", function (d) {
      return _this.handleConnectionOpen(d);
    });
    this.roomClient.on("CONNECTION_CLOSE", function (d) {
      return _this.handleConnectionClose(d);
    });
    this.roomClient.on("CONNECTION_PARTICIPANT_JOIN", function (d) {
      return _this.handleConnectionParticipantJoin(d);
    });
    this.roomClient.on("SWITCH_ROOM", function (d) {
      return _this.handleSwitchMeeting(d);
    });
    this.roomClient.on("CONNECTION_CHAT_MESSAGE", function (d) {
      return _this.handleConnectionChatMessage(d);
    });
    this.roomClient.on("CONNECTION_PARTICIPANT_LEFT", function (d) {
      _this.handleConnectionParticipantLeft(d);
    });
    this.roomClient.on("PUBSUB_MESSAGE", function (d) {
      return meeting_assertClassBrand(_Meeting_brand, _this, _handlePubsubMessage).call(_this, d);
    });
    this.roomClient.on("PEER_MODE_CHANGED", function (d) {
      return meeting_assertClassBrand(_Meeting_brand, _this, _handlePeerModeChanged).call(_this, d);
    });
    this.updateMainParticipant(this.localParticipant.id);
    this.roomClient.on("MEETING_STATE_CHANGED", function (d) {
      return _this.handleMeetingStateChanged(d);
    });
    this.roomClient.on("QUALITY_LIMITATION_INTERNAL", function (d) {
      return _this.handleQualityChanged(d);
    });
    this.roomClient.on("ALL_CONSUMERS_PAUSED", function (d) {
      return _this.handleConsumersPaused(d);
    });
    this.roomClient.on("ALL_CONSUMERS_RESUMED", function (d) {
      return _this.handleConsumersResumed(d);
    });
    this.roomClient.on("VIDEO_QUALITY_CHANGED", function (d) {
      return _this.handleVideoQualityChanged(d);
    });
    this.roomClient.on("ADD_CHARACTER", function (d) {
      return _this.handleAddCharacter(d);
    });
    this.roomClient.on("INIT_CHARACTER", function (d) {
      return _this.handleInitCharacter(d);
    });
    this.roomClient.on("REMOVE_CHARACTER", function (d) {
      return _this.handleRemoveCharacter(d);
    });
    this.roomClient.on("CHARACTER_STATE_CHANGED", function (d) {
      return _this.handleCharacterStateChanged(d);
    });
    this.roomClient.on("CHARACTER_MESSAGE", function (d) {
      return _this.handleCharacterMessage(d);
    });
    this.roomClient.on("USER_MESSAGE", function (d) {
      return _this.handleUserMessage(d);
    });
    this.roomClient.on("CHARACTER_DATA", function (d) {
      return _this.handleOnCharacterData(d);
    });
    this.roomClient.on("CHARACTER_ERROR", function (d) {
      return _this.handleOnCharacterError(d);
    });
    this.roomClient.on("E2EE_STATE_CHANGE", function (d) {
      return _this.handleE2EEStateChange(d);
    });
    this.roomClient.on("REMOVE_PARTICIPANTS_FOR_SWITCH_MEETING", function () {
      return _this.handleOnRemoveCurrentMeetingParticipant();
    });
    this.roomClient.on("MEDIA_RELAY_STARTED", function (d) {
      return _this.handleMediaRelayStart(d);
    });
    this.roomClient.on("MEDIA_RELAY_STOPPED", function (d) {
      return _this.handleMediaRelayStop(d);
    });
    this.roomClient.on("MEDIA_RELAY_ERROR", function (d) {
      return _this.handleMediaRelayError(d);
    });
    this.roomClient.on("MEDIA_RELAY_REQUEST_RESPONSE", function (d) {
      return _this.handleMediaRelayRequestResponse(d);
    });
    this.roomClient.on("MEDIA_RELAY_REQUEST_RECEIVED", function (d) {
      return _this.handleMediaRelayRequest(d);
    });
  }
  return (0,createClass/* default */.A)(Meeting, [{
    key: "isE2EEEnabled",
    get: function get() {
      return this.roomClient.isE2EEEnabled;
    }
  }, {
    key: "handleError",
    value: function handleError(error) {
      var errorListenerCount = this.eventEmitter.listenerCount(EV_ERROR);
      if (errorListenerCount > 0) {
        this.eventEmitter.emit(EV_ERROR, error);
      }
    }
  }, {
    key: "join",
    value: function join() {
      this.roomClient.join();
    }
  }, {
    key: "changeMode",
    value: function changeMode(mode) {
      this.roomClient.changeMode(mode);
    }
  }, {
    key: "leave",
    value: function leave() {
      this.roomClient.close({
        sendLeft: true
      });
    }
  }, {
    key: "end",
    value: function end() {
      this.roomClient.closeRoom();
    }

    /**
     *
     * @param {string} participantId
     * @param {boolean} decision
     */
  }, {
    key: "respondEntry",
    value: function respondEntry(participantId, decision) {
      this.roomClient.respondEntry(participantId, decision);
    }

    /**
     * @returns {Map<string, Participant>}
     */
  }, {
    key: "pinnedParticipants",
    get: function get() {
      return this.roomClient._pinnedParticipants;
    }
  }, {
    key: "muteMic",
    value: function muteMic() {
      this.roomClient.disableMic();
    }

    /**
     * @param {MediaStream | undefined} customAudioTrack?
     */
  }, {
    key: "unmuteMic",
    value: function unmuteMic() {
      var customAudioTrack = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this.roomClient.enableMic(customAudioTrack);
    }

    /**
     *
     * @param {MediaStream | undefined} customAudioTrack?
     * @returns
     */
  }, {
    key: "publishAudio",
    value: (function () {
      var _publishAudio = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee6() {
        var customAudioTrack,
          _args6 = arguments;
        return regenerator_default().wrap(function (_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              customAudioTrack = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : undefined;
              _context6.next = 1;
              return this.roomClient.enableMic(customAudioTrack);
            case 1:
              return _context6.abrupt("return");
            case 2:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function publishAudio() {
        return _publishAudio.apply(this, arguments);
      }
      return publishAudio;
    }())
  }, {
    key: "unpublishAudio",
    value: function () {
      var _unpublishAudio = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee7() {
        return regenerator_default().wrap(function (_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 1;
              return this.roomClient.disableMic();
            case 1:
              return _context7.abrupt("return");
            case 2:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function unpublishAudio() {
        return _unpublishAudio.apply(this, arguments);
      }
      return unpublishAudio;
    }()
  }, {
    key: "disableWebcam",
    value: function disableWebcam() {
      this.roomClient.disableWebcam();
    }

    /**
     * @param {MediaStream | undefined} customVideoTrack?
     */
  }, {
    key: "enableWebcam",
    value: function enableWebcam() {
      var customVideoTrack = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this.roomClient.enableWebcam(customVideoTrack);
    }
    /**
     * @param {MediaStream | undefined} customVideoTrack?
     */
  }, {
    key: "publishVideo",
    value: (function () {
      var _publishVideo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee8() {
        var customVideoTrack,
          _args8 = arguments;
        return regenerator_default().wrap(function (_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              customVideoTrack = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : undefined;
              this.roomClient.enableWebcam(customVideoTrack);
              return _context8.abrupt("return");
            case 1:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function publishVideo() {
        return _publishVideo.apply(this, arguments);
      }
      return publishVideo;
    }())
  }, {
    key: "unpublishVideo",
    value: function () {
      var _unpublishVideo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee9() {
        return regenerator_default().wrap(function (_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              this.roomClient.disableWebcam();
              return _context9.abrupt("return");
            case 1:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function unpublishVideo() {
        return _unpublishVideo.apply(this, arguments);
      }
      return unpublishVideo;
    }()
  }, {
    key: "disableScreenShare",
    value: function disableScreenShare() {
      this.roomClient.disableShare();
    }

    /**
     *  @param {MediaStream | undefined}customScreenSharingTrack?
     */
  }, {
    key: "enableScreenShare",
    value: function enableScreenShare() {
      var customScreenSharingTrack = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this.roomClient.enableShare(customScreenSharingTrack);
    }

    /**
     *  @param {MediaStream | undefined}customScreenSharingTrack?
     */
  }, {
    key: "pubblishScreenShare",
    value: function pubblishScreenShare() {
      var customScreenSharingTrack = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this.roomClient.enableShare(customScreenSharingTrack);
    }
  }, {
    key: "unpublishScreenShare",
    value: function unpublishScreenShare() {
      this.roomClient.disableShare();
    }

    /**
    * Send a message over the DataChannel with chunking.
    *
    * @param {string | Blob | ArrayBuffer | ArrayBufferView} payload - The message to send.
    * @param {object} [options={}] - Additional send options.
    * @param {("RELIABLE"|"UNRELIABLE")} [options.reliability="RELIABLE"] - Reliability mode for the message.
    */
  }, {
    key: "send",
    value: (function () {
      var _send = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee0(payload, options) {
        return regenerator_default().wrap(function (_context0) {
          while (1) switch (_context0.prev = _context0.next) {
            case 0:
              _context0.next = 1;
              return this.roomClient.send(payload, options);
            case 1:
              return _context0.abrupt("return", _context0.sent);
            case 2:
            case "end":
              return _context0.stop();
          }
        }, _callee0, this);
      }));
      function send(_x1, _x10) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
    /**
     * @param {string} kind?
     */
    )
  }, {
    key: "pauseAllStreams",
    value: function pauseAllStreams(kind) {
      this.roomClient.pauseAllConsumers(kind);
    }

    /**
     * @param {string} kind?
     */
  }, {
    key: "resumeAllStreams",
    value: function resumeAllStreams(kind) {
      this.roomClient.resumeAllConsumers(kind);
    }

    /**
     * @param {string} webhookUrl?
     * @param {string} awsDirPath?
     * @param {{layout: { type: "GRID" | "SPOTLIGHT" | "SIDEBAR" , priority: "SPEAKER" | "PIN", gridSize: number}}} config?
     * @param {{enabled: boolean , summary: { enabled: boolean, prompt: string | undefined } | undefined}} transcription?
     */
  }, {
    key: "startRecording",
    value: function startRecording(webhookUrl, awsDirPath, config, transcription) {
      this.roomClient.startRecording(webhookUrl, awsDirPath, config, transcription);
    }
  }, {
    key: "stopRecording",
    value: function stopRecording() {
      this.roomClient.stopRecording();
    }

    /**
     * @param {any} config?
     */
  }, {
    key: "startTranscription",
    value: function startTranscription(config) {
      this.roomClient.startTranscription(config);
    }
  }, {
    key: "stopTranscription",
    value: function stopTranscription() {
      this.roomClient.stopTranscription();
    }

    /**
     * @param {{layout: { type: "GRID" | "SPOTLIGHT" | "SIDEBAR" , priority: "SPEAKER" | "PIN", gridSize: number}}} config?
     * @param {Array<{url : string, streamKey: string}>} outputs
     */
  }, {
    key: "startLivestream",
    value: function startLivestream(outputs, config) {
      this.roomClient.startLivestream(outputs, config);
    }
  }, {
    key: "stopLivestream",
    value: function stopLivestream() {
      this.roomClient.stopLivestream();
    }

    /**
     * @param {{layout: { type: "GRID" | "SPOTLIGHT" | "SIDEBAR" , priority: "SPEAKER" | "PIN", gridSize: number}}} config?
     * @param {{enabled: boolean , summary: { enabled: boolean, prompt: string | undefined } | undefined}} transcription?
     */
  }, {
    key: "startHls",
    value: (function () {
      var _startHls = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee1(config, transcription) {
        return regenerator_default().wrap(function (_context1) {
          while (1) switch (_context1.prev = _context1.next) {
            case 0:
              _context1.next = 1;
              return this.roomClient.startHls(config, transcription);
            case 1:
            case "end":
              return _context1.stop();
          }
        }, _callee1, this);
      }));
      function startHls(_x11, _x12) {
        return _startHls.apply(this, arguments);
      }
      return startHls;
    }())
  }, {
    key: "stopHls",
    value: function stopHls() {
      this.roomClient.stopHls();
    }
  }, {
    key: "createCharacter",
    value: function createCharacter(config) {
      if (!config.interactionId && !config.id) {
        throw new Error("InteractionId or id is required");
      }
      return new Character(meeting_objectSpread(meeting_objectSpread({}, config), {}, {
        roomClient: this.roomClient
      }));
    }
  }, {
    key: "getMics",
    value: function () {
      var _getMics = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee10() {
        return regenerator_default().wrap(function (_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 1;
              return this.roomClient.getMics();
            case 1:
              return _context10.abrupt("return", _context10.sent);
            case 2:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function getMics() {
        return _getMics.apply(this, arguments);
      }
      return getMics;
    }()
  }, {
    key: "getWebcams",
    value: function () {
      var _getWebcams = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee11() {
        return regenerator_default().wrap(function (_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 1;
              return this.roomClient.getWebcams();
            case 1:
              return _context11.abrupt("return", _context11.sent);
            case 2:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function getWebcams() {
        return _getWebcams.apply(this, arguments);
      }
      return getWebcams;
    }()
    /**
     *
     * @param {string | MediaStream } object
     */
  }, {
    key: "changeMic",
    value: function changeMic(object) {
      this.roomClient.changeMic(object);
    }

    /**
     *
     * @param {string | MediaStream } object
     */
  }, {
    key: "changeWebcam",
    value: function changeWebcam(object) {
      this.roomClient.changeWebcam(object);
    }

    /**
     *
     * @param { MediaStream } stream
     */
  }, {
    key: "replaceWebcamStream",
    value: function replaceWebcamStream(stream) {
      this.roomClient.replaceWebcamStream(stream);
    }

    /**
     *
     * @param {"low" | "med" | "high"} quality
     */
  }, {
    key: "setWebcamQuality",
    value: function setWebcamQuality(quality) {
      this.roomClient.setWebcamQuality(quality);
    }
  }, {
    key: "startWhiteboard",
    value: function startWhiteboard() {
      this.roomClient.startWhiteboard();
    }
  }, {
    key: "stopWhiteboard",
    value: function stopWhiteboard() {
      this.roomClient.stopWhiteboard();
    }

    /**
     *
     * @param {{link: string}} options
     */
  }, {
    key: "startVideo",
    value: function startVideo(_ref5) {
      var link = _ref5.link;
      this.roomClient.startVideo({
        link: link
      });
    }
  }, {
    key: "stopVideo",
    value: function stopVideo() {
      this.roomClient.stopVideo();
    }
  }, {
    key: "resumeVideo",
    value: function resumeVideo() {
      this.roomClient.resumeVideo();
    }
  }, {
    key: "refreshConnection",
    value: function refreshConnection() {
      this.roomClient.restartIce();
    }

    /**
     *
     * @param {{currentTime: number}} options
     */
  }, {
    key: "pauseVideo",
    value: function pauseVideo(_ref6) {
      var currentTime = _ref6.currentTime;
      this.roomClient.pauseVideo(currentTime);
    }

    /**
     *
     * @param {{currentTime: number}} options
     */
  }, {
    key: "seekVideo",
    value: function seekVideo(_ref7) {
      var currentTime = _ref7.currentTime;
      this.roomClient.seekVideo(currentTime);
    }
  }, {
    key: "handlePeerAdd",
    value: function handlePeerAdd(_ref8) {
      var peer = _ref8.peer;
      var participant = new Participant(peer);
      this.participants.set(participant.id, participant);
      this.eventEmitter.emit(meeting_EV_PARTICIPANT_JOINED, participant);
      if (this.participants.size === 1) {
        this.updateMainParticipant(participant.id);
      }
    }
  }, {
    key: "handleStreamState",
    value: function handleStreamState(_ref9) {
      var state = _ref9.state,
        peerId = _ref9.peerId,
        streamId = _ref9.streamId;
      var participant = this.participants.get(peerId);
      if (participant == null) return;
      participant.handleStreamStateChanged({
        state: state,
        peerId: peerId,
        streamId: streamId
      });
    }
  }, {
    key: "handlePeerRemove",
    value: function handlePeerRemove(_ref0) {
      var peerId = _ref0.peerId;
      var participant = this.participants.get(peerId);
      if (participant == null) return;
      this.participants["delete"](peerId);
      this.eventEmitter.emit(meeting_EV_PARTICIPANT_LEFT, participant);

      // update presenter
      if (this.activePresenterId === participant.id) {
        this.activePresenterId = null;
        this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
      }

      // update main participant
      if (this.mainParticipantId === participant.id) {
        if (this.participants.size > 0) {
          this.updateMainParticipant(this.participants.entries().next().value[1].id);
        } else {
          this.updateMainParticipant(this.localParticipant.id);
        }
      }
    }
  }, {
    key: "handleProducerAdd",
    value: function handleProducerAdd(_ref1) {
      var producer = _ref1.producer;
      var producerInfo = {
        id: producer.id,
        rtpSender: producer.rtpSender
      };
      this.localParticipant.addProducer(producerInfo);
      var stream = new Stream(producer);
      this.localParticipant.addStream(stream);
      if (stream.kind === "share") {
        this.activePresenterId = this.localParticipant.id;
        this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
        this.updateMainParticipant(this.localParticipant.id);
      }
    }
  }, {
    key: "handleUpdateProducer",
    value: function handleUpdateProducer(_ref10) {
      var producer = _ref10.producer;
      var stream = new Stream(producer);
      this.localParticipant.updateStream(stream);
    }
  }, {
    key: "handleProducerRemove",
    value: function handleProducerRemove(_ref11) {
      var producerId = _ref11.producerId;
      this.localParticipant.removeProducer(producerId);
      var stream = this.localParticipant.deleteStream(producerId);
      if (stream && stream.kind === "share") {
        this.activePresenterId = null;
        this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
        var nextParticipant = this.participants.size > 0 ? this.participants.entries().next().value[1].id : null;
        this.updateMainParticipant(this.activeSpeakerId || nextParticipant || this.localParticipant.id);
      }
    }
  }, {
    key: "handleConsumerAdd",
    value: function handleConsumerAdd(_ref12) {
      var consumer = _ref12.consumer,
        peerId = _ref12.peerId;
      var participant = this.participants.get(peerId) || this.characters.get(peerId);
      if (participant) {
        var consumerInfo = {
          id: consumer.id,
          rtpReceiver: consumer.rtpReceiver
        };
        participant.addConsumer(consumerInfo);
        var stream = new Stream(consumer);
        participant.addStream(stream);
        this.eventEmitter.emit(meeting_EV_STREAM_ENABLED, stream);
        if (stream.kind === "share") {
          this.activePresenterId = participant.id;
          this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
          this.updateMainParticipant(participant.id);
        }
      }
    }
  }, {
    key: "handleConsumerResume",
    value: function handleConsumerResume(_ref13) {
      var consumerId = _ref13.consumerId,
        peerId = _ref13.peerId;
      var participant = this.participants.get(peerId);
      if (participant) {
        participant.streamResumed(consumerId);
      }
    }
  }, {
    key: "handleConsumerPause",
    value: function handleConsumerPause(_ref14) {
      var consumerId = _ref14.consumerId,
        peerId = _ref14.peerId;
      var participant = this.participants.get(peerId);
      if (participant) {
        participant.streamPaused(consumerId);
      }
    }
  }, {
    key: "handleConsumerRemove",
    value: function handleConsumerRemove(_ref15) {
      var consumerId = _ref15.consumerId,
        peerId = _ref15.peerId;
      var participant = this.participants.get(peerId) || this.characters.get(peerId);
      if (participant == null) return;
      if (participant) {
        participant.removeConsumer(consumerId);
        var stream = participant.deleteStream(consumerId);
        this.eventEmitter.emit(meeting_EV_STREAM_DISABLED, stream);
        if (stream && stream.kind === "share") {
          this.activePresenterId = null;
          this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
          var nextParticipant = this.participants.size > 0 ? this.participants.entries().next().value[1].id : null;
          this.updateMainParticipant(this.activeSpeakerId || nextParticipant || this.localParticipant.id);
        }
      }
    }
  }, {
    key: "handleParticipantMediaStateChanged",
    value: function handleParticipantMediaStateChanged(_ref16) {
      var peerId = _ref16.peerId,
        kind = _ref16.kind,
        newState = _ref16.newState;
      var participant = this.participants.get(peerId) || this.characters.get(peerId);
      if (this.localParticipant.id == peerId) {
        participant = this.localParticipant;
      }
      if (!participant) return;
      if (participant) {
        if (kind == "audio") {
          participant.micOn = newState;
        } else if (kind == "video") {
          participant.webcamOn = newState;
        }
        participant.updateParticipantMediaState(kind, newState);
      }
    }
  }, {
    key: "handleParticipantPausedBySubManager",
    value: function handleParticipantPausedBySubManager(data) {
      var participant = this.participants.get(data.peerId);
      if (!participant) return;
      if (participant) {
        participant.handleParticipantPause(data);
      }
    }
  }, {
    key: "handleParticipantResumeBySubManager",
    value: function handleParticipantResumeBySubManager(data) {
      var participant = this.participants.get(data.peerId);
      if (!participant) return;
      if (participant) {
        participant.handleParticipantResume(data);
      }
    }
  }, {
    key: "handleSpeakerChange",
    value: function handleSpeakerChange(_ref17) {
      var peerId = _ref17.peerId;
      if (this.activeSpeakerId !== peerId) {
        this.activeSpeakerId = peerId;
        this.eventEmitter.emit(EV_SPEAKER_CHANGED, peerId);
        if (peerId && peerId !== this.localParticipant.id && this.activePresenterId !== this.mainParticipantId && peerId !== this.mainParticipantId) {
          this.updateMainParticipant(peerId);
        }
      }
    }
  }, {
    key: "handleNewChatMessage",
    value: function handleNewChatMessage(_ref18) {
      var payload = _ref18.payload,
        from = _ref18.from,
        reliability = _ref18.reliability,
        timestamp = _ref18.timestamp;
      var message = {
        from: from,
        payload: payload,
        timestamp: timestamp,
        reliability: reliability
      };
      this.messages.push(message);
      this.eventEmitter.emit(meeting_EV_DATA, message);
    }
  }, {
    key: "updateMainParticipant",
    value: function updateMainParticipant(participantId) {
      this.mainParticipantId = participantId;
      var participant = null;
      if (participantId === this.localParticipant.id) {
        participant = this.localParticipant;
      } else {
        participant = this.participants.get(this.mainParticipantId);
      }
      this.eventEmitter.emit(EV_MAIN_PARTICIPANT_CHANGED, participant);
    }
  }, {
    key: "handleEntryRequested",
    value: function handleEntryRequested(_ref19) {
      var _this2 = this;
      var id = _ref19.id,
        name = _ref19.name;
      this.eventEmitter.emit(EV_ENTRY_REQUESTED, {
        participantId: id,
        name: name,
        allow: function allow() {
          _this2.roomClient.respondEntry(id, "allowed");
        },
        deny: function deny() {
          _this2.roomClient.respondEntry(id, "denied");
        }
      });
    }
  }, {
    key: "handleEntryResponded",
    value: function handleEntryResponded(_ref20) {
      var id = _ref20.id,
        decision = _ref20.decision;
      this.eventEmitter.emit(EV_ENTRY_RESPONDED, id, decision);

      // if (id == this.localParticipant.id) {
      //   this.eventEmitter.emit(EV_MEETING_JOINED);
      // }
    }
  }, {
    key: "handleMeetingJoined",
    value: function handleMeetingJoined(_ref21) {
      var peers = _ref21.peers,
        poll = _ref21.poll,
        messages = _ref21.messages,
        baseUrl = _ref21.baseUrl,
        switchRoomId = _ref21.switchRoomId;
      if (typeof switchRoomId === "string") {
        this.id = switchRoomId;
      }
      this.baseUrl = baseUrl;
      if (messages.length > 0) this.messages = messages;
      this.eventEmitter.emit(EV_MEETING_JOINED, {
        switchRoomId: switchRoomId || null,
        peers: peers,
        poll: poll,
        messages: messages
      });
    }
  }, {
    key: "handleMeetingLeft",
    value: function handleMeetingLeft(d) {
      this.eventEmitter.emit(EV_MEETING_LEFT, d);
    }
  }, {
    key: "handleRecordingStateChanged",
    value: function handleRecordingStateChanged(d) {
      this.recordingState = d.status;
      this.eventEmitter.emit(EV_RECORDING_STATE_CHANGED, d);
    }
  }, {
    key: "handleLivestreamStateChanged",
    value: function handleLivestreamStateChanged(d) {
      this.livestreamState = d.status;
      this.eventEmitter.emit(EV_LIVESTREAM_STATE_CHANGED, d);
    }
  }, {
    key: "handleHlsStateChanged",
    value: function handleHlsStateChanged(d) {
      this.hlsState = d.status;
      if (d.status == "HLS_PLAYABLE") {
        this.hlsUrls = {
          downstreamUrl: d.downstreamUrl,
          playbackHlsUrl: d.playbackHlsUrl,
          livestreamUrl: d.livestreamUrl
        };
      } else if (d.status == "HLS_STOPPED") {
        this.hlsUrls = {
          downstreamUrl: null,
          playbackHlsUrl: null,
          livestreamUrl: null
        };
      }
      this.eventEmitter.emit(EV_HLS_STATE_CHANGED, d);
    }
  }, {
    key: "handleTranscriptionStateChanged",
    value: function handleTranscriptionStateChanged(d) {
      this.transcriptionState = d.status;
      this.eventEmitter.emit(EV_TRANSCRIPTION_STATE_CHANGED, d);
    }
  }, {
    key: "handleTranscriptionText",
    value: function handleTranscriptionText(d) {
      this.eventEmitter.emit(EV_TRANSCRIPTION_TEXT, d);
    }
  }, {
    key: "handleRecordingStarted",
    value: function handleRecordingStarted() {
      this.eventEmitter.emit(EV_RECORDING_STARTED);
    }
  }, {
    key: "handleRecordingStopped",
    value: function handleRecordingStopped() {
      this.eventEmitter.emit(EV_RECORDING_STOPPED);
    }
  }, {
    key: "handleLivestreamStarted",
    value: function handleLivestreamStarted() {
      this.eventEmitter.emit(EV_LIVESTREAM_STARTED);
    }
  }, {
    key: "handleLivestreamStopped",
    value: function handleLivestreamStopped() {
      this.eventEmitter.emit(EV_LIVESTREAM_STOPPED);
    }
  }, {
    key: "handleHlsStarted",
    value: function handleHlsStarted(d) {
      this.eventEmitter.emit(EV_HLS_STARTED, d);
    }
  }, {
    key: "handleHlsStopped",
    value: function handleHlsStopped() {
      this.eventEmitter.emit(EV_HLS_STOPPED);
    }
  }, {
    key: "handleWhiteboardStarted",
    value: function handleWhiteboardStarted(data) {
      this.eventEmitter.emit(EV_WHITEBOARD_STARTED, data);
    }
  }, {
    key: "handleWhiteboardStopped",
    value: function handleWhiteboardStopped(_ref22) {
      _objectDestructuringEmpty(_ref22);
      this.eventEmitter.emit(EV_WHITEBOARD_STOPPED);
    }
  }, {
    key: "handleAddCharacter",
    value: function handleAddCharacter(config) {
      var _this$characters$get;
      var id = config.id;
      var character = (_this$characters$get = this.characters.get(id)) !== null && _this$characters$get !== void 0 ? _this$characters$get : new Character(meeting_objectSpread(meeting_objectSpread({}, config), {}, {
        state: CharacterState.CHARACTER_LISTENING,
        roomClient: this.roomClient
      }));
      this.characters.set(id, character);
      this.eventEmitter.emit(meeting_EV_CHARACTER_JOINED, character);
      character.eventEmitter.emit(meeting_EV_CHARACTER_JOINED);
    }
  }, {
    key: "handleInitCharacter",
    value: function handleInitCharacter(character) {
      this.characters.set(character.id, character);
    }
  }, {
    key: "handleRemoveCharacter",
    value: function handleRemoveCharacter(config) {
      var id = config.id;
      if (this.characters.has(id)) {
        var character = this.characters.get(id);
        this.eventEmitter.emit(meeting_EV_CHARACTER_LEFT, character);
        character.eventEmitter.emit(meeting_EV_CHARACTER_LEFT);
        this.characters["delete"](id);
      }
    }
  }, {
    key: "handleCharacterStateChanged",
    value: function handleCharacterStateChanged(config) {
      var id = config.id;
      if (this.characters.has(id)) {
        var character = this.characters.get(id);
        character.handleCharacterStateChanged(config);
      }
    }
  }, {
    key: "handleCharacterMessage",
    value: function handleCharacterMessage(config) {
      var id = config.id;
      if (this.characters.has(id)) {
        var character = this.characters.get(id);
        character.handleCharacterMessage(config);
      }
    }
  }, {
    key: "handleUserMessage",
    value: function handleUserMessage(config) {
      var id = config.id;
      if (this.characters.has(id)) {
        var character = this.characters.get(id);
        character.handleUserMessage(config);
      }
    }
  }, {
    key: "handleOnCharacterData",
    value: function handleOnCharacterData(config) {
      var id = config.id;
      if (this.characters.has(id)) {
        var character = this.characters.get(id);
        character.handleCharacterData(config);
      }
    }
  }, {
    key: "handleOnCharacterError",
    value: function handleOnCharacterError(config) {
      var id = config.id;
      if (this.characters.has(id)) {
        var character = this.characters.get(id);
        character.handleCharacterError(config);
      }
    }
  }, {
    key: "handleOnRemoveCurrentMeetingParticipant",
    value: function handleOnRemoveCurrentMeetingParticipant() {
      var _this3 = this;
      (0,toConsumableArray/* default */.A)(this.participants.keys()).forEach(function (peerId) {
        if (peerId !== _this3.localParticipant.id) {
          _this3.handlePeerRemove({
            peerId: peerId
          });
        }
      });
    }
  }, {
    key: "handleVideoStateChanged",
    value: function handleVideoStateChanged(data) {
      this.eventEmitter.emit(EV_VIDEO_STATE_CHANGED, data);
    }
  }, {
    key: "handleVideoSeeked",
    value: function handleVideoSeeked(_ref23) {
      var currentTime = _ref23.currentTime;
      this.eventEmitter.emit(EV_VIDEO_SEEKED, {
        currentTime: currentTime
      });
    }
  }, {
    key: "handlePinStateChanged",
    value: function handlePinStateChanged(_ref24) {
      var peerId = _ref24.peerId,
        state = _ref24.state,
        pinnedBy = _ref24.pinnedBy;
      //peerId to participantId for client side better understanding
      this.eventEmitter.emit(EV_PIN_STATE_CHANGED, {
        participantId: peerId,
        state: state,
        pinnedBy: pinnedBy
      });
    }
  }, {
    key: "handleMeetingStateChanged",
    value: function handleMeetingStateChanged(_ref25) {
      var state = _ref25.state;
      this.eventEmitter.emit(EV_MEETING_STATE_CHANGE, {
        state: state
      });
    }
  }, {
    key: "handleQualityChanged",
    value: function handleQualityChanged(_ref26) {
      var type = _ref26.type,
        state = _ref26.state,
        timestamp = _ref26.timestamp;
      this.eventEmitter.emit(EV_QUALITY_LIMITATION, {
        type: type,
        state: state,
        timestamp: timestamp
      });
    }
  }, {
    key: "handleConsumersPaused",
    value: function handleConsumersPaused(_ref27) {
      var kind = _ref27.kind;
      this.eventEmitter.emit(EV_ALL_STREAMS_PAUSED, {
        kind: kind
      });
    }
  }, {
    key: "handleConsumersResumed",
    value: function handleConsumersResumed(_ref28) {
      var kind = _ref28.kind;
      this.eventEmitter.emit(EV_ALL_STREAMS_RESUMED, {
        kind: kind
      });
    }
  }, {
    key: "handleVideoQualityChanged",
    value: function handleVideoQualityChanged(_ref29) {
      var peerId = _ref29.peerId,
        prevQuality = _ref29.prevQuality,
        currentQuality = _ref29.currentQuality;
      var participant = this.participants.get(peerId) || this.characters.get(peerId);
      if (!participant) return;
      if (participant) {
        participant.videoQualityChanged(prevQuality, currentQuality);
      }
    }
  }, {
    key: "handleMicRequested",
    value: function handleMicRequested(_ref30) {
      var _this4 = this;
      var peerId = _ref30.peerId;
      this.eventEmitter.emit(EV_MIC_REQUESTED, {
        participantId: peerId,
        accept: function accept() {
          return _this4.unmuteMic();
        },
        reject: function reject() {}
      });
    }
  }, {
    key: "handleWebcamRequested",
    value: function handleWebcamRequested(_ref31) {
      var _this5 = this;
      var peerId = _ref31.peerId;
      this.eventEmitter.emit(EV_WEBCAM_REQUESTED, {
        participantId: peerId,
        accept: function accept() {
          return _this5.enableWebcam();
        },
        reject: function reject() {}
      });
    }
  }, {
    key: "handleConnectionParticipantJoin",
    value: function handleConnectionParticipantJoin(_ref32) {
      var roomId = _ref32.roomId,
        peer = _ref32.peer;
      var connection = this.connections.get(roomId);
      if (connection == null) return;
      connection.meeting.participantJoin(peer);
    }
  }, {
    key: "handleConnectionParticipantLeft",
    value: function handleConnectionParticipantLeft(_ref33) {
      var roomId = _ref33.roomId,
        peerId = _ref33.peerId;
      var connection = this.connections.get(roomId);
      if (connection == null) return;
      connection.meeting.participantLeft(peerId);
    }
  }, {
    key: "handleConnectionOpen",
    value: function handleConnectionOpen(_ref34) {
      var peers = _ref34.peers,
        roomId = _ref34.roomId,
        payload = _ref34.payload;
      var connection = new Connection({
        roomId: roomId,
        peers: peers,
        payload: payload
      });

      // Set Connection Map
      this.connections.set(connection.id, connection);

      // Trigger Event
      this.eventEmitter.emit(EV_CONNECTION_OPEN, connection);
    }
  }, {
    key: "handleConnectionClose",
    value: function handleConnectionClose(_ref35) {
      var roomId = _ref35.roomId;
      var connection = this.connections.get(roomId);
      if (connection == null) return;
      this.connections["delete"](roomId);
      this.eventEmitter.emit(EV_CONNECTION_CLOSE, roomId);
    }
  }, {
    key: "handleMediaRelayError",
    value: function handleMediaRelayError(_ref36) {
      var meetingId = _ref36.meetingId,
        error = _ref36.error;
      this.eventEmitter.emit(EV_MEDIA_RELAY_ERROR, {
        meetingId: meetingId,
        error: error
      });
    }
  }, {
    key: "handleMediaRelayRequest",
    value: function handleMediaRelayRequest(_ref37) {
      var _this6 = this;
      var peerId = _ref37.peerId,
        meetingId = _ref37.meetingId,
        displayName = _ref37.displayName;
      this.eventEmitter.emit(EV_MEDIA_RELAY_REQUEST_RECEIVED, {
        participantId: peerId,
        meetingId: meetingId,
        displayName: displayName,
        accept: function accept() {
          return _this6.roomClient.handleRelayRequestResponse({
            decision: "allowed",
            meetingId: meetingId,
            peerId: peerId
          });
        },
        reject: function reject() {
          return _this6.roomClient.handleRelayRequestResponse({
            decision: "denied",
            meetingId: meetingId,
            peerId: peerId
          });
        }
      });
    }
  }, {
    key: "handleMediaRelayRequestResponse",
    value: function handleMediaRelayRequestResponse(_ref38) {
      var decision = _ref38.decision,
        decidedBy = _ref38.decidedBy,
        meetingId = _ref38.meetingId;
      this.eventEmitter.emit(EV_MEDIA_RELAY_REQUEST_RESPONSE, {
        decision: decision,
        decidedBy: decidedBy,
        meetingId: meetingId
      });
    }
  }, {
    key: "handleMediaRelayStart",
    value: function handleMediaRelayStart(_ref39) {
      var meetingId = _ref39.meetingId;
      this.eventEmitter.emit(EV_MEDIA_RELAY_STARTED, {
        meetingId: meetingId
      });
    }
  }, {
    key: "handleMediaRelayStop",
    value: function handleMediaRelayStop(_ref40) {
      var meetingId = _ref40.meetingId,
        reason = _ref40.reason;
      this.eventEmitter.emit(EV_MEDIA_RELAY_STOPPED, {
        meetingId: meetingId,
        reason: reason
      });
    }
  }, {
    key: "requestMediaRelay",
    value: function () {
      var _requestMediaRelay = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee12(_ref41) {
        var destinationMeetingId, token, kinds;
        return regenerator_default().wrap(function (_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              destinationMeetingId = _ref41.destinationMeetingId, token = _ref41.token, kinds = _ref41.kinds;
              if (destinationMeetingId) {
                _context12.next = 1;
                break;
              }
              throw new Error("Parameter destinationMeetingId is required when calling requestMediaRelay.");
            case 1:
              _context12.next = 2;
              return this.roomClient.requestMediaRelay(destinationMeetingId, token, kinds);
            case 2:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function requestMediaRelay(_x13) {
        return _requestMediaRelay.apply(this, arguments);
      }
      return requestMediaRelay;
    }()
  }, {
    key: "stopMediaRelay",
    value: function () {
      var _stopMediaRelay = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee13(destinationMeetingId) {
        return regenerator_default().wrap(function (_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              if (destinationMeetingId) {
                _context13.next = 1;
                break;
              }
              throw new Error("Parameter destinationMeetingId is required when calling stopMediaRelay.");
            case 1:
              _context13.next = 2;
              return this.roomClient.stopMediaRelay(destinationMeetingId);
            case 2:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function stopMediaRelay(_x14) {
        return _stopMediaRelay.apply(this, arguments);
      }
      return stopMediaRelay;
    }() // async enableRelayMedia(meetingId, kind) {
    //   await this.roomClient.enableRelayMedia(meetingId, kind);
    // }
    // async disableRelayMedia(meetingId, kind) {
    //   await this.roomClient.disableRelayMedia(meetingId, kind);
    // }
  }, {
    key: "enableAdaptiveSubscription",
    value: function () {
      var _enableAdaptiveSubscription = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee14() {
        return regenerator_default().wrap(function (_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 1;
              return this.roomClient.enableAdaptiveSubscription();
            case 1:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function enableAdaptiveSubscription() {
        return _enableAdaptiveSubscription.apply(this, arguments);
      }
      return enableAdaptiveSubscription;
    }()
  }, {
    key: "disableAdaptiveSubscription",
    value: function () {
      var _disableAdaptiveSubscription = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee15() {
        return regenerator_default().wrap(function (_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 1;
              return this.roomClient.disableAdaptiveSubscription();
            case 1:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function disableAdaptiveSubscription() {
        return _disableAdaptiveSubscription.apply(this, arguments);
      }
      return disableAdaptiveSubscription;
    }()
  }, {
    key: "enableE2EE",
    value: function () {
      var _enableE2EE = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee16() {
        return regenerator_default().wrap(function (_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.next = 1;
              return this.roomClient.toggleE2EEEnabled(true);
            case 1:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function enableE2EE() {
        return _enableE2EE.apply(this, arguments);
      }
      return enableE2EE;
    }()
  }, {
    key: "disableE2EE",
    value: function () {
      var _disableE2EE = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee17() {
        return regenerator_default().wrap(function (_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 1;
              return this.roomClient.toggleE2EEEnabled(false);
            case 1:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function disableE2EE() {
        return _disableE2EE.apply(this, arguments);
      }
      return disableE2EE;
    }()
  }, {
    key: "handleSwitchMeeting",
    value: function handleSwitchMeeting(d) {
      var roomId = d.roomId,
        token = d.token,
        payload = d.payload,
        peerId = d.peerId,
        connectionPeerId = d.connectionPeerId,
        connectionRoomId = d.connectionRoomId;
      var data = peerId ? {
        meetingId: roomId,
        payload: payload,
        token: token,
        participantId: peerId
      } : {
        meetingId: roomId,
        payload: payload,
        token: token,
        connectionParticipantId: connectionPeerId,
        connectionMeetingId: connectionRoomId
      };
      this.eventEmitter.emit(EV_SWITCH_MEETING, data);
    }
  }, {
    key: "handleConnectionChatMessage",
    value: function handleConnectionChatMessage(_ref42) {
      var roomId = _ref42.roomId,
        peerId = _ref42.peerId,
        message = _ref42.message;
      var connection = this.connections.get(roomId);
      if (connection == null) return;
      connection.meeting.sendChatMessageEvent({
        participantId: peerId,
        message: message
      });
    }
  }, {
    key: "handleE2EEStateChange",
    value: function handleE2EEStateChange(data) {
      var peerId = data.peerId;
      var participant = this.localParticipant.id == peerId ? this.localParticipant : this.participants.get(peerId) || this.characters.get(peerId);
      if (!participant) return;
      if (participant) {
        participant.handleE2EEStateChange(data);
      }
    }

    // OPEN CONNECTION FUNCTION
    /**
     *
     * @param {{meetingId: string, payload: string}} options
     */
  }, {
    key: "connectTo",
    value: function () {
      var _connectTo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee18(_ref43) {
        var meetingId, payload;
        return regenerator_default().wrap(function (_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              meetingId = _ref43.meetingId, payload = _ref43.payload;
              _context18.next = 1;
              return this.roomClient.openConnection({
                roomId: meetingId,
                payload: payload
              });
            case 1:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function connectTo(_x15) {
        return _connectTo.apply(this, arguments);
      }
      return connectTo;
    }()
  }, {
    key: "switchTo",
    value: function switchTo(_ref44) {
      var meetingId = _ref44.meetingId,
        token = _ref44.token;
      // Validate meetingId exists and is a non-empty string
      if (!meetingId || typeof meetingId !== "string" || meetingId.trim() === "") {
        throw new Error("Invalid meetingId: must be a non-empty string");
      }
      this.roomClient.switchTo({
        meetingId: meetingId,
        token: token,
        participantId: this.localParticipant.id
      });
    }
  }, {
    key: "selectedCameraDevice",
    get:
    /**
     *
     * @returns {InputDeviceInfo}
     */
    function get() {
      var _this$roomClient$_web;
      return (_this$roomClient$_web = this.roomClient._webcam) === null || _this$roomClient$_web === void 0 ? void 0 : _this$roomClient$_web.device;
    }

    /**
     *
     * @returns {InputDeviceInfo}
     */
  }, {
    key: "selectedMicrophoneDevice",
    get: function get() {
      var _this$roomClient$_mic;
      return (_this$roomClient$_mic = this.roomClient._mic) === null || _this$roomClient$_mic === void 0 ? void 0 : _this$roomClient$_mic.device;
    }

    /**
     * Add event listener
     * @param { EV_PARTICIPANT_JOINED | EV_PARTICIPANT_LEFT | EV_SPEAKER_CHANGED | EV_PRESENTER_CHANGED | EV_MAIN_PARTICIPANT_CHANGED | EV_ENTRY_REQUESTED | EV_ENTRY_RESPONDED |       EV_RECORDING_STARTED | EV_RECORDING_STOPPED |      EV_LIVESTREAM_STARTED | EV_LIVESTREAM_STOPPED |       EV_HLS_STARTED | EV_HLS_STOPPED |       EV_STREAM_ENABLED | EV_STREAM_DISABLED |       EV_WHITEBOARD_STARTED | EV_WHITEBOARD_STOPPED |       EV_MEETING_JOINED | EV_MEETING_LEFT |      EV_VIDEO_STATE_CHANGED | EV_VIDEO_SEEKED |       EV_MIC_REQUESTED | EV_WEBCAM_REQUESTED |      EV_PIN_STATE_CHANGED | EV_CONNECTION_OPEN | EV_CONNECTION_CLOSE |    EV_SWITCH_MEETING | EV_ALL_STREAMS_PAUSED | EV_ALL_STREAMS_RESUMED | EV_DATA } eventType
     * @param {Function} listener Callback function
     */
  }, {
    key: "on",
    value: function on(eventType, listener) {
      switch (eventType) {
        case meeting_EV_PARTICIPANT_JOINED:
        case meeting_EV_PARTICIPANT_LEFT:
        case EV_SPEAKER_CHANGED:
        case EV_PRESENTER_CHANGED:
        case EV_MAIN_PARTICIPANT_CHANGED:
        case meeting_EV_DATA:
        case EV_ENTRY_REQUESTED:
        case EV_ENTRY_RESPONDED:
        case EV_RECORDING_STATE_CHANGED:
        case EV_RECORDING_STARTED:
        case EV_RECORDING_STOPPED:
        case EV_LIVESTREAM_STATE_CHANGED:
        case EV_LIVESTREAM_STARTED:
        case EV_LIVESTREAM_STOPPED:
        case EV_HLS_STARTED:
        case EV_HLS_STOPPED:
        case EV_HLS_STATE_CHANGED:
        case EV_TRANSCRIPTION_STATE_CHANGED:
        case EV_TRANSCRIPTION_TEXT:
        case meeting_EV_STREAM_ENABLED:
        case meeting_EV_STREAM_DISABLED:
        case EV_WHITEBOARD_STARTED:
        case EV_WHITEBOARD_STOPPED:
        case meeting_EV_CHARACTER_JOINED:
        case meeting_EV_CHARACTER_LEFT:
        case EV_MEETING_JOINED:
        case EV_MEETING_LEFT:
        case EV_VIDEO_STATE_CHANGED:
        case EV_VIDEO_SEEKED:
        case EV_MIC_REQUESTED:
        case EV_WEBCAM_REQUESTED:
        case EV_PIN_STATE_CHANGED:
        case EV_CONNECTION_OPEN:
        case EV_CONNECTION_CLOSE:
        case EV_SWITCH_MEETING:
        case EV_MEETING_STATE_CHANGE:
        case EV_PARTICIPANT_MODE_CHANGED:
        case EV_ALL_STREAMS_PAUSED:
        case EV_ALL_STREAMS_RESUMED:
        case EV_MEDIA_RELAY_STARTED:
        case EV_MEDIA_RELAY_STOPPED:
        case EV_MEDIA_RELAY_ERROR:
        case EV_MEDIA_RELAY_REQUEST_RECEIVED:
        case EV_MEDIA_RELAY_REQUEST_RESPONSE:
        case EV_ERROR:
        case EV_QUALITY_LIMITATION:
          this.eventEmitter.on(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type " + eventType);
      }
    }

    /**
     * Remove event listener
     * @param { EV_PARTICIPANT_JOINED | EV_PARTICIPANT_LEFT | EV_SPEAKER_CHANGED | EV_PRESENTER_CHANGED | EV_MAIN_PARTICIPANT_CHANGED | EV_ENTRY_REQUESTED | EV_ENTRY_RESPONDED |       EV_RECORDING_STARTED | EV_RECORDING_STOPPED |      EV_LIVESTREAM_STARTED | EV_LIVESTREAM_STOPPED |       EV_HLS_STARTED | EV_HLS_STOPPED |       EV_STREAM_ENABLED | EV_STREAM_DISABLED |       EV_WHITEBOARD_STARTED | EV_WHITEBOARD_STOPPED |       EV_MEETING_JOINED | EV_MEETING_LEFT |      EV_VIDEO_STATE_CHANGED | EV_VIDEO_SEEKED |       EV_MIC_REQUESTED | EV_WEBCAM_REQUESTED |      EV_PIN_STATE_CHANGED | EV_CONNECTION_OPEN | EV_CONNECTION_CLOSE |    EV_SWITCH_MEETING | EV_ALL_STREAMS_PAUSED | EV_ALL_STREAMS_RESUMED | EV_DATA } eventType
     * @param {Function} listener Callback function
     */
  }, {
    key: "off",
    value: function off(eventType, listener) {
      switch (eventType) {
        case meeting_EV_PARTICIPANT_JOINED:
        case meeting_EV_PARTICIPANT_LEFT:
        case EV_SPEAKER_CHANGED:
        case EV_PRESENTER_CHANGED:
        case EV_MAIN_PARTICIPANT_CHANGED:
        case meeting_EV_DATA:
        case EV_ENTRY_REQUESTED:
        case EV_ENTRY_RESPONDED:
        case EV_RECORDING_STATE_CHANGED:
        case EV_RECORDING_STARTED:
        case EV_RECORDING_STOPPED:
        case EV_LIVESTREAM_STATE_CHANGED:
        case EV_LIVESTREAM_STARTED:
        case EV_LIVESTREAM_STOPPED:
        case EV_HLS_STATE_CHANGED:
        case EV_HLS_STARTED:
        case EV_HLS_STOPPED:
        case EV_TRANSCRIPTION_STATE_CHANGED:
        case EV_TRANSCRIPTION_TEXT:
        case meeting_EV_STREAM_ENABLED:
        case meeting_EV_STREAM_DISABLED:
        case EV_WHITEBOARD_STARTED:
        case EV_WHITEBOARD_STOPPED:
        case meeting_EV_CHARACTER_JOINED:
        case meeting_EV_CHARACTER_LEFT:
        case EV_MEETING_JOINED:
        case EV_MEETING_LEFT:
        case EV_VIDEO_STATE_CHANGED:
        case EV_VIDEO_SEEKED:
        case EV_MIC_REQUESTED:
        case EV_WEBCAM_REQUESTED:
        case EV_PIN_STATE_CHANGED:
        case EV_CONNECTION_OPEN:
        case EV_CONNECTION_CLOSE:
        case EV_SWITCH_MEETING:
        case EV_MEETING_STATE_CHANGE:
        case EV_ERROR:
        case EV_MEDIA_RELAY_STARTED:
        case EV_MEDIA_RELAY_STOPPED:
        case EV_MEDIA_RELAY_ERROR:
        case EV_MEDIA_RELAY_REQUEST_RECEIVED:
        case EV_MEDIA_RELAY_REQUEST_RESPONSE:
        case EV_PARTICIPANT_MODE_CHANGED:
        case EV_ALL_STREAMS_PAUSED:
        case EV_ALL_STREAMS_RESUMED:
        case EV_QUALITY_LIMITATION:
          this.eventEmitter.off(eventType, listener);
          break;
        default:
          throw new Error("Invalid event type.");
          // removed by dead control flow

      }
    }
  }]);
}();
function _handlePubsubMessage(data) {
  var topic = data.topic,
    message = data.message,
    senderId = data.senderId,
    timestamp = data.timestamp,
    senderName = data.senderName,
    id = data.id,
    payload = data.payload;
  if (!topic || !message) return;
  meeting_classPrivateFieldGet(_topicEventEmitter, this).emit(topic, {
    message: message,
    senderId: senderId,
    timestamp: timestamp,
    topic: topic,
    senderName: senderName,
    id: id,
    payload: payload
  });
}
function _handlePeerModeChanged(_ref45) {
  var peerId = _ref45.peerId,
    mode = _ref45.mode;
  if (peerId === this.localParticipant.id) {
    this.localParticipant.mode = mode;
  } else {
    this.participants.get(peerId).mode = mode;
  }
  // update presenter
  if (this.activePresenterId === this.localParticipant.id && !(0,modes/* isSendRecvMode */.kR)(mode)) {
    this.activePresenterId = null;
    this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
  }
  this.eventEmitter.emit(EV_PARTICIPANT_MODE_CHANGED, {
    participantId: peerId,
    mode: mode
  });
}

// EXTERNAL MODULE: ./src/constants/errors.js
var errors = __webpack_require__(7080);
;// ./src/constants/recordingEvents.js
var recordingEvents = {
  RECORDING_STARTING: "RECORDING_STARTING",
  RECORDING_STARTED: "RECORDING_STARTED",
  RECORDING_STOPPING: "RECORDING_STOPPING",
  RECORDING_STOPPED: "RECORDING_STOPPED"
};
;// ./src/constants/livestreamEvents.js
var livestreamEvents = {
  LIVESTREAM_STARTING: "LIVESTREAM_STARTING",
  LIVESTREAM_STARTED: "LIVESTREAM_STARTED",
  LIVESTREAM_STOPPING: "LIVESTREAM_STOPPING",
  LIVESTREAM_STOPPED: "LIVESTREAM_STOPPED"
};
// EXTERNAL MODULE: ./src/constants/hlsEvents.js
var hlsEvents = __webpack_require__(5071);
;// ./src/constants/transcriptionEvents.js
var transcriptionEvents = {
  TRANSCRIPTION_STARTING: "TRANSCRIPTION_STARTING",
  TRANSCRIPTION_STARTED: "TRANSCRIPTION_STARTED",
  TRANSCRIPTION_STOPPING: "TRANSCRIPTION_STOPPING",
  TRANSCRIPTION_STOPPED: "TRANSCRIPTION_STOPPED"
};
// EXTERNAL MODULE: ./src/lib/media.js
var media = __webpack_require__(4973);
// EXTERNAL MODULE: ./src/config.js
var config = __webpack_require__(9027);
;// ./src/classes/DeviceInfo.js





function DeviceInfo_callSuper(t, o, e) { return o = (0,getPrototypeOf/* default */.A)(o), (0,possibleConstructorReturn/* default */.A)(t, DeviceInfo_isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0,getPrototypeOf/* default */.A)(t).constructor) : o.apply(t, e)); }
function DeviceInfo_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (DeviceInfo_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var MediaDeviceInfo = /*#__PURE__*/(0,createClass/* default */.A)(function MediaDeviceInfo(deviceId, groupId, kind, label) {
  (0,classCallCheck/* default */.A)(this, MediaDeviceInfo);
  /**
   * @type {string}
   */
  this.deviceId = deviceId;
  /**
   * @type {string}
   */
  this.groupId = groupId;
  /**
   * @type {string}
   */
  this.kind = kind;
  /**
   * @type {string}
   */
  this.label = label;
});
var DeviceInfo = /*#__PURE__*/function (_MediaDeviceInfo) {
  function DeviceInfo(deviceId, groupId, kind, label) {
    (0,classCallCheck/* default */.A)(this, DeviceInfo);
    return DeviceInfo_callSuper(this, DeviceInfo, [deviceId, groupId, kind, label]);
  }
  (0,inherits/* default */.A)(DeviceInfo, _MediaDeviceInfo);
  return (0,createClass/* default */.A)(DeviceInfo);
}(MediaDeviceInfo);
var CameraDeviceInfo = /*#__PURE__*/function (_DeviceInfo) {
  function CameraDeviceInfo(deviceId, groupId, kind, label) {
    (0,classCallCheck/* default */.A)(this, CameraDeviceInfo);
    return DeviceInfo_callSuper(this, CameraDeviceInfo, [deviceId, groupId, kind, label]);
  }
  (0,inherits/* default */.A)(CameraDeviceInfo, _DeviceInfo);
  return (0,createClass/* default */.A)(CameraDeviceInfo);
}(DeviceInfo);
var MicrophoneDeviceInfo = /*#__PURE__*/function (_DeviceInfo2) {
  function MicrophoneDeviceInfo(deviceId, groupId, kind, label) {
    (0,classCallCheck/* default */.A)(this, MicrophoneDeviceInfo);
    return DeviceInfo_callSuper(this, MicrophoneDeviceInfo, [deviceId, groupId, kind, label]);
  }
  (0,inherits/* default */.A)(MicrophoneDeviceInfo, _DeviceInfo2);
  return (0,createClass/* default */.A)(MicrophoneDeviceInfo);
}(DeviceInfo);
var PlaybackDeviceInfo = /*#__PURE__*/function (_DeviceInfo3) {
  function PlaybackDeviceInfo(deviceId, groupId, kind, label) {
    (0,classCallCheck/* default */.A)(this, PlaybackDeviceInfo);
    return DeviceInfo_callSuper(this, PlaybackDeviceInfo, [deviceId, groupId, kind, label]);
  }
  (0,inherits/* default */.A)(PlaybackDeviceInfo, _DeviceInfo3);
  return (0,createClass/* default */.A)(PlaybackDeviceInfo);
}(DeviceInfo);

;// ./src/classes/Permissions.js
var Permission = {
  AUDIO: "audio",
  VIDEO: "video",
  AUDIO_AND_VIDEO: "audio_video"
};
// EXTERNAL MODULE: ./node_modules/isomorphic-fetch/fetch-npm-browserify.js
var fetch_npm_browserify = __webpack_require__(328);
// EXTERNAL MODULE: ./node_modules/lodash.memoize/index.js
var lodash_memoize = __webpack_require__(7654);
;// ./node_modules/d3-array/src/ascending.js
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

;// ./node_modules/d3-array/src/descending.js
function descending(a, b) {
  return a == null || b == null ? NaN
    : b < a ? -1
    : b > a ? 1
    : b >= a ? 0
    : NaN;
}

;// ./node_modules/d3-array/src/bisector.js



function bisector(f) {
  let compare1, compare2, delta;

  // If an accessor is specified, promote it to a comparator. In this case we
  // can test whether the search value is (self-) comparable. We can’t do this
  // for a comparator (except for specific, known comparators) because we can’t
  // tell if the comparator is symmetric, and an asymmetric comparator can’t be
  // used to test whether a single value is comparable.
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }

  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = (lo + hi) >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }

  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function zero() {
  return 0;
}

;// ./node_modules/d3-array/src/number.js
function number(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

;// ./node_modules/d3-array/src/bisect.js




const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = bisector(number).center;
/* harmony default export */ const bisect = (bisectRight);

;// ./node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}

;// ./node_modules/d3-scale/src/threshold.js



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

;// ./node_modules/@cloudflare/speedtest/dist/speedtest.js




function speedtest_arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return speedtest_arrayLikeToArray(r);
}
function speedtest_assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function speedtest_callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, speedtest_isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function speedtest_checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet2(s, a) {
  return s.get(speedtest_assertClassBrand(s, a));
}
function speedtest_classPrivateFieldInitSpec(e, t, a) {
  speedtest_checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _classPrivateFieldSet2(s, a, r) {
  return s.set(speedtest_assertClassBrand(s, a), r), r;
}
function speedtest_classPrivateMethodInitSpec(e, a) {
  speedtest_checkPrivateRedeclaration(e, a), a.add(e);
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
function speedtest_isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (speedtest_isNativeReflectConstruct = function () {
    return !!t;
  })();
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = true,
      o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = true, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function speedtest_ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function speedtest_objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? speedtest_ownKeys(Object(t), true).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : speedtest_ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o,
    r,
    i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function set(e, r, t, o) {
  return set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function (e, r, t, o) {
    var f,
      i = _superPropBase(e, r);
    if (i) {
      if ((f = Object.getOwnPropertyDescriptor(i, r)).set) return f.set.call(o, t), true;
      if (!f.writable) return false;
    }
    if (f = Object.getOwnPropertyDescriptor(o, r)) {
      if (!f.writable) return false;
      f.value = t, Object.defineProperty(o, r, f);
    } else _defineProperty(o, r, t);
    return true;
  }, set(e, r, t, o);
}
function _set(e, r, t, o, f) {
  if (!set(e, r, t, o || e) && f) throw new TypeError("failed to set property");
  return t;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || speedtest_unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););
  return t;
}
function _superPropGet(t, o, e, r) {
  var p = _get(_getPrototypeOf(t.prototype ), o, e);
  return 2 & r && "function" == typeof p ? function (t) {
    return p.apply(e, t);
  } : p;
}
function _superPropSet(t, e, o, r, p, f) {
  return _set(_getPrototypeOf(t.prototype ), e, o, r, p);
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || speedtest_unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (String )(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function speedtest_unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return speedtest_arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? speedtest_arrayLikeToArray(r, a) : void 0;
  }
}

var REL_API_URL = 'https://speed.cloudflare.com';
var defaultConfig = {
  // Engine
  autoStart: true,
  // APIs
  downloadApiUrl: "".concat(REL_API_URL, "/__down"),
  uploadApiUrl: "".concat(REL_API_URL, "/__up"),
  logMeasurementApiUrl: null,
  logAimApiUrl: 'https://aim.cloudflare.com/__log',
  turnServerUri: 'turn.speed.cloudflare.com:50000',
  turnServerCredsApiUrl: "".concat(REL_API_URL, "/turn-creds"),
  turnServerUser: null,
  turnServerPass: null,
  rpkiInvalidHost: 'invalid.rpki.cloudflare.com',
  cfTraceUrl: "".concat(REL_API_URL, "/cdn-cgi/trace"),
  includeCredentials: false,
  // Measurements
  measurements: [{
    type: 'latency',
    numPackets: 1
  },
  // initial ttfb estimation
  {
    type: 'download',
    bytes: 1e5,
    count: 1,
    bypassMinDuration: true
  },
  // initial download estimation
  {
    type: 'latency',
    numPackets: 20
  }, {
    type: 'download',
    bytes: 1e5,
    count: 9
  }, {
    type: 'download',
    bytes: 1e6,
    count: 8
  }, {
    type: 'upload',
    bytes: 1e5,
    count: 8
  }, {
    type: 'packetLoss',
    numPackets: 1e3,
    batchSize: 10,
    batchWaitTime: 10,
    // ms (in between batches)
    responsesWaitTime: 3000 // ms (silent time after last sent msg)
  }, {
    type: 'upload',
    bytes: 1e6,
    count: 6
  }, {
    type: 'download',
    bytes: 1e7,
    count: 6
  }, {
    type: 'upload',
    bytes: 1e7,
    count: 4
  }, {
    type: 'download',
    bytes: 2.5e7,
    count: 4
  }, {
    type: 'upload',
    bytes: 2.5e7,
    count: 4
  }, {
    type: 'download',
    bytes: 1e8,
    count: 3
  }, {
    type: 'upload',
    bytes: 5e7,
    count: 3
  }, {
    type: 'download',
    bytes: 2.5e8,
    count: 2
  }],
  measureDownloadLoadedLatency: true,
  measureUploadLoadedLatency: true,
  loadedLatencyThrottle: 400,
  // ms in between loaded latency requests
  bandwidthFinishRequestDuration: 1000,
  // download/upload duration (ms) to reach for stopping further measurements
  estimatedServerTime: 10,
  // ms to discount from latency calculation (if not present in response headers)

  // Result interpretation
  latencyPercentile: 0.5,
  // Percentile used to calculate latency from a set of measurements
  bandwidthPercentile: 0.9,
  // Percentile used to calculate bandwidth from a set of measurements
  bandwidthMinRequestDuration: 10,
  // minimum duration (ms) to consider a measurement good enough to use in bandwidth calculation
  loadedRequestMinDuration: 250,
  // minimum duration (ms) of a request to consider it to be loading the connection
  loadedLatencyMaxPoints: 20 // number of data points to keep for loaded latency
};

var internalConfig = {
  // AIM
  aimMeasurementScoring: {
    packetLoss: threshold([0.01, 0.05, 0.25, 0.5], [10, 5, 0, -10, -20]),
    latency: threshold([10, 20, 50, 100, 500], [20, 10, 5, 0, -10, -20]),
    loadedLatencyIncrease: threshold([10, 20, 50, 100, 500], [20, 10, 5, 0, -10, -20]),
    jitter: threshold([10, 20, 100, 500], [10, 5, 0, -10, -20]),
    download: threshold([1e6, 10e6, 50e6, 100e6], [0, 5, 10, 20, 30]),
    upload: threshold([1e6, 10e6, 50e6, 100e6], [0, 5, 10, 20, 30])
  },
  aimExperiencesDefs: {
    streaming: {
      input: ['latency', 'packetLoss', 'download', 'loadedLatencyIncrease'],
      pointThresholds: [15, 20, 40, 60]
    },
    gaming: {
      input: ['latency', 'packetLoss', 'loadedLatencyIncrease'],
      pointThresholds: [5, 15, 25, 30]
    },
    rtc: {
      input: ['latency', 'jitter', 'packetLoss', 'loadedLatencyIncrease'],
      pointThresholds: [5, 15, 25, 40]
    }
  }
};

var MAX_RETRIES = 20;
var ESTIMATED_HEADER_FRACTION = 0.005; // ~.5% of packet header / payload size. used when transferSize is not available.

var cfGetServerTime = function cfGetServerTime(r) {
  // extract server-timing from headers: server-timing: cfRequestDuration;dur=15.999794
  var serverTiming = r.headers.get("server-timing");
  if (serverTiming) {
    var re = serverTiming.match(/dur=([0-9.]+)/);
    if (re) return +re[1];
  }
};
var getTtfb = function getTtfb(perf) {
  return perf.responseStart - perf.requestStart;
};
var gePayloadDownload = function gePayloadDownload(perf) {
  return perf.responseEnd - perf.responseStart;
}; // min 1ms

var calcDownloadDuration = function calcDownloadDuration(_ref) {
  var ping = _ref.ping,
    payloadDownloadTime = _ref.payloadDownloadTime;
  return ping + payloadDownloadTime;
}; // request duration excluding server time

var calcUploadDuration = function calcUploadDuration(_ref2) {
  var ttfb = _ref2.ttfb;
  return ttfb;
};
var calcDownloadSpeed = function calcDownloadSpeed(_ref3, numBytes) {
  var duration = _ref3.duration,
    transferSize = _ref3.transferSize;
  // use transferSize if available. if estimating from numBytes, add ~0.5% of headers.
  var bits = 8 * (transferSize || +numBytes * (1 + ESTIMATED_HEADER_FRACTION));
  var secs = duration / 1000;
  return !secs ? undefined : bits / secs;
};
var calcUploadSpeed = function calcUploadSpeed(_ref4, numBytes) {
  var duration = _ref4.duration;
  var bits = 8 * numBytes * (1 + ESTIMATED_HEADER_FRACTION); // take into account estimated packet headers
  var secs = duration / 1000; // subtract estimated server time

  return !secs ? undefined : bits / secs;
};
var genContent = lodash_memoize(function (numBytes) {
  return '0'.repeat(numBytes);
});

//
var _qsParams = /*#__PURE__*/new WeakMap();
var _fetchOptions = /*#__PURE__*/new WeakMap();
var _responseHook = /*#__PURE__*/new WeakMap();
var _onRunningChange = /*#__PURE__*/new WeakMap();
var _onNewMeasurementStarted = /*#__PURE__*/new WeakMap();
var _onMeasurementResult = /*#__PURE__*/new WeakMap();
var _onFinished$1 = /*#__PURE__*/new WeakMap();
var _onConnectionError$1 = /*#__PURE__*/new WeakMap();
var _measurements = /*#__PURE__*/new WeakMap();
var _downloadApi = /*#__PURE__*/new WeakMap();
var _uploadApi = /*#__PURE__*/new WeakMap();
var _running$2 = /*#__PURE__*/new WeakMap();
var _finished$1 = /*#__PURE__*/new WeakMap();
var _results$1 = /*#__PURE__*/new WeakMap();
var _measIdx = /*#__PURE__*/new WeakMap();
var _counter = /*#__PURE__*/new WeakMap();
var _retries = /*#__PURE__*/new WeakMap();
var _minDuration = /*#__PURE__*/new WeakMap();
var _throttleMs = /*#__PURE__*/new WeakMap();
var _estimatedServerTime = /*#__PURE__*/new WeakMap();
var _currentFetchPromise = /*#__PURE__*/new WeakMap();
var _currentNextMsmTimeoutId = /*#__PURE__*/new WeakMap();
var _BandwidthMeasurementEngine_brand = /*#__PURE__*/new WeakSet();
var BandwidthMeasurementEngine = /*#__PURE__*/function () {
  function BandwidthMeasurementEngine(_measurements2) {
    var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      downloadApiUrl = _ref5.downloadApiUrl,
      uploadApiUrl = _ref5.uploadApiUrl,
      _ref5$throttleMs = _ref5.throttleMs,
      throttleMs = _ref5$throttleMs === void 0 ? 0 : _ref5$throttleMs,
      _ref5$estimatedServer = _ref5.estimatedServerTime,
      estimatedServerTime = _ref5$estimatedServer === void 0 ? 0 : _ref5$estimatedServer;
    _classCallCheck(this, BandwidthMeasurementEngine);
    // Internal methods
    speedtest_classPrivateMethodInitSpec(this, _BandwidthMeasurementEngine_brand);
    speedtest_classPrivateFieldInitSpec(this, _qsParams, {});
    speedtest_classPrivateFieldInitSpec(this, _fetchOptions, {});
    _defineProperty(this, "finishRequestDuration", 1000);
    // download/upload duration (ms) to reach for stopping further measurements
    _defineProperty(this, "getServerTime", cfGetServerTime);
    // method to extract server time from response

    speedtest_classPrivateFieldInitSpec(this, _responseHook, function (r) {
      return r;
    });
    speedtest_classPrivateFieldInitSpec(this, _onRunningChange, function () {});
    speedtest_classPrivateFieldInitSpec(this, _onNewMeasurementStarted, function () {});
    speedtest_classPrivateFieldInitSpec(this, _onMeasurementResult, function () {});
    speedtest_classPrivateFieldInitSpec(this, _onFinished$1, function () {});
    speedtest_classPrivateFieldInitSpec(this, _onConnectionError$1, function () {});
    // Internal state
    speedtest_classPrivateFieldInitSpec(this, _measurements, void 0);
    speedtest_classPrivateFieldInitSpec(this, _downloadApi, void 0);
    speedtest_classPrivateFieldInitSpec(this, _uploadApi, void 0);
    speedtest_classPrivateFieldInitSpec(this, _running$2, false);
    speedtest_classPrivateFieldInitSpec(this, _finished$1, {
      down: false,
      up: false
    });
    speedtest_classPrivateFieldInitSpec(this, _results$1, {
      down: {},
      up: {}
    });
    speedtest_classPrivateFieldInitSpec(this, _measIdx, 0);
    speedtest_classPrivateFieldInitSpec(this, _counter, 0);
    speedtest_classPrivateFieldInitSpec(this, _retries, 0);
    speedtest_classPrivateFieldInitSpec(this, _minDuration, -Infinity);
    // of current measurement
    speedtest_classPrivateFieldInitSpec(this, _throttleMs, 0);
    speedtest_classPrivateFieldInitSpec(this, _estimatedServerTime, 0);
    speedtest_classPrivateFieldInitSpec(this, _currentFetchPromise, undefined);
    speedtest_classPrivateFieldInitSpec(this, _currentNextMsmTimeoutId, undefined);
    if (!_measurements2) throw new Error('Missing measurements argument');
    if (!downloadApiUrl) throw new Error('Missing downloadApiUrl argument');
    if (!uploadApiUrl) throw new Error('Missing uploadApiUrl argument');
    _classPrivateFieldSet2(_measurements, this, _measurements2);
    _classPrivateFieldSet2(_downloadApi, this, downloadApiUrl);
    _classPrivateFieldSet2(_uploadApi, this, uploadApiUrl);
    _classPrivateFieldSet2(_throttleMs, this, throttleMs);
    _classPrivateFieldSet2(_estimatedServerTime, this, Math.max(0, estimatedServerTime));
  }

  // Public attributes
  return _createClass(BandwidthMeasurementEngine, [{
    key: "results",
    get: function get() {
      // read access to results
      return _classPrivateFieldGet2(_results$1, this);
    }
  }, {
    key: "qsParams",
    get:
    // additional query string params to include in the requests
    function get() {
      return _classPrivateFieldGet2(_qsParams, this);
    },
    set: function set(v) {
      _classPrivateFieldSet2(_qsParams, this, v);
    }
  }, {
    key: "fetchOptions",
    get:
    // additional options included in the requests
    function get() {
      return _classPrivateFieldGet2(_fetchOptions, this);
    },
    set: function set(v) {
      _classPrivateFieldSet2(_fetchOptions, this, v);
    }
  }, {
    key: "responseHook",
    set:
    // pipe-through of response objects
    function set(f) {
      _classPrivateFieldSet2(_responseHook, this, f);
    }
  }, {
    key: "onRunningChange",
    set:
    // callback invoked when engine starts/stops
    function set(f) {
      _classPrivateFieldSet2(_onRunningChange, this, f);
    }
  }, {
    key: "onNewMeasurementStarted",
    set:
    // callback invoked when a new item in the measurement list is started
    function set(f) {
      _classPrivateFieldSet2(_onNewMeasurementStarted, this, f);
    }
  }, {
    key: "onMeasurementResult",
    set:
    // callback invoked when a new measurement result arrives
    function set(f) {
      _classPrivateFieldSet2(_onMeasurementResult, this, f);
    }
  }, {
    key: "onFinished",
    set:
    // callback invoked when all the measurements are finished
    function set(f) {
      _classPrivateFieldSet2(_onFinished$1, this, f);
    }
  }, {
    key: "onConnectionError",
    set:
    // Invoked when unable to get a response from the API
    function set(f) {
      _classPrivateFieldSet2(_onConnectionError$1, this, f);
    }

    // Public methods
  }, {
    key: "pause",
    value: function pause() {
      clearTimeout(_classPrivateFieldGet2(_currentNextMsmTimeoutId, this));
      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _cancelCurrentMeasurement).call(this);
      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _setRunning$2).call(this, false);
    }
  }, {
    key: "play",
    value: function play() {
      if (!_classPrivateFieldGet2(_running$2, this)) {
        speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _setRunning$2).call(this, true);
        speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _nextMeasurement).call(this);
      }
    }
  }]);
}();
function _setRunning$2(running) {
  var _this = this;
  if (running !== _classPrivateFieldGet2(_running$2, this)) {
    _classPrivateFieldSet2(_running$2, this, running);
    setTimeout(function () {
      return _classPrivateFieldGet2(_onRunningChange, _this).call(_this, _classPrivateFieldGet2(_running$2, _this));
    });
  }
}
function _saveMeasurementResults(measIdx, measTiming) {
  var _this2 = this;
  var _classPrivateFieldGet2$1 = _classPrivateFieldGet2(_measurements, this)[measIdx],
    bytes = _classPrivateFieldGet2$1.bytes,
    dir = _classPrivateFieldGet2$1.dir;
  var results = _classPrivateFieldGet2(_results$1, this);
  var bytesResult = results[dir].hasOwnProperty(bytes) ? results[dir][bytes] : {
    timings: [],
    // count all measurements with same bytes and direction
    numMeasurements: _classPrivateFieldGet2(_measurements, this).filter(function (_ref6) {
      var b = _ref6.bytes,
        d = _ref6.dir;
      return bytes === b && dir === d;
    }).map(function (m) {
      return m.count;
    }).reduce(function (agg, cnt) {
      return agg + cnt;
    }, 0)
  };
  !!measTiming && bytesResult.timings.push(measTiming);
  bytesResult.timings = bytesResult.timings.slice(-bytesResult.numMeasurements);
  results[dir][bytes] = bytesResult;
  if (measTiming) {
    setTimeout(function () {
      _classPrivateFieldGet2(_onMeasurementResult, _this2).call(_this2, speedtest_objectSpread2({
        type: dir,
        bytes: bytes
      }, measTiming), results);
    });
  } else {
    _classPrivateFieldGet2(_onNewMeasurementStarted, this).call(this, _classPrivateFieldGet2(_measurements, this)[measIdx], results);
  }
}
function _nextMeasurement() {
  var _this3 = this;
  var measurements = _classPrivateFieldGet2(_measurements, this);
  var meas = measurements[_classPrivateFieldGet2(_measIdx, this)];
  if (_classPrivateFieldGet2(_counter, this) >= meas.count) {
    // Finished current measurement
    var finished = _classPrivateFieldGet2(_finished$1, this);
    if (_classPrivateFieldGet2(_minDuration, this) > this.finishRequestDuration && !meas.bypassMinDuration) {
      // mark direction as finished
      var _dir = meas.dir;
      _classPrivateFieldGet2(_finished$1, this)[_dir] = true;
      Object.values(_classPrivateFieldGet2(_finished$1, this)).every(function (finished) {
        return finished;
      }) && _classPrivateFieldGet2(_onFinished$1, this).call(this, _classPrivateFieldGet2(_results$1, this));
    }

    // clear settings
    _classPrivateFieldSet2(_counter, this, 0);
    _classPrivateFieldSet2(_minDuration, this, -Infinity);
    performance.clearResourceTimings();
    do {
      _classPrivateFieldSet2(_measIdx, this, _classPrivateFieldGet2(_measIdx, this) + 1); // skip through finished measurements
    } while (_classPrivateFieldGet2(_measIdx, this) < measurements.length && finished[measurements[_classPrivateFieldGet2(_measIdx, this)].dir]);
    if (_classPrivateFieldGet2(_measIdx, this) >= measurements.length) {
      // reached the end: halt further measurements
      _classPrivateFieldSet2(_finished$1, this, {
        down: true,
        up: true
      });
      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _setRunning$2).call(this, false);
      _classPrivateFieldGet2(_onFinished$1, this).call(this, _classPrivateFieldGet2(_results$1, this));
      return;
    }
    meas = measurements[_classPrivateFieldGet2(_measIdx, this)];
  }
  var measIdx = _classPrivateFieldGet2(_measIdx, this);
  if (_classPrivateFieldGet2(_counter, this) === 0) {
    speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _saveMeasurementResults).call(this, measIdx); // register measurement start
  }
  var _meas = meas,
    numBytes = _meas.bytes,
    dir = _meas.dir;
  var isDown = dir === 'down';
  var apiUrl = isDown ? _classPrivateFieldGet2(_downloadApi, this) : _classPrivateFieldGet2(_uploadApi, this);
  var qsParams = Object.assign({}, _classPrivateFieldGet2(_qsParams, this));
  isDown && (qsParams.bytes = "".concat(numBytes));
  var url = "".concat(apiUrl.startsWith('http') || apiUrl.startsWith('//') ? '' : window.location.origin // use abs to match perf timing urls
  ).concat(apiUrl, "?").concat(Object.entries(qsParams).map(function (_ref7) {
    var _ref8 = _slicedToArray(_ref7, 2),
      k = _ref8[0],
      v = _ref8[1];
    return "".concat(k, "=").concat(v);
  }).join('&'));
  var fetchOpt = Object.assign({}, isDown ? {} : {
    method: 'POST',
    body: genContent(numBytes)
  }, _classPrivateFieldGet2(_fetchOptions, this));
  var serverTime;
  var curPromise = _classPrivateFieldSet2(_currentFetchPromise, this, fetch(url, fetchOpt).then(function (r) {
    if (r.ok) return r;
    throw Error(r.statusText);
  }).then(function (r) {
    _this3.getServerTime && (serverTime = _this3.getServerTime(r));
    return r;
  }).then(function (r) {
    return r.text().then(function (body) {
      _classPrivateFieldGet2(_responseHook, _this3) && _classPrivateFieldGet2(_responseHook, _this3).call(_this3, {
        url: url,
        headers: r.headers,
        body: body
      });
      return body;
    });
  }).then(function (_, reject) {
    if (curPromise._cancel) {
      reject('cancelled');
      return;
    }
    var perf = performance.getEntriesByName(url).slice(-1)[0]; // get latest perf timing
    var timing = {
      transferSize: perf.transferSize,
      ttfb: getTtfb(perf),
      payloadDownloadTime: gePayloadDownload(perf),
      serverTime: serverTime || -1,
      measTime: new Date()
    };
    timing.ping = Math.max(1e-2, timing.ttfb - (serverTime || _classPrivateFieldGet2(_estimatedServerTime, _this3))); // ttfb = network latency + server time

    timing.duration = (isDown ? calcDownloadDuration : calcUploadDuration)(timing);
    timing.bps = (isDown ? calcDownloadSpeed : calcUploadSpeed)(timing, numBytes);
    if (isDown && numBytes) {
      var reqSize = +numBytes;
      if (timing.transferSize && (timing.transferSize < reqSize || timing.transferSize / reqSize > 1.05)) {
        // log if transferSize is too different from requested size
        console.warn("Requested ".concat(reqSize, "B but received ").concat(timing.transferSize, "B (").concat(Math.round(timing.transferSize / reqSize * 1e4) / 1e2, "%)."));
      }
    }
    speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _saveMeasurementResults).call(_this3, measIdx, timing);
    var requestDuration = timing.duration;
    _classPrivateFieldSet2(_minDuration, _this3, _classPrivateFieldGet2(_minDuration, _this3) < 0 ? requestDuration : Math.min(_classPrivateFieldGet2(_minDuration, _this3), requestDuration)); // carry minimum request duration

    _classPrivateFieldSet2(_counter, _this3, _classPrivateFieldGet2(_counter, _this3) + 1);
    _classPrivateFieldSet2(_retries, _this3, 0);
    if (_classPrivateFieldGet2(_throttleMs, _this3)) {
      _classPrivateFieldSet2(_currentNextMsmTimeoutId, _this3, setTimeout(function () {
        return speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _nextMeasurement).call(_this3);
      }, _classPrivateFieldGet2(_throttleMs, _this3)));
    } else {
      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _nextMeasurement).call(_this3);
    }
  })["catch"](function (error) {
    var _this$retries, _this$retries2;
    if (curPromise._cancel) return;
    console.warn("Error fetching ".concat(url, ": ").concat(error));
    if ((_classPrivateFieldSet2(_retries, _this3, (_this$retries = _classPrivateFieldGet2(_retries, _this3), _this$retries2 = _this$retries++, _this$retries)), _this$retries2) < MAX_RETRIES) {
      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _nextMeasurement).call(_this3); // keep trying
    } else {
      _classPrivateFieldSet2(_retries, _this3, 0);
      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _setRunning$2).call(_this3, false);
      _classPrivateFieldGet2(_onConnectionError$1, _this3).call(_this3, "Connection failed to ".concat(url, ". Gave up after ").concat(MAX_RETRIES, " retries."));
    }
  }));
}
function _cancelCurrentMeasurement() {
  var curPromise = _classPrivateFieldGet2(_currentFetchPromise, this);
  curPromise && (curPromise._cancel = true);
}

var _excluded$5 = ["measureParallelLatency", "parallelLatencyThrottleMs", "downloadApiUrl", "uploadApiUrl", "estimatedServerTime"];
var _latencyEngine = /*#__PURE__*/new WeakMap();
var _latencyTimeout = /*#__PURE__*/new WeakMap();
var _BandwidthWithParallelLatencyEngine_brand = /*#__PURE__*/new WeakSet();
var BandwidthWithParallelLatencyEngine = /*#__PURE__*/function (_BandwidthEngine) {
  function BandwidthWithParallelLatencyEngine(measurements) {
    var _this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$measureParallelL = _ref.measureParallelLatency,
      measureParallelLatency = _ref$measureParallelL === void 0 ? false : _ref$measureParallelL,
      _ref$parallelLatencyT = _ref.parallelLatencyThrottleMs,
      parallelLatencyThrottleMs = _ref$parallelLatencyT === void 0 ? 100 : _ref$parallelLatencyT,
      downloadApiUrl = _ref.downloadApiUrl,
      uploadApiUrl = _ref.uploadApiUrl,
      _ref$estimatedServerT = _ref.estimatedServerTime,
      estimatedServerTime = _ref$estimatedServerT === void 0 ? 0 : _ref$estimatedServerT,
      ptProps = _objectWithoutProperties(_ref, _excluded$5);
    _classCallCheck(this, BandwidthWithParallelLatencyEngine);
    _this = speedtest_callSuper(this, BandwidthWithParallelLatencyEngine, [measurements, speedtest_objectSpread2({
      downloadApiUrl: downloadApiUrl,
      uploadApiUrl: uploadApiUrl,
      estimatedServerTime: estimatedServerTime
    }, ptProps)]);
    // Internal methods
    speedtest_classPrivateMethodInitSpec(_this, _BandwidthWithParallelLatencyEngine_brand);
    // Internal state
    speedtest_classPrivateFieldInitSpec(_this, _latencyEngine, void 0);
    speedtest_classPrivateFieldInitSpec(_this, _latencyTimeout, void 0);
    if (measureParallelLatency) {
      _classPrivateFieldSet2(_latencyEngine, _this, new BandwidthMeasurementEngine([{
        dir: 'down',
        bytes: 0,
        count: Infinity,
        bypassMinDuration: true
      }], {
        downloadApiUrl: downloadApiUrl,
        uploadApiUrl: uploadApiUrl,
        estimatedServerTime: estimatedServerTime,
        throttleMs: parallelLatencyThrottleMs
      }));
      _classPrivateFieldGet2(_latencyEngine, _this).qsParams = {
        during: "".concat(measurements[0].dir, "load")
      };
      _superPropSet((BandwidthWithParallelLatencyEngine), "onRunningChange", speedtest_assertClassBrand(_BandwidthWithParallelLatencyEngine_brand, _this, _setLatencyRunning), _this, 1);
      _superPropSet((BandwidthWithParallelLatencyEngine), "onConnectionError", function () {
        return _classPrivateFieldGet2(_latencyEngine, _this).pause();
      }, _this, 1);
    }
    return _this;
  }

  // Public attributes
  _inherits(BandwidthWithParallelLatencyEngine, _BandwidthEngine);
  return _createClass(BandwidthWithParallelLatencyEngine, [{
    key: "latencyResults",
    get: function get() {
      // read access to latency results
      return _classPrivateFieldGet2(_latencyEngine, this) && _classPrivateFieldGet2(_latencyEngine, this).results.down[0].timings;
    }

    // callback invoked when a new parallel latency result arrives
  }, {
    key: "onParallelLatencyResult",
    set: function set(f) {
      _classPrivateFieldGet2(_latencyEngine, this) && (_classPrivateFieldGet2(_latencyEngine, this).onMeasurementResult = function (res) {
        return f(res);
      });
    }

    // Overridden attributes
  }, {
    key: "fetchOptions",
    get: function get() {
      return _superPropGet(BandwidthWithParallelLatencyEngine, "fetchOptions", this, 1);
    },
    set: function set(fetchOptions) {
      _superPropSet(BandwidthWithParallelLatencyEngine, "fetchOptions", fetchOptions, this, 1);
      _classPrivateFieldGet2(_latencyEngine, this) && (_classPrivateFieldGet2(_latencyEngine, this).fetchOptions = fetchOptions);
    }
  }, {
    key: "onRunningChange",
    set: function set(onRunningChange) {
      var _this2 = this;
      _superPropSet(BandwidthWithParallelLatencyEngine, "onRunningChange", function (running) {
        speedtest_assertClassBrand(_BandwidthWithParallelLatencyEngine_brand, _this2, _setLatencyRunning).call(_this2, running);
        onRunningChange(running);
      }, this, 1);
    }
  }, {
    key: "onConnectionError",
    set: function set(onConnectionError) {
      var _this3 = this;
      _superPropSet(BandwidthWithParallelLatencyEngine, "onConnectionError", function () {
        _classPrivateFieldGet2(_latencyEngine, _this3) && _classPrivateFieldGet2(_latencyEngine, _this3).pause();
        onConnectionError.apply(void 0, arguments);
      }, this, 1);
    }
  }]);
}(BandwidthMeasurementEngine);
function _setLatencyRunning(running) {
  var _this4 = this;
  if (_classPrivateFieldGet2(_latencyEngine, this)) {
    if (!running) {
      clearTimeout(_classPrivateFieldGet2(_latencyTimeout, this));
      _classPrivateFieldGet2(_latencyEngine, this).pause();
    } else {
      // slight delay in starting latency measurements
      _classPrivateFieldSet2(_latencyTimeout, this, setTimeout(function () {
        return _classPrivateFieldGet2(_latencyEngine, _this4).play();
      }, 20));
    }
  }
}

var _excluded$4 = ["measurementId", "logApiUrl"];
var _measurementId$1 = /*#__PURE__*/new WeakMap();
var _token = /*#__PURE__*/new WeakMap();
var _requestTime = /*#__PURE__*/new WeakMap();
var _logApiUrl = /*#__PURE__*/new WeakMap();
var _LoggingBandwidthEngine_brand = /*#__PURE__*/new WeakSet();
var LoggingBandwidthEngine = /*#__PURE__*/function (_BandwidthEngine) {
  function LoggingBandwidthEngine(measurements) {
    var _this;
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      measurementId = _ref.measurementId,
      logApiUrl = _ref.logApiUrl,
      ptProps = _objectWithoutProperties(_ref, _excluded$4);
    _classCallCheck(this, LoggingBandwidthEngine);
    _this = speedtest_callSuper(this, LoggingBandwidthEngine, [measurements, ptProps]);
    // Internal methods
    speedtest_classPrivateMethodInitSpec(_this, _LoggingBandwidthEngine_brand);
    // Internal state
    speedtest_classPrivateFieldInitSpec(_this, _measurementId$1, void 0);
    speedtest_classPrivateFieldInitSpec(_this, _token, void 0);
    speedtest_classPrivateFieldInitSpec(_this, _requestTime, void 0);
    speedtest_classPrivateFieldInitSpec(_this, _logApiUrl, void 0);
    _classPrivateFieldSet2(_measurementId$1, _this, measurementId);
    _classPrivateFieldSet2(_logApiUrl, _this, logApiUrl);
    _superPropSet((LoggingBandwidthEngine), "qsParams", logApiUrl ? {
      measId: _classPrivateFieldGet2(_measurementId$1, _this)
    } : {}, _this, 1);
    _superPropSet((LoggingBandwidthEngine), "responseHook", function (r) {
      return speedtest_assertClassBrand(_LoggingBandwidthEngine_brand, _this, _loggingResponseHook).call(_this, r);
    }, _this, 1);
    _superPropSet((LoggingBandwidthEngine), "onMeasurementResult", function (meas) {
      return speedtest_assertClassBrand(_LoggingBandwidthEngine_brand, _this, _logMeasurement).call(_this, meas);
    }, _this, 1);
    return _this;
  }

  // Overridden attributes
  _inherits(LoggingBandwidthEngine, _BandwidthEngine);
  return _createClass(LoggingBandwidthEngine, [{
    key: "qsParams",
    set: function set(qsParams) {
      _superPropSet(LoggingBandwidthEngine, "qsParams", _classPrivateFieldGet2(_logApiUrl, this) ? speedtest_objectSpread2({
        measId: _classPrivateFieldGet2(_measurementId$1, this)
      }, qsParams) : qsParams, this, 1);
    }
  }, {
    key: "responseHook",
    set: function set(responseHook) {
      var _this2 = this;
      _superPropSet(LoggingBandwidthEngine, "responseHook", function (r) {
        responseHook(r);
        speedtest_assertClassBrand(_LoggingBandwidthEngine_brand, _this2, _loggingResponseHook).call(_this2, r);
      }, this, 1);
    }
  }, {
    key: "onMeasurementResult",
    set: function set(onMeasurementResult) {
      var _this3 = this;
      _superPropSet(LoggingBandwidthEngine, "onMeasurementResult", function (meas) {
        for (var _len = arguments.length, restArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          restArgs[_key - 1] = arguments[_key];
        }
        onMeasurementResult.apply(void 0, [meas].concat(restArgs));
        speedtest_assertClassBrand(_LoggingBandwidthEngine_brand, _this3, _logMeasurement).call(_this3, meas);
      }, this, 1);
    }
  }]);
}(BandwidthWithParallelLatencyEngine);
function _loggingResponseHook(r) {
  if (!_classPrivateFieldGet2(_logApiUrl, this)) return;

  // get request time
  _classPrivateFieldSet2(_requestTime, this, +r.headers.get("cf-meta-request-time"));

  // get token in payload
  _classPrivateFieldSet2(_token, this, r.body.slice(-300).split('___').pop());
}
function _logMeasurement(measData) {
  if (!_classPrivateFieldGet2(_logApiUrl, this)) return;
  var logData = {
    type: measData.type,
    bytes: measData.bytes,
    ping: Math.round(measData.ping),
    // round to ms
    ttfb: Math.round(measData.ttfb),
    // round to ms
    payloadDownloadTime: Math.round(measData.payloadDownloadTime),
    duration: Math.round(measData.duration),
    transferSize: Math.round(measData.transferSize),
    serverTime: Math.round(measData.serverTime),
    token: _classPrivateFieldGet2(_token, this),
    requestTime: _classPrivateFieldGet2(_requestTime, this),
    measId: _classPrivateFieldGet2(_measurementId$1, this)
  };
  _classPrivateFieldSet2(_token, this, null);
  _classPrivateFieldSet2(_requestTime, this, null);
  fetch(_classPrivateFieldGet2(_logApiUrl, this), speedtest_objectSpread2({
    method: 'POST',
    body: JSON.stringify(logData)
  }, this.fetchOptions));
}

var _running$1 = /*#__PURE__*/new WeakMap();
var _currentPromise = /*#__PURE__*/new WeakMap();
var _promiseFn = /*#__PURE__*/new WeakMap();
var _PromiseEngine_brand = /*#__PURE__*/new WeakSet();
var PromiseEngine = /*#__PURE__*/function () {
  function PromiseEngine(promiseFn) {
    _classCallCheck(this, PromiseEngine);
    // Internal methods
    speedtest_classPrivateMethodInitSpec(this, _PromiseEngine_brand);
    // Internal state
    speedtest_classPrivateFieldInitSpec(this, _running$1, false);
    speedtest_classPrivateFieldInitSpec(this, _currentPromise, undefined);
    speedtest_classPrivateFieldInitSpec(this, _promiseFn, void 0);
    if (!promiseFn) throw new Error("Missing operation to perform");
    _classPrivateFieldSet2(_promiseFn, this, promiseFn);
    this.play();
  }

  // Public methods
  return _createClass(PromiseEngine, [{
    key: "pause",
    value: function pause() {
      speedtest_assertClassBrand(_PromiseEngine_brand, this, _cancelCurrent).call(this);
      speedtest_assertClassBrand(_PromiseEngine_brand, this, _setRunning$1).call(this, false);
    }
  }, {
    key: "stop",
    value: function stop() {
      this.pause();
    }
  }, {
    key: "play",
    value: function play() {
      if (!_classPrivateFieldGet2(_running$1, this)) {
        speedtest_assertClassBrand(_PromiseEngine_brand, this, _setRunning$1).call(this, true);
        speedtest_assertClassBrand(_PromiseEngine_brand, this, _next$1).call(this);
      }
    }
  }]);
}();
function _setRunning$1(running) {
  if (running !== _classPrivateFieldGet2(_running$1, this)) {
    _classPrivateFieldSet2(_running$1, this, running);
  }
}
function _next$1() {
  var _this2 = this;
  var curPromise = _classPrivateFieldSet2(_currentPromise, this, _classPrivateFieldGet2(_promiseFn, this).call(this).then(function () {
    !curPromise._cancel && speedtest_assertClassBrand(_PromiseEngine_brand, _this2, _next$1).call(_this2);
  }));
}
function _cancelCurrent() {
  var curPromise = _classPrivateFieldGet2(_currentPromise, this);
  curPromise && (curPromise._cancel = true);
}
var _engines = /*#__PURE__*/new WeakMap();
var LoadNetworkEngine = /*#__PURE__*/function () {
  function LoadNetworkEngine() {
    var _this = this;
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      download = _ref.download,
      upload = _ref.upload;
    _classCallCheck(this, LoadNetworkEngine);
    // Public attributes
    _defineProperty(this, "qsParams", {});
    // additional query string params to include in the requests
    _defineProperty(this, "fetchOptions", {});
    // Internal state
    speedtest_classPrivateFieldInitSpec(this, _engines, []);
    // Expected attrs for each: { apiUrl, chunkSize }
    if (!download && !upload) throw new Error('Missing at least one of download/upload config');
    [[download, 'download'], [upload, 'upload']].filter(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 1),
        cfg = _ref3[0];
      return cfg;
    }).forEach(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
        cfg = _ref5[0],
        type = _ref5[1];
      var apiUrl = cfg.apiUrl,
        chunkSize = cfg.chunkSize;
      if (!apiUrl) throw new Error("Missing ".concat(type, " apiUrl argument"));
      if (!chunkSize) throw new Error("Missing ".concat(type, " chunkSize argument"));
    });
    var getLoadEngine = function getLoadEngine(_ref6) {
      var apiUrl = _ref6.apiUrl,
        _ref6$qsParams = _ref6.qsParams,
        qsParams = _ref6$qsParams === void 0 ? {} : _ref6$qsParams,
        _ref6$fetchOptions = _ref6.fetchOptions,
        fetchOptions = _ref6$fetchOptions === void 0 ? {} : _ref6$fetchOptions;
      return new PromiseEngine(function () {
        var fetchQsParams = Object.assign({}, qsParams, _this.qsParams);
        var url = "".concat(apiUrl.startsWith('http') || apiUrl.startsWith('//') ? '' : window.location.origin // use abs to match perf timing urls
        ).concat(apiUrl, "?").concat(Object.entries(fetchQsParams).map(function (_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2),
            k = _ref8[0],
            v = _ref8[1];
          return "".concat(k, "=").concat(v);
        }).join('&'));
        var fetchOpt = Object.assign({}, fetchOptions, _this.fetchOptions);
        return fetch(url, fetchOpt).then(function (r) {
          if (r.ok) return r;
          throw Error(r.statusText);
        }).then(function (r) {
          return r.text();
        });
      });
    };
    download && _classPrivateFieldGet2(_engines, this).push(getLoadEngine({
      apiUrl: download.apiUrl,
      qsParams: {
        bytes: "".concat(download.chunkSize)
      }
    }));
    upload && _classPrivateFieldGet2(_engines, this).push(getLoadEngine({
      apiUrl: upload.apiUrl,
      fetchOptions: {
        method: 'POST',
        body: '0'.repeat(upload.chunkSize)
      }
    }));
  }
  return _createClass(LoadNetworkEngine, [{
    key: "pause",
    value:
    // additional options included in the requests

    // Public methods
    function pause() {
      _classPrivateFieldGet2(_engines, this).forEach(function (engine) {
        return engine.pause();
      });
    }
  }, {
    key: "stop",
    value: function stop() {
      this.pause();
    }
  }, {
    key: "play",
    value: function play() {
      _classPrivateFieldGet2(_engines, this).forEach(function (engine) {
        return engine.play();
      });
    }
  }]);
}();

var _excluded$3 = ["iceServers", "acceptIceCandidate", "dataChannelCfg"];
var _established = /*#__PURE__*/new WeakMap();
var _sender = /*#__PURE__*/new WeakMap();
var _receiver = /*#__PURE__*/new WeakMap();
var _senderDc = /*#__PURE__*/new WeakMap();
var _receiverDc = /*#__PURE__*/new WeakMap();
var SelfWebRtcDataConnection = /*#__PURE__*/function () {
  function SelfWebRtcDataConnection() {
    var _this = this;
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$iceServers = _ref.iceServers,
      iceServers = _ref$iceServers === void 0 ? [] : _ref$iceServers,
      _ref$acceptIceCandida = _ref.acceptIceCandidate,
      acceptIceCandidate = _ref$acceptIceCandida === void 0 ? function (candidate) {
        var protocol = candidate.protocol || '';
        // parsed webRTC candidate properties not extracted in Firefox: https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidate
        if (!protocol && candidate.candidate) {
          var sdpAttrs = candidate.candidate.split(' ');
          sdpAttrs.length >= 3 && (protocol = sdpAttrs[2]);
        }
        return protocol.toLowerCase() === 'udp';
      } : _ref$acceptIceCandida,
      _ref$dataChannelCfg = _ref.dataChannelCfg,
      dataChannelCfg = _ref$dataChannelCfg === void 0 ? {
        ordered: false,
        maxRetransmits: 0
      } : _ref$dataChannelCfg,
      rtcPeerConnectionCfg = _objectWithoutProperties(_ref, _excluded$3);
    _classCallCheck(this, SelfWebRtcDataConnection);
    // Public attributes
    _defineProperty(this, "onOpen", function () {});
    // callback invoked when WebRTC TURN connection is established
    _defineProperty(this, "onClose", function () {});
    // callback invoked when WebRTC TURN connection is closed
    _defineProperty(this, "onMessageReceived", function () {});
    // Internal state
    speedtest_classPrivateFieldInitSpec(this, _established, false);
    speedtest_classPrivateFieldInitSpec(this, _sender, void 0);
    speedtest_classPrivateFieldInitSpec(this, _receiver, void 0);
    speedtest_classPrivateFieldInitSpec(this, _senderDc, void 0);
    speedtest_classPrivateFieldInitSpec(this, _receiverDc, void 0);
    var sender = new RTCPeerConnection(speedtest_objectSpread2({
      iceServers: iceServers
    }, rtcPeerConnectionCfg));
    var receiver = new RTCPeerConnection(speedtest_objectSpread2({
      iceServers: iceServers
    }, rtcPeerConnectionCfg));
    var senderDc = sender.createDataChannel('channel', dataChannelCfg);
    senderDc.onopen = function () {
      _classPrivateFieldSet2(_established, _this, true);
      _this.onOpen();
    };
    senderDc.onclose = function () {
      return _this.close();
    };
    // senderDc.onmessage = msg => this.#onMessage(msg.data);

    receiver.ondatachannel = function (e) {
      var dc = e.channel;
      dc.onclose = function () {
        return _this.close();
      };
      dc.onmessage = function (msg) {
        return _this.onMessageReceived(msg.data);
      };
      _classPrivateFieldSet2(_receiverDc, _this, dc);
    };

    // sender.onconnectionstatechange = e => console.log('connection state change', e);
    // sender.oniceconnectionstatechange = e => console.log('ice connection state change', e);
    // sender.onicecandidateerror = e => console.log('ice error', e);
    sender.onicecandidate = function (e) {
      // console.log('sender', e.candidate);
      e.candidate && acceptIceCandidate(e.candidate) && receiver.addIceCandidate(e.candidate);
    };
    receiver.onicecandidate = function (e) {
      // console.log('receiver', e.candidate);
      e.candidate && acceptIceCandidate(e.candidate) && sender.addIceCandidate(e.candidate);
    };
    sender.createOffer().then(function (offer) {
      return sender.setLocalDescription(offer);
    }).then(function () {
      return receiver.setRemoteDescription(sender.localDescription);
    }).then(function () {
      return receiver.createAnswer();
    }).then(function (answer) {
      return receiver.setLocalDescription(answer);
    }).then(function () {
      return sender.setRemoteDescription(receiver.localDescription);
    });
    _classPrivateFieldSet2(_sender, this, sender);
    _classPrivateFieldSet2(_receiver, this, receiver);
    _classPrivateFieldSet2(_senderDc, this, senderDc);
    _classPrivateFieldSet2(_established, this, false);
  }
  return _createClass(SelfWebRtcDataConnection, [{
    key: "send",
    value:
    // callback invoked when a new message is received from the TURN server

    // Public methods
    function send(msg) {
      return _classPrivateFieldGet2(_senderDc, this).send(msg);
    }
  }, {
    key: "close",
    value: function close() {
      _classPrivateFieldGet2(_sender, this) && _classPrivateFieldGet2(_sender, this).close();
      _classPrivateFieldGet2(_receiver, this) && _classPrivateFieldGet2(_receiver, this).close();
      _classPrivateFieldGet2(_senderDc, this) && _classPrivateFieldGet2(_senderDc, this).close();
      _classPrivateFieldGet2(_receiverDc, this) && _classPrivateFieldGet2(_receiverDc, this).close();
      _classPrivateFieldGet2(_established, this) && this.onClose();
      _classPrivateFieldSet2(_established, this, false);
      return this;
    }
  }]);
}();

var _onCredentialsFailure = /*#__PURE__*/new WeakMap();
var _onConnectionError = /*#__PURE__*/new WeakMap();
var _onFinished = /*#__PURE__*/new WeakMap();
var _msgTracker = /*#__PURE__*/new WeakMap();
var _webRtcConnection = /*#__PURE__*/new WeakMap();
var _numMsgs = /*#__PURE__*/new WeakMap();
var PacketLossEngine = /*#__PURE__*/function () {
  function PacketLossEngine() {
    var _this = this;
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      turnServerUri = _ref.turnServerUri,
      turnServerCredsApi = _ref.turnServerCredsApi,
      _ref$turnServerCredsA = _ref.turnServerCredsApiParser,
      turnServerCredsApiParser = _ref$turnServerCredsA === void 0 ? function (_ref2) {
        var username = _ref2.username,
          credential = _ref2.credential,
          server = _ref2.server;
        return {
          turnServerUser: username,
          turnServerPass: credential,
          turnServerUri: server
        };
      } : _ref$turnServerCredsA,
      _ref$turnServerCredsA2 = _ref.turnServerCredsApiIncludeCredentials,
      turnServerCredsApiIncludeCredentials = _ref$turnServerCredsA2 === void 0 ? false : _ref$turnServerCredsA2,
      turnServerUser = _ref.turnServerUser,
      turnServerPass = _ref.turnServerPass,
      _ref$numMsgs = _ref.numMsgs,
      numMsgs = _ref$numMsgs === void 0 ? 100 : _ref$numMsgs,
      _ref$batchSize = _ref.batchSize,
      batchSize = _ref$batchSize === void 0 ? 10 : _ref$batchSize,
      _ref$batchWaitTime = _ref.batchWaitTime,
      batchWaitTime = _ref$batchWaitTime === void 0 ? 10 : _ref$batchWaitTime,
      _ref$responsesWaitTim = _ref.responsesWaitTime,
      responsesWaitTime = _ref$responsesWaitTim === void 0 ? 5000 : _ref$responsesWaitTim,
      _ref$connectionTimeou = _ref.connectionTimeout,
      connectionTimeout = _ref$connectionTimeou === void 0 ? 5000 : _ref$connectionTimeou;
    _classCallCheck(this, PacketLossEngine);
    // Public attributes
    speedtest_classPrivateFieldInitSpec(this, _onCredentialsFailure, function () {});
    speedtest_classPrivateFieldInitSpec(this, _onConnectionError, function () {});
    speedtest_classPrivateFieldInitSpec(this, _onFinished, function () {});
    _defineProperty(this, "onMsgSent", function () {});
    // Invoked when sending a new message to the TURN server
    _defineProperty(this, "onAllMsgsSent", function () {});
    // Invoked when all messages have been sent
    _defineProperty(this, "onMsgReceived", function () {});
    // Public methods

    // Internal state
    speedtest_classPrivateFieldInitSpec(this, _msgTracker, {});
    speedtest_classPrivateFieldInitSpec(this, _webRtcConnection, void 0);
    speedtest_classPrivateFieldInitSpec(this, _numMsgs, void 0);
    if (!turnServerUri && !turnServerCredsApi) throw new Error('Missing turnServerCredsApi or turnServerUri argument');
    if ((!turnServerUser || !turnServerPass) && !turnServerCredsApi) throw new Error('Missing either turnServerCredsApi or turnServerUser+turnServerPass arguments');
    _classPrivateFieldSet2(_numMsgs, this, numMsgs);
    (!turnServerUser || !turnServerPass ?
    // Get TURN credentials from API endpoint if not statically supplied
    fetch(turnServerCredsApi, {
      credentials: turnServerCredsApiIncludeCredentials ? 'include' : undefined
    }).then(function (r) {
      return r.json();
    }).then(function (d) {
      if (d.error) throw d.error;
      return d;
    }).then(turnServerCredsApiParser) : Promise.resolve({
      turnServerUser: turnServerUser,
      turnServerPass: turnServerPass
    }))["catch"](function (e) {
      return _classPrivateFieldGet2(_onCredentialsFailure, _this).call(_this, e);
    }).then(function (_ref3) {
      var turnServerUser = _ref3.turnServerUser,
        turnServerPass = _ref3.turnServerPass,
        credsApiTurnServerUri = _ref3.turnServerUri;
      var c = _classPrivateFieldSet2(_webRtcConnection, _this, new SelfWebRtcDataConnection({
        iceServers: [{
          urls: "turn:".concat(credsApiTurnServerUri || turnServerUri, "?transport=udp"),
          username: turnServerUser,
          credential: turnServerPass
        }],
        iceTransportPolicy: 'relay'
      }));
      var connectionSuccess = false;
      setTimeout(function () {
        if (!connectionSuccess) {
          c.close();
          _classPrivateFieldGet2(_onConnectionError, _this).call(_this, 'ICE connection timeout!');
        }
      }, connectionTimeout);
      var msgTracker = _classPrivateFieldGet2(_msgTracker, _this);
      c.onOpen = function () {
        connectionSuccess = true;
        var self = _this;
        (function sendNum(n) {
          if (n <= numMsgs) {
            var i = n;
            while (i <= Math.min(numMsgs, n + batchSize - 1)) {
              msgTracker[i] = false;
              c.send(i);
              self.onMsgSent(i);
              i++;
            }
            setTimeout(function () {
              return sendNum(i);
            }, batchWaitTime);
          } else {
            self.onAllMsgsSent(Object.keys(msgTracker).length);
            var finishFn = function finishFn() {
              c.close();
              _classPrivateFieldGet2(_onFinished, self).call(self, self.results);
            };
            var finishTimeout = setTimeout(finishFn, responsesWaitTime);
            var missingMsgs = Object.values(_classPrivateFieldGet2(_msgTracker, self)).filter(function (recv) {
              return !recv;
            }).length;
            c.onMessageReceived = function (msg) {
              clearTimeout(finishTimeout);
              msgTracker[msg] = true;
              self.onMsgReceived(msg);
              missingMsgs--;
              if (missingMsgs <= 0 && Object.values(_classPrivateFieldGet2(_msgTracker, self)).every(function (recv) {
                return recv;
              })) {
                // Last msg received, shortcut out
                finishFn();
              } else {
                // restart timeout
                finishTimeout = setTimeout(finishFn, responsesWaitTime);
              }
            };
          }
        })(1);
      };
      c.onMessageReceived = function (msg) {
        msgTracker[msg] = true;
        _this.onMsgReceived(msg);
      };
    })["catch"](function (e) {
      return _classPrivateFieldGet2(_onConnectionError, _this).call(_this, e.toString());
    });
  }
  return _createClass(PacketLossEngine, [{
    key: "onCredentialsFailure",
    set:
    // Invoked when unable to fetch TURN server credentials
    function set(f) {
      _classPrivateFieldSet2(_onCredentialsFailure, this, f);
    }
  }, {
    key: "onConnectionError",
    set:
    // Invoked when unable to establish a connection with TURN server
    function set(f) {
      _classPrivateFieldSet2(_onConnectionError, this, f);
    }
  }, {
    key: "onFinished",
    set:
    // Invoked when the packet loss measurement is complete
    function set(f) {
      _classPrivateFieldSet2(_onFinished, this, f);
    }
  }, {
    key: "results",
    get:
    // Invoked when receiving a new message from the TURN server

    function get() {
      var totalMessages = _classPrivateFieldGet2(_numMsgs, this);
      var numMessagesSent = Object.keys(_classPrivateFieldGet2(_msgTracker, this)).length;
      var lostMessages = Object.entries(_classPrivateFieldGet2(_msgTracker, this)).filter(function (_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
          recv = _ref5[1];
        return !recv;
      }).map(function (_ref6) {
        var _ref7 = _slicedToArray(_ref6, 1),
          n = _ref7[0];
        return +n;
      });
      var packetLoss = lostMessages.length / numMessagesSent;
      return {
        totalMessages: totalMessages,
        numMessagesSent: numMessagesSent,
        packetLoss: packetLoss,
        lostMessages: lostMessages
      };
    }
  }]);
}();

var _excluded$2 = ["downloadChunkSize", "uploadChunkSize", "downloadApiUrl", "uploadApiUrl"];
var _loadEngine = /*#__PURE__*/new WeakMap();
var PacketLossUnderLoadEngine = /*#__PURE__*/function (_PacketLossEngine) {
  function PacketLossUnderLoadEngine() {
    var _this;
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      downloadChunkSize = _ref.downloadChunkSize,
      uploadChunkSize = _ref.uploadChunkSize,
      downloadApiUrl = _ref.downloadApiUrl,
      uploadApiUrl = _ref.uploadApiUrl,
      ptProps = _objectWithoutProperties(_ref, _excluded$2);
    _classCallCheck(this, PacketLossUnderLoadEngine);
    _this = speedtest_callSuper(this, PacketLossUnderLoadEngine, [ptProps]);
    // Internal state
    speedtest_classPrivateFieldInitSpec(_this, _loadEngine, void 0);
    if (downloadChunkSize || uploadChunkSize) {
      _classPrivateFieldSet2(_loadEngine, _this, new LoadNetworkEngine({
        download: downloadChunkSize ? {
          apiUrl: downloadApiUrl,
          chunkSize: downloadChunkSize
        } : null,
        upload: uploadChunkSize ? {
          apiUrl: uploadApiUrl,
          chunkSize: uploadChunkSize
        } : null
      }));
      _superPropSet((PacketLossUnderLoadEngine), "onCredentialsFailure", _superPropSet((PacketLossUnderLoadEngine), "onConnectionError", _superPropSet((PacketLossUnderLoadEngine), "onFinished", function () {
        return _classPrivateFieldGet2(_loadEngine, _this).stop();
      }, _this, 1, 1), _this, 1, 1), _this, 1);
    }
    return _this;
  }

  // Overridden attributes
  _inherits(PacketLossUnderLoadEngine, _PacketLossEngine);
  return _createClass(PacketLossUnderLoadEngine, [{
    key: "qsParams",
    set: function set(qsParams) {
      _classPrivateFieldGet2(_loadEngine, this) && (_classPrivateFieldGet2(_loadEngine, this).qsParams = qsParams);
    }
  }, {
    key: "fetchOptions",
    set: function set(fetchOptions) {
      _classPrivateFieldGet2(_loadEngine, this) && (_classPrivateFieldGet2(_loadEngine, this).fetchOptions = fetchOptions);
    }
  }, {
    key: "onCredentialsFailure",
    set: function set(onCredentialsFailure) {
      var _this2 = this;
      _superPropSet(PacketLossUnderLoadEngine, "onCredentialsFailure", function () {
        onCredentialsFailure.apply(void 0, arguments);
        _classPrivateFieldGet2(_loadEngine, _this2) && _classPrivateFieldGet2(_loadEngine, _this2).stop();
      }, this, 1);
    }
  }, {
    key: "onConnectionError",
    set: function set(onConnectionError) {
      var _this3 = this;
      _superPropSet(PacketLossUnderLoadEngine, "onConnectionError", function () {
        onConnectionError.apply(void 0, arguments);
        _classPrivateFieldGet2(_loadEngine, _this3) && _classPrivateFieldGet2(_loadEngine, _this3).stop();
      }, this, 1);
    }
  }, {
    key: "onFinished",
    set: function set(onFinished) {
      var _this4 = this;
      _superPropSet(PacketLossUnderLoadEngine, "onFinished", function () {
        onFinished.apply(void 0, arguments);
        _classPrivateFieldGet2(_loadEngine, _this4) && _classPrivateFieldGet2(_loadEngine, _this4).stop();
      }, this, 1);
    }
  }]);
}(PacketLossEngine);

var _excluded$1 = ["reachable"];
var ReachabilityEngine = /*#__PURE__*/_createClass(function ReachabilityEngine(targetUrl) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$timeout = _ref.timeout,
    timeout = _ref$timeout === void 0 ? -1 : _ref$timeout,
    _ref$fetchOptions = _ref.fetchOptions,
    fetchOptions = _ref$fetchOptions === void 0 ? {} : _ref$fetchOptions;
  _classCallCheck(this, ReachabilityEngine);
  // Public attributes
  _defineProperty(this, "onFinished", function () {});
  var finished = false;
  var finish = function finish(_ref2) {
    var reachable = _ref2.reachable,
      rest = _objectWithoutProperties(_ref2, _excluded$1);
    if (finished) return;
    finished = true;
    _this.onFinished(speedtest_objectSpread2({
      targetUrl: targetUrl,
      reachable: reachable
    }, rest));
  };
  fetch(targetUrl, fetchOptions).then(function (response) {
    finish({
      reachable: true,
      response: response
    });
  })["catch"](function (error) {
    finish({
      reachable: false,
      error: error
    });
  });
  timeout > 0 && setTimeout(function () {
    return finish({
      reachable: false,
      error: 'Request timeout'
    });
  }, timeout);
});

var sum = function sum(vals) {
  return vals.reduce(function (agg, val) {
    return agg + val;
  }, 0);
};
var percentile = function percentile(vals) {
  var perc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
  if (!vals.length) return 0;
  var sortedVals = vals.slice().sort(function (a, b) {
    return a - b;
  });
  var idx = (vals.length - 1) * perc;
  var rem = idx % 1;
  if (rem === 0) return sortedVals[Math.round(idx)];

  // calculate weighted average
  var edges = [Math.floor, Math.ceil].map(function (rndFn) {
    return sortedVals[rndFn(idx)];
  });
  return edges[0] + (edges[1] - edges[0]) * rem;
};

var _config$3 = /*#__PURE__*/new WeakMap();
var _extractLoadedLatencies = /*#__PURE__*/new WeakMap();
var MeasurementCalculations = /*#__PURE__*/function () {
  function MeasurementCalculations(config) {
    var _this = this;
    _classCallCheck(this, MeasurementCalculations);
    // Public methods
    _defineProperty(this, "getLatencyPoints", function (latencyResults) {
      return latencyResults.timings.map(function (d) {
        return d.ping;
      });
    });
    _defineProperty(this, "getLatency", function (latencyResults) {
      return percentile(_this.getLatencyPoints(latencyResults), _classPrivateFieldGet2(_config$3, _this).latencyPercentile);
    });
    _defineProperty(this, "getBandwidthPoints", function (bandwidthResults) {
      return Object.entries(bandwidthResults).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          bytes = _ref2[0],
          timings = _ref2[1].timings;
        return timings.map(function (_ref3) {
          var bps = _ref3.bps,
            duration = _ref3.duration,
            ping = _ref3.ping,
            measTime = _ref3.measTime,
            serverTime = _ref3.serverTime,
            transferSize = _ref3.transferSize;
          return {
            bytes: +bytes,
            bps: bps,
            duration: duration,
            ping: ping,
            measTime: measTime,
            serverTime: serverTime,
            transferSize: transferSize
          };
        });
      }).flat();
    });
    _defineProperty(this, "getBandwidth", function (bandwidthResults) {
      return percentile(_this.getBandwidthPoints(bandwidthResults).filter(function (d) {
        return d.duration >= _classPrivateFieldGet2(_config$3, _this).bandwidthMinRequestDuration;
      }).map(function (d) {
        return d.bps;
      }).filter(function (bps) {
        return bps;
      }), _classPrivateFieldGet2(_config$3, _this).bandwidthPercentile);
    });
    _defineProperty(this, "getLoadedLatency", function (loadedResults) {
      return _this.getLatency({
        timings: _classPrivateFieldGet2(_extractLoadedLatencies, _this).call(_this, loadedResults)
      });
    });
    _defineProperty(this, "getLoadedJitter", function (loadedResults) {
      return _this.getJitter({
        timings: _classPrivateFieldGet2(_extractLoadedLatencies, _this).call(_this, loadedResults)
      });
    });
    _defineProperty(this, "getLoadedLatencyPoints", function (loadedResults) {
      return _this.getLatencyPoints({
        timings: _classPrivateFieldGet2(_extractLoadedLatencies, _this).call(_this, loadedResults)
      });
    });
    _defineProperty(this, "getPacketLoss", function (plResults) {
      return plResults.packetLoss;
    });
    _defineProperty(this, "getPacketLossDetails", function (plResults) {
      return plResults;
    });
    _defineProperty(this, "getReachability", function (reachabilityResults) {
      return !!reachabilityResults.reachable;
    });
    _defineProperty(this, "getReachabilityDetails", function (d) {
      return {
        host: d.host,
        reachable: d.reachable
      };
    });
    // Internal state
    speedtest_classPrivateFieldInitSpec(this, _config$3, void 0);
    // Internal methods
    speedtest_classPrivateFieldInitSpec(this, _extractLoadedLatencies, function (loadedResults) {
      return Object.values(loadedResults).filter(
      // keep only file sizes that saturated the connection
      function (d) {
        return d.timings.length && Math.min.apply(Math, _toConsumableArray(d.timings.map(function (d) {
          return d.duration;
        }))) >= _classPrivateFieldGet2(_config$3, _this).loadedRequestMinDuration;
      }).map(function (d) {
        return d.sideLatency || [];
      }).flat().slice(-_classPrivateFieldGet2(_config$3, _this).loadedLatencyMaxPoints);
    });
    _classPrivateFieldSet2(_config$3, this, config);
  }
  return _createClass(MeasurementCalculations, [{
    key: "getJitter",
    value: function getJitter(latencyResults) {
      // calc jitter as the average latency delta between consecutive samples
      var pings = this.getLatencyPoints(latencyResults);
      return pings.length < 2 ? null : pings.reduce(function (_ref4, latency) {
        var _ref4$sumDeltas = _ref4.sumDeltas,
          sumDeltas = _ref4$sumDeltas === void 0 ? 0 : _ref4$sumDeltas,
          prevLatency = _ref4.prevLatency;
        return {
          sumDeltas: sumDeltas + (prevLatency !== undefined ? Math.abs(prevLatency - latency) : 0),
          prevLatency: latency
        };
      }, {}).sumDeltas / (pings.length - 1);
    }

    // last measurements are most accurate
  }]);
}();

var classificationNames = ['bad', 'poor', 'average', 'good', 'great'];
var customResultTypes = {
  loadedLatencyIncrease: function loadedLatencyIncrease(measurements) {
    return measurements.latency && (measurements.downLoadedLatency || measurements.upLoadedLatency) ? Math.max(measurements.downLoadedLatency, measurements.upLoadedLatency) - measurements.latency : undefined;
  }
};
var defaultPoints = {
  packetLoss: 0
};
var _config$2 = /*#__PURE__*/new WeakMap();
var ScoresCalculations = /*#__PURE__*/function () {
  function ScoresCalculations(config) {
    _classCallCheck(this, ScoresCalculations);
    // Internal state
    speedtest_classPrivateFieldInitSpec(this, _config$2, void 0);
    _classPrivateFieldSet2(_config$2, this, config);
  }
  return _createClass(ScoresCalculations, [{
    key: "getScores",
    value: function getScores(measurements) {
      var scores = Object.assign.apply(Object, _toConsumableArray(Object.entries(_classPrivateFieldGet2(_config$2, this).aimMeasurementScoring).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          type = _ref2[0],
          fn = _ref2[1];
        var val = customResultTypes.hasOwnProperty(type) ? customResultTypes[type](measurements) : measurements[type];
        return val === undefined ? defaultPoints.hasOwnProperty(type) ? _defineProperty({}, type, defaultPoints[type]) : {} : _defineProperty({}, type, val === undefined ? 0 : +fn(val));
      })));
      return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(_classPrivateFieldGet2(_config$2, this).aimExperiencesDefs).filter(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
          input = _ref6[1].input;
        return input.every(function (k) {
          return scores.hasOwnProperty(k);
        });
      }).map(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
          k = _ref8[0],
          _ref8$ = _ref8[1],
          input = _ref8$.input,
          pointThresholds = _ref8$.pointThresholds;
        var sumPoints = Math.max(0, sum(input.map(function (k) {
          return scores[k];
        })));
        var classificationIdx = threshold(pointThresholds, [0, 1, 2, 3, 4])(sumPoints);
        var classificationName = classificationNames[classificationIdx];
        return _defineProperty({}, k, {
          points: sumPoints,
          classificationIdx: classificationIdx,
          classificationName: classificationName
        });
      }))));
    }
  }]);
}();

var _config$1 = /*#__PURE__*/new WeakMap();
var _measCalc = /*#__PURE__*/new WeakMap();
var _scoresCalc = /*#__PURE__*/new WeakMap();
var _calcGetter = /*#__PURE__*/new WeakMap();
var _getV4Reachability = /*#__PURE__*/new WeakMap();
var _getV4ReachabilityDetails = /*#__PURE__*/new WeakMap();
var _getV6Reachability = /*#__PURE__*/new WeakMap();
var _getV6ReachabilityDetails = /*#__PURE__*/new WeakMap();
var Results = /*#__PURE__*/function () {
  function Results(config) {
    var _this = this;
    _classCallCheck(this, Results);
    // Public attributes
    _defineProperty(this, "raw", void 0);
    _defineProperty(this, "getUnloadedLatency", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getLatency', 'latency');
    });
    _defineProperty(this, "getUnloadedJitter", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getJitter', 'latency');
    });
    _defineProperty(this, "getUnloadedLatencyPoints", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getLatencyPoints', 'latency', []);
    });
    _defineProperty(this, "getDownLoadedLatency", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getLoadedLatency', 'download');
    });
    _defineProperty(this, "getDownLoadedJitter", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getLoadedJitter', 'download');
    });
    _defineProperty(this, "getDownLoadedLatencyPoints", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getLoadedLatencyPoints', 'download', []);
    });
    _defineProperty(this, "getUpLoadedLatency", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getLoadedLatency', 'upload');
    });
    _defineProperty(this, "getUpLoadedJitter", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getLoadedJitter', 'upload');
    });
    _defineProperty(this, "getUpLoadedLatencyPoints", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getLoadedLatencyPoints', 'upload', []);
    });
    _defineProperty(this, "getDownloadBandwidth", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getBandwidth', 'download');
    });
    _defineProperty(this, "getDownloadBandwidthPoints", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getBandwidthPoints', 'download', []);
    });
    _defineProperty(this, "getUploadBandwidth", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getBandwidth', 'upload');
    });
    _defineProperty(this, "getUploadBandwidthPoints", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getBandwidthPoints', 'upload', []);
    });
    _defineProperty(this, "getPacketLoss", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getPacketLoss', 'packetLoss');
    });
    _defineProperty(this, "getPacketLossDetails", function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getPacketLossDetails', 'packetLoss', undefined, true);
    });
    _defineProperty(this, "getScores", function () {
      return _classPrivateFieldGet2(_scoresCalc, _this).getScores(_this.getSummary());
    });
    // Internal state
    speedtest_classPrivateFieldInitSpec(this, _config$1, void 0);
    speedtest_classPrivateFieldInitSpec(this, _measCalc, void 0);
    speedtest_classPrivateFieldInitSpec(this, _scoresCalc, void 0);
    // Internal methods
    speedtest_classPrivateFieldInitSpec(this, _calcGetter, function (calcFn, resKey) {
      var defaultVal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var surfaceError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      return !_this.raw.hasOwnProperty(resKey) || !_this.raw[resKey].started ? defaultVal : surfaceError && _this.raw[resKey].error ? {
        error: _this.raw[resKey].error
      } : _classPrivateFieldGet2(_measCalc, _this)[calcFn](_this.raw[resKey].results);
    });
    speedtest_classPrivateFieldInitSpec(this, _getV4Reachability, function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getReachability', 'v4Reachability');
    });
    speedtest_classPrivateFieldInitSpec(this, _getV4ReachabilityDetails, function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getReachabilityDetails', 'v4Reachability');
    });
    speedtest_classPrivateFieldInitSpec(this, _getV6Reachability, function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getReachability', 'v6Reachability');
    });
    speedtest_classPrivateFieldInitSpec(this, _getV6ReachabilityDetails, function () {
      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, 'getReachabilityDetails', 'v6Reachability');
    });
    _classPrivateFieldSet2(_config$1, this, config);
    this.clear();
    _classPrivateFieldSet2(_measCalc, this, new MeasurementCalculations(_classPrivateFieldGet2(_config$1, this)));
    _classPrivateFieldSet2(_scoresCalc, this, new ScoresCalculations(_classPrivateFieldGet2(_config$1, this)));
  }
  return _createClass(Results, [{
    key: "isFinished",
    get: function get() {
      return Object.values(this.raw).every(function (d) {
        return d.finished;
      });
    }

    // Public methods
  }, {
    key: "clear",
    value: function clear() {
      this.raw = Object.assign.apply(Object, [{}].concat(_toConsumableArray(_toConsumableArray(new Set(_classPrivateFieldGet2(_config$1, this).measurements.map(function (m) {
        return m.type;
      }))).map(function (m) {
        return _defineProperty({}, m, {
          started: false,
          finished: false,
          results: {}
        });
      }))));
    }
  }, {
    key: "getSummary",
    value: function getSummary() {
      var items = {
        download: this.getDownloadBandwidth,
        upload: this.getUploadBandwidth,
        latency: this.getUnloadedLatency,
        jitter: this.getUnloadedJitter,
        downLoadedLatency: this.getDownLoadedLatency,
        downLoadedJitter: this.getDownLoadedJitter,
        upLoadedLatency: this.getUpLoadedLatency,
        upLoadedJitter: this.getUpLoadedJitter,
        packetLoss: this.getPacketLoss,
        v4Reachability: _classPrivateFieldGet2(_getV4Reachability, this),
        v6Reachability: _classPrivateFieldGet2(_getV6Reachability, this)
      };
      return Object.assign.apply(Object, _toConsumableArray(Object.entries(items).map(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
          key = _ref3[0],
          fn = _ref3[1];
        var val = fn();
        return val === undefined ? {} : _defineProperty({}, key, val);
      })));
    }
  }]);
}();

var round = function round(num) {
  var decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return !num ? num : Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
};
var latencyPointsParser = function latencyPointsParser(durations) {
  return durations.map(function (d) {
    return round(d, 2);
  });
};
var bpsPointsParser = function bpsPointsParser(pnts) {
  return pnts.map(function (d) {
    return {
      bytes: +d.bytes,
      bps: round(d.bps)
    };
  });
};
var packetLossParser = function packetLossParser(d) {
  return d.error ? undefined : {
    numMessages: d.numMessagesSent,
    lossRatio: round(d.packetLoss, 4)
  };
};
var resultsParsers = {
  latencyMs: ['getUnloadedLatencyPoints', latencyPointsParser],
  download: ['getDownloadBandwidthPoints', bpsPointsParser],
  upload: ['getUploadBandwidthPoints', bpsPointsParser],
  downLoadedLatencyMs: ['getDownLoadedLatencyPoints', latencyPointsParser],
  upLoadedLatencyMs: ['getUpLoadedLatencyPoints', latencyPointsParser],
  packetLoss: ['getPacketLossDetails', packetLossParser]
  // v4Reachability: ['getV4ReachabilityDetails'],
  // v6Reachability: ['getV6ReachabilityDetails']
};
var scoreParser = function scoreParser(d) {
  return {
    points: d.points,
    classification: d.classificationName
  };
};
var logAimResults = function logAimResults(results, _ref) {
  var apiUrl = _ref.apiUrl;
  var logData = {};
  Object.entries(resultsParsers).forEach(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
      logK = _ref3[0],
      _ref3$ = _slicedToArray(_ref3[1], 2),
      fn = _ref3$[0],
      _ref3$$ = _ref3$[1],
      parser = _ref3$$ === void 0 ? function (d) {
        return d;
      } : _ref3$$;
    var val = results[fn]();
    val && (logData[logK] = parser(val));
  });
  var scores = results.getScores();
  scores && (logData.scores = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(scores).map(function (_ref4) {
    var _ref5 = _slicedToArray(_ref4, 2),
      k = _ref5[0],
      score = _ref5[1];
    return _defineProperty({}, k, scoreParser(score));
  })))));
  fetch(apiUrl, {
    method: 'POST',
    body: JSON.stringify(logData)
  });
};

var _excluded = ["type"],
  _excluded2 = ["numPackets"],
  _excluded3 = ["bytes"];
var DEFAULT_OPTIMAL_DOWNLOAD_SIZE = 1e6;
var DEFAULT_OPTIMAL_UPLOAD_SIZE = 1e6;
var OPTIMAL_SIZE_RATIO = 0.5; // of largest size reached in measurement

var pausableTypes = ['latency', 'latencyUnderLoad', 'download', 'upload'];
var genMeasId = function genMeasId() {
  return "".concat(Math.round(Math.random() * 1e16));
};
var _onFinish = /*#__PURE__*/new WeakMap();
var _onError = /*#__PURE__*/new WeakMap();
var _config = /*#__PURE__*/new WeakMap();
var _results = /*#__PURE__*/new WeakMap();
var _measurementId = /*#__PURE__*/new WeakMap();
var _curMsmIdx = /*#__PURE__*/new WeakMap();
var _curEngine = /*#__PURE__*/new WeakMap();
var _optimalDownloadChunkSize = /*#__PURE__*/new WeakMap();
var _optimalUploadChunkSize = /*#__PURE__*/new WeakMap();
var _running = /*#__PURE__*/new WeakMap();
var _finished = /*#__PURE__*/new WeakMap();
var _MeasurementEngine_brand = /*#__PURE__*/new WeakSet();
var MeasurementEngine = /*#__PURE__*/function () {
  function MeasurementEngine() {
    var userConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, MeasurementEngine);
    // Internal methods
    speedtest_classPrivateMethodInitSpec(this, _MeasurementEngine_brand);
    _defineProperty(this, "onRunningChange", function () {});
    _defineProperty(this, "onResultsChange", function () {});
    speedtest_classPrivateFieldInitSpec(this, _onFinish, function () {});
    speedtest_classPrivateFieldInitSpec(this, _onError, function () {});
    // Internal state
    speedtest_classPrivateFieldInitSpec(this, _config, void 0);
    speedtest_classPrivateFieldInitSpec(this, _results, void 0);
    speedtest_classPrivateFieldInitSpec(this, _measurementId, genMeasId());
    speedtest_classPrivateFieldInitSpec(this, _curMsmIdx, -1);
    speedtest_classPrivateFieldInitSpec(this, _curEngine, void 0);
    speedtest_classPrivateFieldInitSpec(this, _optimalDownloadChunkSize, DEFAULT_OPTIMAL_DOWNLOAD_SIZE);
    speedtest_classPrivateFieldInitSpec(this, _optimalUploadChunkSize, DEFAULT_OPTIMAL_UPLOAD_SIZE);
    speedtest_classPrivateFieldInitSpec(this, _running, false);
    speedtest_classPrivateFieldInitSpec(this, _finished, false);
    _classPrivateFieldSet2(_config, this, Object.assign({}, defaultConfig, userConfig, internalConfig));
    _classPrivateFieldSet2(_results, this, new Results(_classPrivateFieldGet2(_config, this)));
    _classPrivateFieldGet2(_config, this).autoStart && this.play();
  }

  // Public attributes
  return _createClass(MeasurementEngine, [{
    key: "results",
    get: function get() {
      // read access to results
      return _classPrivateFieldGet2(_results, this);
    }
  }, {
    key: "isRunning",
    get: function get() {
      return _classPrivateFieldGet2(_running, this);
    }
  }, {
    key: "isFinished",
    get: function get() {
      return _classPrivateFieldGet2(_finished, this);
    }
  }, {
    key: "onFinish",
    set:
    // callback invoked when all the measurements are finished
    function set(f) {
      _classPrivateFieldSet2(_onFinish, this, f);
    }
  }, {
    key: "onError",
    set:
    // callback invoked if an error occurs during measurement
    function set(f) {
      _classPrivateFieldSet2(_onError, this, f);
    }

    // Public methods
  }, {
    key: "pause",
    value: function pause() {
      pausableTypes.includes(speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curType).call(this)) && _classPrivateFieldGet2(_curEngine, this).pause();
      speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setRunning).call(this, false);
    }
  }, {
    key: "play",
    value: function play() {
      if (!_classPrivateFieldGet2(_running, this)) {
        speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setRunning).call(this, true);
        speedtest_assertClassBrand(_MeasurementEngine_brand, this, _next).call(this);
      }
    }
  }, {
    key: "restart",
    value: function restart() {
      speedtest_assertClassBrand(_MeasurementEngine_brand, this, _clear).call(this);
      this.play();
    }
  }]);
}();
function _setRunning(running) {
  if (running !== _classPrivateFieldGet2(_running, this)) {
    _classPrivateFieldSet2(_running, this, running);
    this.onRunningChange(_classPrivateFieldGet2(_running, this));
  }
}
function _setFinished(finished) {
  var _this3 = this;
  if (finished !== _classPrivateFieldGet2(_finished, this)) {
    _classPrivateFieldSet2(_finished, this, finished);
    finished && setTimeout(function () {
      return _classPrivateFieldGet2(_onFinish, _this3).call(_this3, _this3.results);
    });
  }
}
function _curType() {
  return _classPrivateFieldGet2(_curMsmIdx, this) < 0 || _classPrivateFieldGet2(_curMsmIdx, this) >= _classPrivateFieldGet2(_config, this).measurements.length ? null : _classPrivateFieldGet2(_config, this).measurements[_classPrivateFieldGet2(_curMsmIdx, this)].type;
}
function _curTypeResults() {
  return _classPrivateFieldGet2(_results, this).raw[speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curType).call(this)] || undefined;
}
function _clear() {
  speedtest_assertClassBrand(_MeasurementEngine_brand, this, _destroyCurEngine).call(this);
  _classPrivateFieldSet2(_measurementId, this, genMeasId());
  _classPrivateFieldSet2(_curMsmIdx, this, -1);
  _classPrivateFieldSet2(_curEngine, this, undefined);
  speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setRunning).call(this, false);
  speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setFinished).call(this, false);
  _classPrivateFieldGet2(_results, this).clear();
}
function _destroyCurEngine() {
  var engine = _classPrivateFieldGet2(_curEngine, this);
  if (!engine) return;
  engine.onFinished = engine.onConnectionError = engine.onFail = engine.onMsgReceived = engine.onCredentialsFailure = engine.onMeasurementResult = function () {};
  pausableTypes.includes(speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curType).call(this)) && engine.pause();
}
function _next() {
  var _this4 = this;
  var _this$curMsmIdx;
  if (pausableTypes.includes(speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curType).call(this)) && speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this) && speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this).started && !speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this).finished && !speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this).finishedCurrentRound && !speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this).error) {
    _classPrivateFieldGet2(_curEngine, this).play();
    return;
  }

  // advance to next msm
  _classPrivateFieldSet2(_curMsmIdx, this, (_this$curMsmIdx = _classPrivateFieldGet2(_curMsmIdx, this), _this$curMsmIdx++, _this$curMsmIdx));
  if (_classPrivateFieldGet2(_curMsmIdx, this) >= _classPrivateFieldGet2(_config, this).measurements.length) {
    // done with measurements
    speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setRunning).call(this, false);
    speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setFinished).call(this, true);
    return;
  }
  var _classPrivateFieldGet2$1 = _classPrivateFieldGet2(_config, this).measurements[_classPrivateFieldGet2(_curMsmIdx, this)],
    type = _classPrivateFieldGet2$1.type,
    msmConfig = _objectWithoutProperties(_classPrivateFieldGet2$1, _excluded);
  var msmResults = speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this);
  var _classPrivateFieldGet3 = _classPrivateFieldGet2(_config, this),
    downloadApiUrl = _classPrivateFieldGet3.downloadApiUrl,
    uploadApiUrl = _classPrivateFieldGet3.uploadApiUrl,
    estimatedServerTime = _classPrivateFieldGet3.estimatedServerTime;
  var engine;
  switch (type) {
    case 'v4Reachability':
    case 'v6Reachability':
      engine = new ReachabilityEngine("https://".concat(msmConfig.host), {
        fetchOptions: {
          method: 'GET',
          mode: 'no-cors'
        }
      });
      engine.onFinished = function (result) {
        msmResults.finished = true;
        msmResults.results = speedtest_objectSpread2({
          host: msmConfig.host
        }, result);
        _this4.onResultsChange({
          type: type
        });
        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
      };
      break;
    case 'rpki':
      engine = new ReachabilityEngine("https://".concat(_classPrivateFieldGet2(_config, this).rpkiInvalidHost), {
        timeout: 5000
      });
      engine.onFinished = function (result) {
        (result.response ? result.response.json() : Promise.resolve()).then(function (response) {
          msmResults.finished = true;
          msmResults.results = speedtest_objectSpread2({
            host: _classPrivateFieldGet2(_config, _this4).rpkiInvalidHost,
            filteringInvalids: !result.reachable
          }, response ? {
            asn: response.asn,
            name: response.name
          } : {});
          _this4.onResultsChange({
            type: type
          });
          speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
        });
      };
      break;
    case 'nxdomain':
      engine = new ReachabilityEngine("https://".concat(msmConfig.nxhost), {
        fetchOptions: {
          mode: 'no-cors'
        }
      });
      engine.onFinished = function (result) {
        msmResults.finished = true;
        msmResults.results = {
          host: msmConfig.nxhost,
          reachable: result.reachable
        };
        _this4.onResultsChange({
          type: type
        });
        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
      };
      break;
    case 'packetLoss':
    case 'packetLossUnderLoad':
      {
        msmResults.finished = false;
        var numMsgs = msmConfig.numPackets,
          ptCfg = _objectWithoutProperties(msmConfig, _excluded2);
        var _classPrivateFieldGet4 = _classPrivateFieldGet2(_config, this),
          turnServerUri = _classPrivateFieldGet4.turnServerUri,
          turnServerCredsApi = _classPrivateFieldGet4.turnServerCredsApiUrl,
          turnServerUser = _classPrivateFieldGet4.turnServerUser,
          turnServerPass = _classPrivateFieldGet4.turnServerPass,
          includeCredentials = _classPrivateFieldGet4.includeCredentials;
        engine = new PacketLossUnderLoadEngine(speedtest_objectSpread2({
          turnServerUri: turnServerUri,
          turnServerCredsApi: turnServerCredsApi,
          turnServerCredsApiIncludeCredentials: includeCredentials,
          turnServerUser: turnServerUser,
          turnServerPass: turnServerPass,
          numMsgs: numMsgs,
          // if under load
          downloadChunkSize: msmConfig.loadDown ? _classPrivateFieldGet2(_optimalDownloadChunkSize, this) : undefined,
          uploadChunkSize: msmConfig.loadUp ? _classPrivateFieldGet2(_optimalUploadChunkSize, this) : undefined,
          downloadApiUrl: downloadApiUrl,
          uploadApiUrl: uploadApiUrl
        }, ptCfg));
      }
      engine.onMsgReceived = function () {
        msmResults.results = Object.assign({}, engine.results);
        _this4.onResultsChange({
          type: type
        });
      };
      engine.onFinished = function () {
        msmResults.finished = true;
        _this4.onResultsChange({
          type: type
        });
        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
      };
      engine.onConnectionError = function (e) {
        msmResults.error = e;
        _this4.onResultsChange({
          type: type
        });
        _classPrivateFieldGet2(_onError, _this4).call(_this4, "Connection error while measuring packet loss: ".concat(e));
        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
      };
      engine.onCredentialsFailure = function () {
        msmResults.error = 'unable to get turn server credentials';
        _this4.onResultsChange({
          type: type
        });
        _classPrivateFieldGet2(_onError, _this4).call(_this4, 'Error while measuring packet loss: unable to get turn server credentials.');
        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
      };
      break;
    case 'latency':
    case 'latencyUnderLoad':
      msmResults.finished = false;
      engine = new LoggingBandwidthEngine([{
        dir: 'down',
        bytes: 0,
        count: msmConfig.numPackets,
        bypassMinDuration: true
      }], {
        downloadApiUrl: downloadApiUrl,
        uploadApiUrl: uploadApiUrl,
        estimatedServerTime: estimatedServerTime,
        logApiUrl: _classPrivateFieldGet2(_config, this).logMeasurementApiUrl,
        measurementId: _classPrivateFieldGet2(_measurementId, this),
        // if under load
        downloadChunkSize: msmConfig.loadDown ? _classPrivateFieldGet2(_optimalDownloadChunkSize, this) : undefined,
        uploadChunkSize: msmConfig.loadUp ? _classPrivateFieldGet2(_optimalUploadChunkSize, this) : undefined
      });
      engine.fetchOptions = {
        credentials: _classPrivateFieldGet2(_config, this).includeCredentials ? 'include' : undefined
      };
      engine.onMeasurementResult = engine.onNewMeasurementStarted = function (meas, results) {
        msmResults.results = Object.assign({}, results.down[0]);
        _this4.onResultsChange({
          type: type
        });
      };
      engine.onFinished = function () {
        msmResults.finished = true;
        _this4.onResultsChange({
          type: type
        });
        _classPrivateFieldGet2(_running, _this4) && speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
      };
      engine.onConnectionError = function (e) {
        msmResults.error = e;
        _this4.onResultsChange({
          type: type
        });
        _classPrivateFieldGet2(_onError, _this4).call(_this4, "Connection error while measuring latency: ".concat(e));
        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
      };
      engine.play();
      break;
    case 'download':
    case 'upload':
      if (msmResults.finished || msmResults.error) {
        speedtest_assertClassBrand(_MeasurementEngine_brand, this, _next).call(this); // skip, already concluded this bandwidth measurement type
      } else {
        delete msmResults.finishedCurrentRound;
        var measureParallelLatency = _classPrivateFieldGet2(_config, this)["measure".concat(type === 'download' ? 'Down' : 'Up', "loadLoadedLatency")];
        engine = new LoggingBandwidthEngine([speedtest_objectSpread2({
          dir: type === 'download' ? 'down' : 'up'
        }, msmConfig)], {
          downloadApiUrl: downloadApiUrl,
          uploadApiUrl: uploadApiUrl,
          estimatedServerTime: estimatedServerTime,
          logApiUrl: _classPrivateFieldGet2(_config, this).logMeasurementApiUrl,
          measurementId: _classPrivateFieldGet2(_measurementId, this),
          measureParallelLatency: measureParallelLatency,
          parallelLatencyThrottleMs: _classPrivateFieldGet2(_config, this).loadedLatencyThrottle
        });
        engine.fetchOptions = {
          credentials: _classPrivateFieldGet2(_config, this).includeCredentials ? 'include' : undefined
        };
        engine.finishRequestDuration = _classPrivateFieldGet2(_config, this).bandwidthFinishRequestDuration;
        engine.onNewMeasurementStarted = function (_ref) {
          var count = _ref.count,
            bytes = _ref.bytes;
          var res = msmResults.results = Object.assign({}, msmResults.results);
          !res.hasOwnProperty(bytes) && (res[bytes] = {
            timings: [],
            numMeasurements: 0,
            sideLatency: measureParallelLatency ? [] : undefined
          });

          // check if count hasn't already been added
          if (res[bytes].numMeasurements - res[bytes].timings.length !== count) {
            res[bytes].numMeasurements += count;
            _this4.onResultsChange({
              type: type
            });
          }
        };
        engine.onMeasurementResult = function (_ref2) {
          var bytes = _ref2.bytes,
            timing = _objectWithoutProperties(_ref2, _excluded3);
          // merge in new result
          msmResults.results[bytes].timings.push(timing);
          msmResults.results = Object.assign({}, msmResults.results);
          _this4.onResultsChange({
            type: type
          });
        };
        engine.onParallelLatencyResult = function (res) {
          // merge in new latency result
          msmResults.results[msmConfig.bytes].sideLatency.push(res);
          msmResults.results = Object.assign({}, msmResults.results);
          _this4.onResultsChange({
            type: type
          });
        };
        engine.onFinished = function (results) {
          var isLastMsmOfType = !_classPrivateFieldGet2(_config, _this4).measurements.slice(_classPrivateFieldGet2(_curMsmIdx, _this4) + 1).map(function (d) {
            return d.type;
          }).includes(type);
          var minDuration = Math.min.apply(Math, _toConsumableArray(Object.values(type === 'download' ? results.down : results.up).slice(-1)[0].timings.map(function (d) {
            return d.duration;
          })));
          var reachedEndOfMsmType = isLastMsmOfType || !msmConfig.bypassMinDuration && minDuration > _classPrivateFieldGet2(_config, _this4).bandwidthFinishRequestDuration;
          if (!reachedEndOfMsmType) {
            msmResults.finishedCurrentRound = true;
          } else {
            msmResults.finished = true;
            _this4.onResultsChange({
              type: type
            });

            // record optimal load size
            var largestSize = Object.keys(msmResults.results).map(function (n) {
              return +n;
            }).sort(function (a, b) {
              return b - a;
            })[0];
            var optimalSize = largestSize * OPTIMAL_SIZE_RATIO;
            type === 'download' && _classPrivateFieldSet2(_optimalDownloadChunkSize, _this4, optimalSize);
            type === 'upload' && _classPrivateFieldSet2(_optimalUploadChunkSize, _this4, optimalSize);
          }
          _classPrivateFieldGet2(_running, _this4) && speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
        };
        engine.onConnectionError = function (e) {
          msmResults.error = e;
          _this4.onResultsChange({
            type: type
          });
          _classPrivateFieldGet2(_onError, _this4).call(_this4, "Connection error while measuring ".concat(type, ": ").concat(e));
          speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
        };
        engine.play();
      }
      break;
  }
  _classPrivateFieldSet2(_curEngine, this, engine);
  msmResults.started = true;
  this.onResultsChange({
    type: type
  });
}
var _logAimApiUrl = /*#__PURE__*/new WeakMap();
var _logFinalResults = /*#__PURE__*/new WeakMap();
var LoggingMeasurementEngine = /*#__PURE__*/function (_MeasurementEngine2) {
  function LoggingMeasurementEngine(userConfig) {
    var _this;
    _classCallCheck(this, LoggingMeasurementEngine);
    for (var _len = arguments.length, pt = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      pt[_key - 1] = arguments[_key];
    }
    _this = speedtest_callSuper(this, LoggingMeasurementEngine, [userConfig].concat(pt));
    // Internal state
    speedtest_classPrivateFieldInitSpec(_this, _logAimApiUrl, void 0);
    // Internal methods
    speedtest_classPrivateFieldInitSpec(_this, _logFinalResults, function (results) {
      _classPrivateFieldGet2(_logAimApiUrl, _this) && logAimResults(results, {
        apiUrl: _classPrivateFieldGet2(_logAimApiUrl, _this)
      });
    });
    _superPropSet((LoggingMeasurementEngine), "onFinish", _classPrivateFieldGet2(_logFinalResults, _this), _this, 1);
    _classPrivateFieldSet2(_logAimApiUrl, _this, Object.assign({}, defaultConfig, userConfig, internalConfig).logAimApiUrl);
    return _this;
  }

  // Public attributes
  _inherits(LoggingMeasurementEngine, _MeasurementEngine2);
  return _createClass(LoggingMeasurementEngine, [{
    key: "onFinish",
    set: function set(onFinish) {
      var _this2 = this;
      _superPropSet(LoggingMeasurementEngine, "onFinish", function (results) {
        onFinish(results);
        _classPrivateFieldGet2(_logFinalResults, _this2).call(_this2, results);
      }, this, 1);
    }
  }]);
}(MeasurementEngine);



// EXTERNAL MODULE: ./src/e2ee/KeyProvider.js
var KeyProvider = __webpack_require__(9633);
// EXTERNAL MODULE: ./src/constants/reliabilityModes.js
var reliabilityModes = __webpack_require__(2067);
;// ./src/index.js





function src_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = src_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function src_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return src_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? src_arrayLikeToArray(r, a) : void 0; } }
function src_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }







// import deviceInfo from "./lib/deviceInfo";














var reduxMiddlewares = [es];
var deviceChangeEventRegistered = false;





var VideoSDK = /*#__PURE__*/function () {
  function VideoSDK() {
    (0,classCallCheck/* default */.A)(this, VideoSDK);
    (0,defineProperty/* default */.A)(this, "keyProvider", null);
  }
  return (0,createClass/* default */.A)(VideoSDK, null, [{
    key: "setKeyProvider",
    value:
    /**
     * @param {ExternalE2EEKeyProvider} keyProvider
     */
    function setKeyProvider(keyProvider) {
      this.keyProvider = keyProvider;
    }

    /**
     * @returns {ExternalE2EEKeyProvider}
     */
  }, {
    key: "getKeyProvider",
    value: function getKeyProvider() {
      return this.keyProvider;
    }
    /**
     * Configure SDK with apiKey.
     * @param {string} apiKey
     */
  }, {
    key: "config",
    value: function config(apiKey) {
      if (!apiKey) {
        throw new Error("'token' is empty, please provide it in config");
      }
      this.apiKey = apiKey;
      var store = createStore(redux_reducers, undefined, applyMiddleware.apply(void 0, reduxMiddlewares));
      window.STORE = store;
      RoomClient["default"].init({
        store: store
      });
    }

    /**
     *
     * @returns {Promise<Array<CameraDeviceInfo>>}
     */
  }, {
    key: "getCameras",
    value: (function () {
      var _getCameras = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2() {
        var isFirefox, cameras, devices, message, _t;
        return regenerator_default().wrap(function (_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              isFirefox = navigator.userAgent.includes("Firefox");
              cameras = [];
              if (!isFirefox) {
                _context2.next = 2;
                break;
              }
              _context2.next = 1;
              return new Promise(function (resolve, reject) {
                navigator.mediaDevices.getUserMedia({
                  audio: false,
                  video: true
                }).then(/*#__PURE__*/function () {
                  var _ref = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(stream) {
                    var devices;
                    return regenerator_default().wrap(function (_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 1;
                          return navigator.mediaDevices.enumerateDevices();
                        case 1:
                          devices = _context.sent;
                          cameras = devices.filter(function (device) {
                            return device.kind === "videoinput";
                          }).map(function (device) {
                            return new CameraDeviceInfo(device.deviceId, device.groupId, device.kind, device.label);
                          });
                          resolve(cameras);
                          stream.getTracks().forEach(function (track) {
                            return track.stop();
                          });
                        case 2:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee);
                  }));
                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }())["catch"](function (error) {
                  console.error("Error in getCameras()", error);
                  reject(error);
                });
              });
            case 1:
              _context2.next = 4;
              break;
            case 2:
              _context2.next = 3;
              return navigator.mediaDevices.enumerateDevices();
            case 3:
              devices = _context2.sent;
              cameras = devices.filter(function (device) {
                return device.kind === "videoinput";
              }).map(function (device) {
                return new CameraDeviceInfo(device.deviceId, device.groupId, device.kind, device.label);
              });
            case 4:
              return _context2.abrupt("return", cameras);
            case 5:
              _context2.prev = 5;
              _t = _context2["catch"](0);
              message = _t.message;
              if (_t instanceof TypeError && _t.name === "TypeError") {
                message = errors/* sdkErrors */.q.ERROR_CAMERA_ACCESS_UNAVAILABLE.message;
              }
              console.error("An error occurred in getCameras(), ".concat(message));
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[0, 5]]);
      }));
      function getCameras() {
        return _getCameras.apply(this, arguments);
      }
      return getCameras;
    }()
    /**
     *
     * @returns {Promise<Array<MicrophoneDeviceInfo>>}
     */
    )
  }, {
    key: "getMicrophones",
    value: (function () {
      var _getMicrophones = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee4() {
        var isFirefox, microphones, devices, message, _t2;
        return regenerator_default().wrap(function (_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              isFirefox = navigator.userAgent.includes("Firefox");
              microphones = [];
              if (!isFirefox) {
                _context4.next = 2;
                break;
              }
              _context4.next = 1;
              return new Promise(function (resolve, reject) {
                navigator.mediaDevices.getUserMedia({
                  audio: true,
                  video: false
                }).then(/*#__PURE__*/function () {
                  var _ref2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee3(stream) {
                    var devices;
                    return regenerator_default().wrap(function (_context3) {
                      while (1) switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 1;
                          return navigator.mediaDevices.enumerateDevices();
                        case 1:
                          devices = _context3.sent;
                          microphones = devices.filter(function (device) {
                            return device.kind === "audioinput";
                          }).map(function (device) {
                            return new MicrophoneDeviceInfo(device.deviceId, device.groupId, device.kind, device.label);
                          });
                          resolve(microphones);
                          stream.getTracks().forEach(function (track) {
                            return track.stop();
                          });
                        case 2:
                        case "end":
                          return _context3.stop();
                      }
                    }, _callee3);
                  }));
                  return function (_x2) {
                    return _ref2.apply(this, arguments);
                  };
                }())["catch"](function (error) {
                  console.error("Error in getMicrophones()", error);
                  reject(error);
                });
              });
            case 1:
              _context4.next = 4;
              break;
            case 2:
              _context4.next = 3;
              return navigator.mediaDevices.enumerateDevices();
            case 3:
              devices = _context4.sent;
              microphones = devices.filter(function (device) {
                return device.kind === "audioinput";
              }).map(function (device) {
                return new MicrophoneDeviceInfo(device.deviceId, device.groupId, device.kind, device.label);
              });
            case 4:
              return _context4.abrupt("return", microphones);
            case 5:
              _context4.prev = 5;
              _t2 = _context4["catch"](0);
              message = _t2.message;
              if (_t2 instanceof TypeError && _t2.name === "TypeError") {
                message = errors/* sdkErrors */.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE.message;
              }
              console.error("An error occurred in getMicrophones(), ".concat(message));
            case 6:
            case "end":
              return _context4.stop();
          }
        }, _callee4, null, [[0, 5]]);
      }));
      function getMicrophones() {
        return _getMicrophones.apply(this, arguments);
      }
      return getMicrophones;
    }()
    /**
     *
     * @returns {Promise<Array<PlaybackDeviceInfo>>}
     */
    )
  }, {
    key: "getPlaybackDevices",
    value: (function () {
      var _getPlaybackDevices = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee6() {
        var isFirefox, playbackDevices, devices, message, _t3;
        return regenerator_default().wrap(function (_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              isFirefox = navigator.userAgent.includes("Firefox");
              playbackDevices = [];
              if (!isFirefox) {
                _context6.next = 2;
                break;
              }
              _context6.next = 1;
              return new Promise(function (resolve, reject) {
                navigator.mediaDevices.getUserMedia({
                  audio: true,
                  video: false
                }).then(/*#__PURE__*/function () {
                  var _ref3 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee5(stream) {
                    var devices;
                    return regenerator_default().wrap(function (_context5) {
                      while (1) switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 1;
                          return navigator.mediaDevices.enumerateDevices();
                        case 1:
                          devices = _context5.sent;
                          playbackDevices = devices.filter(function (device) {
                            return device.kind === "audiooutput";
                          }).map(function (device) {
                            return new PlaybackDeviceInfo(device.deviceId, device.groupId, device.kind, device.label);
                          });
                          resolve(playbackDevices);
                          stream.getTracks().forEach(function (track) {
                            return track.stop();
                          });
                        case 2:
                        case "end":
                          return _context5.stop();
                      }
                    }, _callee5);
                  }));
                  return function (_x3) {
                    return _ref3.apply(this, arguments);
                  };
                }())["catch"](function (error) {
                  console.error("Error in getPlaybackDevices()", error);
                  reject(error);
                });
              });
            case 1:
              _context6.next = 4;
              break;
            case 2:
              _context6.next = 3;
              return navigator.mediaDevices.enumerateDevices();
            case 3:
              devices = _context6.sent;
              playbackDevices = devices.filter(function (device) {
                return device.kind === "audiooutput";
              }).map(function (device) {
                return new PlaybackDeviceInfo(device.deviceId, device.groupId, device.kind, device.label);
              });
            case 4:
              return _context6.abrupt("return", playbackDevices);
            case 5:
              _context6.prev = 5;
              _t3 = _context6["catch"](0);
              message = _t3.message;
              if (_t3 instanceof TypeError && _t3.name === "TypeError") {
                message = "Playback device access unavailable: Please ensure your device is compatible and that you're on a secure website (https://)";
              }
              console.error("An error occurred in getPlaybackDevices(), ".concat(message));
            case 6:
            case "end":
              return _context6.stop();
          }
        }, _callee6, null, [[0, 5]]);
      }));
      function getPlaybackDevices() {
        return _getPlaybackDevices.apply(this, arguments);
      }
      return getPlaybackDevices;
    }()
    /**
     *
     * @returns {Promise<Array<DeviceInfo>>}
     */
    )
  }, {
    key: "getDevices",
    value: (function () {
      var _getDevices = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee7() {
        var devices, mediaDevices, _iterator, _step, device, message, _t4;
        return regenerator_default().wrap(function (_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 1;
              return navigator.mediaDevices.enumerateDevices();
            case 1:
              devices = _context7.sent;
              mediaDevices = [];
              _iterator = src_createForOfIteratorHelper(devices);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  device = _step.value;
                  mediaDevices.push(new DeviceInfo(device.deviceId, device.groupId, device.kind, device.label));
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return _context7.abrupt("return", mediaDevices);
            case 2:
              _context7.prev = 2;
              _t4 = _context7["catch"](0);
              message = _t4.message;
              if (_t4 instanceof TypeError) {
                if (_t4.name === "TypeError") {
                  message = "Could not access devices : Please ensure your devices is compatible and that you're on a secure website (https://)";
                } else {
                  message = _t4.message;
                }
              }
              console.error("An error occurred in getDevices(), ".concat(message));
            case 3:
            case "end":
              return _context7.stop();
          }
        }, _callee7, null, [[0, 2]]);
      }));
      function getDevices() {
        return _getDevices.apply(this, arguments);
      }
      return getDevices;
    }()
    /**
     * Add event listener
     * @param { "device-changed" } eventType
     * @param {Function} listener Callback function
     */
    )
  }, {
    key: "on",
    value: function on(eventType, listener) {
      switch (eventType) {
        case "device-changed":
          this.addDeviceChangeEvent();
          this.eventEmitter.on(eventType, listener);
          break;
        default:
          throw new Error("Unsupported event type");
      }
    }
  }, {
    key: "addDeviceChangeEvent",
    value: function addDeviceChangeEvent() {
      var _this = this;
      if (!deviceChangeEventRegistered) {
        this.getDevices().then(function (devices) {
          _this.devices = devices;
        });
        try {
          navigator.mediaDevices.addEventListener("devicechange", /*#__PURE__*/function () {
            var _ref4 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee8(e) {
              var oldList, newDevices, _iterator2, _step2, _loop, _t5;
              return regenerator_default().wrap(function (_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    oldList = _this.devices;
                    _context9.next = 1;
                    return _this.getDevices();
                  case 1:
                    _this.devices = _context9.sent;
                    newDevices = new Array();
                    _iterator2 = src_createForOfIteratorHelper(_this.devices);
                    _context9.prev = 2;
                    _loop = /*#__PURE__*/regenerator_default().mark(function _loop() {
                      var device, oldDevice;
                      return regenerator_default().wrap(function (_context8) {
                        while (1) switch (_context8.prev = _context8.next) {
                          case 0:
                            device = _step2.value;
                            oldDevice = oldList.filter(function (old) {
                              return old.deviceId == device.deviceId && old.kind == device.kind;
                            });
                            if (oldDevice.length == 0) {
                              // new device connected
                              newDevices.push(device);
                            } else {
                              //remove this device from old list so that the old list will have remove devices at the end
                              oldList = oldList.filter(function (old) {
                                return !(old.deviceId == device.deviceId && old.kind == device.kind);
                              });
                            }
                          case 1:
                          case "end":
                            return _context8.stop();
                        }
                      }, _loop);
                    });
                    _iterator2.s();
                  case 3:
                    if ((_step2 = _iterator2.n()).done) {
                      _context9.next = 5;
                      break;
                    }
                    return _context9.delegateYield(_loop(), "t0", 4);
                  case 4:
                    _context9.next = 3;
                    break;
                  case 5:
                    _context9.next = 7;
                    break;
                  case 6:
                    _context9.prev = 6;
                    _t5 = _context9["catch"](2);
                    _iterator2.e(_t5);
                  case 7:
                    _context9.prev = 7;
                    _iterator2.f();
                    return _context9.finish(7);
                  case 8:
                    if (newDevices.length != 0) {
                      _this.eventEmitter.emit("device-changed", {
                        devices: _this.devices
                      });
                    }
                    if (oldList.length != 0) {
                      _this.eventEmitter.emit("device-changed", {
                        devices: _this.devices
                      });
                    }
                  case 9:
                  case "end":
                    return _context9.stop();
                }
              }, _callee8, null, [[2, 6, 7, 8]]);
            }));
            return function (_x4) {
              return _ref4.apply(this, arguments);
            };
          }());
          deviceChangeEventRegistered = true;
        } catch (error) {
          var message = error.message;
          if (error instanceof TypeError) {
            if (error.name === "TypeError") {
              message = "Could not access devices : Please ensure your devices is compatible and that you're on a secure website (https://)";
            } else {
              message = error.message;
            }
          }
          console.error("An error occurred in device-change event, ".concat(message));
        }
      }
    }

    /**
     * Remove event listener
     * @param { "device-changed" } eventType
     * @param {Function} listener Callback function
     */
  }, {
    key: "off",
    value: function off(eventType, listener) {
      switch (eventType) {
        case "device-changed":
          this.eventEmitter.off(eventType, listener);
          break;
        default:
          throw new Error("Unsupported event type");
          // removed by dead control flow

      }
    }

    /**
     *
     * @param {Permission} permissions
     * @returns {Promise<Map<string, boolean>>}
     */
  }, {
    key: "checkPermissions",
    value: (function () {
      var _checkPermissions = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee9(permissions) {
        var permissionMap, allowed, res, _allowed, _res, _t6, _t7;
        return regenerator_default().wrap(function (_context0) {
          while (1) switch (_context0.prev = _context0.next) {
            case 0:
              if (!permissions) {
                permissions = Permission.AUDIO_AND_VIDEO;
              }
              permissionMap = new Map();
              if (!(permissions.includes(Permission.AUDIO) || permissions.includes(Permission.AUDIO_AND_VIDEO))) {
                _context0.next = 5;
                break;
              }
              allowed = true;
              _context0.prev = 1;
              _context0.next = 2;
              return navigator.permissions.query({
                name: "microphone"
              });
            case 2:
              res = _context0.sent;
              if (res.state == "prompt" || res.state == "denied") allowed = false;
              _context0.next = 4;
              break;
            case 3:
              _context0.prev = 3;
              _t6 = _context0["catch"](1);
              throw Error("Browser does not support microphone permission check");
            case 4:
              permissionMap.set(Permission.AUDIO, allowed);
            case 5:
              if (!(permissions.includes(Permission.VIDEO) || permissions.includes(Permission.AUDIO_AND_VIDEO))) {
                _context0.next = 10;
                break;
              }
              _allowed = true;
              _context0.prev = 6;
              _context0.next = 7;
              return navigator.permissions.query({
                name: "camera"
              });
            case 7:
              _res = _context0.sent;
              if (_res.state == "prompt" || _res.state == "denied") _allowed = false;
              _context0.next = 9;
              break;
            case 8:
              _context0.prev = 8;
              _t7 = _context0["catch"](6);
              throw Error("Browser does not support camera permission check");
            case 9:
              permissionMap.set(Permission.VIDEO, _allowed);
            case 10:
              return _context0.abrupt("return", permissionMap);
            case 11:
            case "end":
              return _context0.stop();
          }
        }, _callee9, null, [[1, 3], [6, 8]]);
      }));
      function checkPermissions(_x5) {
        return _checkPermissions.apply(this, arguments);
      }
      return checkPermissions;
    }()
    /**
     *
     * @param {Permission} permissions
     * @returns {Promise<Map<string, boolean>>}
     */
    )
  }, {
    key: "requestPermission",
    value: (function () {
      var _requestPermission = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee0(permissions) {
        var permissionMap, mediaStream, constraints, permissionGranted, message, videoMediaStream, _constraints, _permissionGranted, _message, audioMediaStream, _constraints2, _permissionGranted2, _message2, _t8, _t9, _t0, _t1, _t10, _t11;
        return regenerator_default().wrap(function (_context1) {
          while (1) switch (_context1.prev = _context1.next) {
            case 0:
              if (!permissions) {
                permissions = Permission.AUDIO_AND_VIDEO;
              }
              permissionMap = new Map();
              if (!permissions.includes(Permission.AUDIO_AND_VIDEO)) {
                _context1.next = 12;
                break;
              }
              constraints = {
                audio: true,
                video: true
              };
              permissionGranted = true;
              _context1.prev = 1;
              _context1.next = 2;
              return navigator.mediaDevices.getUserMedia(constraints);
            case 2:
              mediaStream = _context1.sent;
              _context1.next = 11;
              break;
            case 3:
              _context1.prev = 3;
              _t8 = _context1["catch"](1);
              if (!(_t8 instanceof DOMException)) {
                _context1.next = 9;
                break;
              }
              _t9 = _t8.name;
              _context1.next = _t9 === "NotAllowedError" ? 4 : _t9 === "NotReadableError" ? 5 : _t9 === "NotFoundError" ? 6 : 7;
              break;
            case 4:
              if (_t8.message === "Permission denied by system") {
                message = errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
              }
              return _context1.abrupt("continue", 8);
            case 5:
              message = handleNotReadableError(_t8, "video");
              return _context1.abrupt("continue", 8);
            case 6:
              message = errors/* sdkErrors */.q.ERROR_CAMERA_NOT_FOUND.message;
              if (navigator && navigator.userAgent) {
                if (navigator.userAgent.indexOf("Firefox") != -1) {
                  // Occurs when camera is not accessed by the firefox browser, and browser ask for the camera permission
                  message = errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
                }
              }
              return _context1.abrupt("continue", 8);
            case 7:
              message = _t8.message;
            case 8:
              _context1.next = 10;
              break;
            case 9:
              if (_t8 instanceof TypeError) {
                if (_t8.name === "TypeError") {
                  message = errors/* sdkErrors */.q.ERROR_CAMERA_ACCESS_UNAVAILABLE.message;
                } else {
                  message = _t8.message;
                }
              } else {
                message = _t8.message;
              }
            case 10:
              permissionGranted = false;
              if (message) console.error("An error occurred in request permission, ".concat(message));
            case 11:
              if (mediaStream) {
                setTimeout(function () {
                  mediaStream.getTracks().forEach(function (track) {
                    track.stop();
                  });
                }, 100);
              }
              permissionMap.set(Permission.AUDIO_AND_VIDEO, permissionGranted);
            case 12:
              if (!permissions.includes(Permission.VIDEO)) {
                _context1.next = 24;
                break;
              }
              _constraints = {
                audio: false,
                video: true
              };
              _permissionGranted = true;
              _context1.prev = 13;
              _context1.next = 14;
              return navigator.mediaDevices.getUserMedia(_constraints);
            case 14:
              videoMediaStream = _context1.sent;
              _context1.next = 23;
              break;
            case 15:
              _context1.prev = 15;
              _t0 = _context1["catch"](13);
              if (!(_t0 instanceof DOMException)) {
                _context1.next = 21;
                break;
              }
              _t1 = _t0.name;
              _context1.next = _t1 === "NotAllowedError" ? 16 : _t1 === "NotReadableError" ? 17 : _t1 === "NotFoundError" ? 18 : 19;
              break;
            case 16:
              if (_t0.message === "Permission denied by system") {
                _message = errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
              }
              return _context1.abrupt("continue", 20);
            case 17:
              _message = handleNotReadableError(_t0, "video");
              return _context1.abrupt("continue", 20);
            case 18:
              _message = errors/* sdkErrors */.q.ERROR_CAMERA_NOT_FOUND.message;
              if (navigator && navigator.userAgent) {
                if (navigator.userAgent.indexOf("Firefox") != -1) {
                  // Occurs when camera is not accessed by the firefox browser, and browser ask for the camera permission
                  _message = errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
                }
              }
              return _context1.abrupt("continue", 20);
            case 19:
              _message = _t0.message;
            case 20:
              _context1.next = 22;
              break;
            case 21:
              if (_t0 instanceof TypeError) {
                if (_t0.name === "TypeError") {
                  _message = errors/* sdkErrors */.q.ERROR_CAMERA_ACCESS_UNAVAILABLE.message;
                } else {
                  _message = _t0.message;
                }
              } else {
                _message = _t0.message;
              }
            case 22:
              _permissionGranted = false;
              if (_message) console.error("An error occurred in request permission, ".concat(_message));
            case 23:
              if (videoMediaStream) {
                videoMediaStream.getTracks().forEach(function (track) {
                  track.stop();
                });
              }
              permissionMap.set(Permission.VIDEO, _permissionGranted);
            case 24:
              if (!permissions.includes(Permission.AUDIO)) {
                _context1.next = 36;
                break;
              }
              _constraints2 = {
                audio: true,
                video: false
              };
              _permissionGranted2 = true;
              _context1.prev = 25;
              _context1.next = 26;
              return navigator.mediaDevices.getUserMedia(_constraints2);
            case 26:
              audioMediaStream = _context1.sent;
              _context1.next = 35;
              break;
            case 27:
              _context1.prev = 27;
              _t10 = _context1["catch"](25);
              if (!(_t10 instanceof DOMException)) {
                _context1.next = 33;
                break;
              }
              _t11 = _t10.name;
              _context1.next = _t11 === "NotAllowedError" ? 28 : _t11 === "NotReadableError" ? 29 : _t11 === "NotFoundError" ? 30 : 31;
              break;
            case 28:
              if (_t10.message === "Permission denied by system") {
                _message2 = errors/* sdkErrors */.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS.message;
              }
              return _context1.abrupt("continue", 32);
            case 29:
              _message2 = handleNotReadableError(_t10, "audio");
              return _context1.abrupt("continue", 32);
            case 30:
              _message2 = errors/* sdkErrors */.q.ERROR_MICROPHONE_NOT_FOUND.message;
              if (navigator && navigator.userAgent) {
                if (navigator.userAgent.indexOf("Firefox") != -1) {
                  // Occurs when microphone is not accessed by the firefox browser, and browser ask for the microphone permission
                  _message2 = errors/* sdkErrors */.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS.message;
                }
              }
              return _context1.abrupt("continue", 32);
            case 31:
              _message2 = _t10.message;
            case 32:
              _context1.next = 34;
              break;
            case 33:
              if (_t10 instanceof TypeError) {
                if (_t10.name === "TypeError") {
                  _message2 = errors/* sdkErrors */.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE.message;
                } else {
                  _message2 = _t10.message;
                }
              } else {
                _message2 = _t10.message;
              }
            case 34:
              _permissionGranted2 = false;
              if (_message2) console.error("An error occurred in request permission, ".concat(_message2));
            case 35:
              if (audioMediaStream) {
                audioMediaStream.getTracks().forEach(function (track) {
                  track.stop();
                });
              }
              permissionMap.set(Permission.AUDIO, _permissionGranted2);
            case 36:
              return _context1.abrupt("return", permissionMap);
            case 37:
            case "end":
              return _context1.stop();
          }
        }, _callee0, null, [[1, 3], [13, 15], [25, 27]]);
      }));
      function requestPermission(_x6) {
        return _requestPermission.apply(this, arguments);
      }
      return requestPermission;
    }())
  }, {
    key: "isInt",
    value: function isInt(x) {
      return typeof x === "number" && x % 1 == 0;
    }
    /**
     * @param {{
     * timeoutDuration ?: number | undefined,
     * }}
     * @returns {Promise<{downloadSpeed: number,uploadSpeed: number}> }
     */
  }, {
    key: "getNetworkStats",
    value: (function () {
      var _getNetworkStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee1() {
        var _ref5,
          timeoutDuration,
          _ref5$baseUrl,
          baseUrl,
          timeoutPromise,
          statsPromise,
          _args10 = arguments;
        return regenerator_default().wrap(function (_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _ref5 = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : {}, timeoutDuration = _ref5.timeoutDuration, _ref5$baseUrl = _ref5.baseUrl, baseUrl = _ref5$baseUrl === void 0 ? "api.videosdk.live" : _ref5$baseUrl;
              if (!timeoutDuration || !this.isInt(timeoutDuration)) {
                timeoutDuration = 60000; // default 1 min
              }
              timeoutPromise = new Promise(function (resolve, reject) {
                setTimeout(function () {
                  reject("Not able to get NetworkStats due to timeout");
                }, timeoutDuration);
              });
              statsPromise = new Promise(function (resolve, reject) {
                if (!navigator.onLine) {
                  reject("Not able to get NetworkStats due to no Network");
                  return;
                }
                var speedTest = new LoggingMeasurementEngine({
                  measureDownloadLoadedLatency: false,
                  measureUploadLoadedLatency: false,
                  measurements: [{
                    type: "upload",
                    bytes: 3e6,
                    count: 1,
                    bypassMinDuration: true
                  }, {
                    type: "download",
                    bytes: 3e6,
                    count: 1,
                    bypassMinDuration: true
                  }],
                  uploadApiUrl: "https://".concat(baseUrl, "/test-upload-speed"),
                  downloadApiUrl: "https://".concat(baseUrl, "/test-download-speed")
                });
                if (!speedTest.isRunning) {
                  reject("Not able to get NetworkStats");
                  return;
                }
                speedTest.onFinish = function (results) {
                  resolve({
                    downloadSpeed: parseFloat(Number(results.getDownloadBandwidth() / 1048576).toFixed(2)),
                    uploadSpeed: parseFloat(Number(results.getUploadBandwidth() / 1048576).toFixed(2))
                  });
                };
                speedTest.onError = function (e) {
                  reject("Not able to get NetworkStats");
                  return;
                };
              });
              return _context10.abrupt("return", Promise.race([statsPromise, timeoutPromise]));
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee1, this);
      }));
      function getNetworkStats() {
        return _getNetworkStats.apply(this, arguments);
      }
      return getNetworkStats;
    }()
    /**
     * @param {{
     * timeoutDuration ?: number | undefined,
     * }}
     * @returns {Promise<string> }
     */
    )
  }, {
    key: "checkConnection",
    value: (function () {
      var _checkConnection = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee10() {
        var _ref6,
          timeoutDuration,
          _ref6$baseUrl,
          baseUrl,
          timeoutPromise,
          connectionPromise,
          _args11 = arguments;
        return regenerator_default().wrap(function (_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _ref6 = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {}, timeoutDuration = _ref6.timeoutDuration, _ref6$baseUrl = _ref6.baseUrl, baseUrl = _ref6$baseUrl === void 0 ? "api.videosdk.live" : _ref6$baseUrl;
              if (!timeoutDuration || !this.isInt(timeoutDuration)) {
                timeoutDuration = 60000; // default 1 min
              }
              timeoutPromise = new Promise(function (resolve, reject) {
                setTimeout(function () {
                  reject("TimeoutError: NetworkStats timeout");
                }, timeoutDuration);
              });
              connectionPromise = new Promise(function (resolve, reject) {
                if (!navigator.onLine) {
                  reject("NetworkError: Offline");
                  return;
                }
                fetch("https://".concat(baseUrl, "/ping")).then(function (response) {
                  response.text().then(function (text) {
                    if (text == "pong") {
                      resolve("Connection established");
                    } else {
                      reject("ConnectionError: Server unreachable");
                    }
                  });
                })["catch"](function (error) {
                  reject("ConnectionError: Server unreachable");
                });
              });
              return _context11.abrupt("return", Promise.race([connectionPromise, timeoutPromise]));
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee10, this);
      }));
      function checkConnection() {
        return _checkConnection.apply(this, arguments);
      }
      return checkConnection;
    }())
  }, {
    key: "analytics",
    value: function analytics(params) {
      var _parsedUserAgent;
      var _userAgent, parsedUserAgent;
      //default pramas if not provided.
      if (!params && navigator && navigator.userAgent) {
        _userAgent = navigator.userAgent;
        parsedUserAgent = es5_default().parse(_userAgent);
        //delete engine field from parsed object
        delete parsedUserAgent.engine;
      }
      try {
        var _params;
        if (!((_params = params) !== null && _params !== void 0 && _params.browserUserAgent)) {
          _userAgent = navigator.userAgent;
          parsedUserAgent = es5_default().parse(_userAgent);
          //delete engine field from parsed object
          delete parsedUserAgent.engine;
        }
      } catch (error) {}

      //if params is provided but with rawUserAgent, we will parse it
      if (params && params.rawUserAgent) {
        _userAgent = params.rawUserAgent;
        parsedUserAgent = es5_default().parse(_userAgent);
        //delete engine field from parsed object
        delete parsedUserAgent.engine;
      }

      //empty params
      if (!params) params = {};

      //
      var deviceInfo = {};
      deviceInfo.sdkType = params.sdkType || "javascript";
      deviceInfo.sdkVersion = params.sdkVersion || "0.3.4";
      deviceInfo.platform = params.platform || ((_parsedUserAgent = parsedUserAgent) === null || _parsedUserAgent === void 0 || (_parsedUserAgent = _parsedUserAgent.platform) === null || _parsedUserAgent === void 0 ? void 0 : _parsedUserAgent.type) || "";

      //browserAgent
      if (params.browserUserAgent == "null") {
        deviceInfo.browserUserAgent = undefined;
      } else {
        deviceInfo.browserUserAgent = parsedUserAgent;
      }

      //device agent
      if (params.deviceUserAgent) {
        deviceInfo.deviceUserAgent = params.deviceUserAgent;
      }
      this._deviceInfo = deviceInfo;
    }
    /**
     * Initialize meeting and local video stream.
     * @param {{
     *  meetingId: string,
     *  autoConsume?: boolean,
     *  preferredProtocol?: "UDP_ONLY" | "UDP_OVER_TCP" | "TCP_ONLY",
     *  participantId?:string,
     *  name:string,
     *  micEnabled:boolean,
     *  webcamEnabled:boolean,
     *  chatEnabled?: boolean,
     *  maxResolution?:"hd" | "sd",
     *  customCameraVideoTrack?: MediaStream | undefined
     *  customMicrophoneAudioTrack?: MediaStream | undefined,
     *  useSpartialLayerAnalytics?: boolean
     *  mode?: SEND_AND_RECV | SIGNALLING_ONLY | RECV_ONLY,
     *  multiStream?: boolean,
     *  metaData?: object | undefined,
     *  defaultCamera?: 'front' | 'back',
     *  debugMode: boolean
     * }}
     * @returns {Meeting}
     */
  }, {
    key: "initMeeting",
    value: function initMeeting(_ref7) {
      var _preferredProtocol;
      var meetingId = _ref7.meetingId,
        _ref7$customCameraVid = _ref7.customCameraVideoTrack,
        customCameraVideoTrack = _ref7$customCameraVid === void 0 ? undefined : _ref7$customCameraVid,
        _ref7$customMicrophon = _ref7.customMicrophoneAudioTrack,
        customMicrophoneAudioTrack = _ref7$customMicrophon === void 0 ? undefined : _ref7$customMicrophon,
        _ref7$autoConsume = _ref7.autoConsume,
        autoConsume = _ref7$autoConsume === void 0 ? true : _ref7$autoConsume,
        preferredProtocol = _ref7.preferredProtocol,
        mode = _ref7.mode,
        _ref7$multiStream = _ref7.multiStream,
        multiStream = _ref7$multiStream === void 0 ? true : _ref7$multiStream,
        participantId = _ref7.participantId,
        name = _ref7.name,
        micEnabled = _ref7.micEnabled,
        webcamEnabled = _ref7.webcamEnabled,
        maxResolution = _ref7.maxResolution,
        metaData = _ref7.metaData,
        chatEnabled = _ref7.chatEnabled,
        useSpartialLayerAnalytics = _ref7.useSpartialLayerAnalytics,
        signalingBaseUrl = _ref7.signalingBaseUrl,
        defaultCamera = _ref7.defaultCamera,
        _ref7$debugMode = _ref7.debugMode,
        debugMode = _ref7$debugMode === void 0 ? true : _ref7$debugMode;
      if (!meetingId) {
        throw new Error("'meetingId' is empty, please verify it or generate new meetingId using the API.");
      }
      var peerId = participantId ? participantId.toString() : random_string_default()({
        length: 8
      }).toLowerCase();
      var displayName = name || random_string_default()({
        length: 6
      }).toLowerCase();

      //if the user did not provide analytics params, we will use the default ones
      if (!this._deviceInfo) {
        this.analytics(); // if not set, set default device info
      }
      if (typeof preferredProtocol !== "string") {
        preferredProtocol = "UDP_OVER_TCP";
      }
      switch ((_preferredProtocol = preferredProtocol) === null || _preferredProtocol === void 0 ? void 0 : _preferredProtocol.toUpperCase()) {
        case "UDP_ONLY":
        case "UDP_OVER_TCP":
        case "TCP_ONLY":
          preferredProtocol = preferredProtocol.toUpperCase();
          break;
        default:
          preferredProtocol = "UDP_OVER_TCP";
          break;
      }
      if (!mode) {
        mode = modes/* modes */.nI.SEND_AND_RECV;
      }
      if (mode !== modes/* modes */.nI.SEND_AND_RECV && mode !== modes/* modes */.nI.SIGNALLING_ONLY && mode !== modes/* modes */.nI.RECV_ONLY && mode !== modes/* modes */.nI.VIEWER && mode !== modes/* modes */.nI.CONFERENCE) {
        throw new Error("\"mode\" can only be either ".concat(modes/* modes */.nI.SEND_AND_RECV, " or ").concat(modes/* modes */.nI.SIGNALLING_ONLY, " or ").concat(modes/* modes */.nI.RECV_ONLY, " "));
      }
      if (metaData != undefined) {
        if ((0,esm_typeof/* default */.A)(metaData) != "object") {
          throw new Error("\"metaData\" can only be object.");
        }
      }
      var isReactNative = this._deviceInfo.sdkType === "react-native";

      // If the SDK is React Native, we first check if the defaultCamera value is provided.
      // If not, we then examine the custom track's facingMode value.
      // If neither defaultCamera nor custom track values are provided, we assign values based on the React Native SDK.
      var defaultCameraIndex = isReactNative ? defaultCamera ? defaultCamera === "front" ? 1 : 0 : customCameraVideoTrack ? customCameraVideoTrack.getVideoTracks()[0].getConstraints().facingMode === "user" ? 1 : 0 : isReactNative ? 1 : 0 : 0; // for WEB

      var roomClient = new RoomClient["default"]({
        roomId: meetingId,
        peerId: peerId,
        secret: this.apiKey,
        device: "unknown",
        displayName: displayName,
        mode: mode,
        useSimulcast: multiStream,
        produce: true,
        consume: true,
        datachannel: chatEnabled !== false,
        micEnabled: micEnabled !== false,
        webcamEnabled: webcamEnabled !== false,
        maxResolution: maxResolution || "hd",
        useSpartialLayerAnalytics: useSpartialLayerAnalytics,
        //useSpartialLayerAnalytics: true,
        _deviceInfo: this._deviceInfo,
        customCameraVideoTrack: customCameraVideoTrack,
        customMicrophoneAudioTrack: customMicrophoneAudioTrack,
        autoConsume: autoConsume,
        preferredProtocol: preferredProtocol,
        signalingBaseUrl: signalingBaseUrl,
        metaData: metaData,
        defaultCameraIndex: defaultCameraIndex,
        debugMode: debugMode,
        keyProvider: this.keyProvider
      });
      Store.roomClient = roomClient;
      var localParticipant = new Participant({
        id: peerId,
        displayName: displayName,
        local: true,
        mode: mode,
        metaData: metaData
      });
      return new Meeting(meetingId, localParticipant, roomClient);
    }

    /**
     *
     * For media API refer this doc
     * https://www.w3.org/TR/mediacapture-streams/#def-constraint-sampleRate
     */

    /**
     * @param {{
     *  cameraId?: string | undefined,
     *  encoderConfig?: "h90p_w160p" | "h180p_w320p" | "h216p_w384p"
     *     | "h360p_w640p" | "h360p_w640p_150kbps" | h540p_w960p" | "h540p_w960p_500kbps" | "h720p_w1280p" | "h1080p_w1920p"
     *     | "h1440p_w2560p" | "h2160p_w3840p" | "h120p_w160p" | "h180p_w240p"
     *     | "h240p_w320p" | "h360p_w480p" | "h480p_w640p" | "h540p_w720p"
     *     | "h720p_w960p" | "h1080p_w1440p" | "h1440p_w1920p" | undefined,
     *  facingMode?: "front" | "environment" | undefined,
     *  optimizationMode?: "text"| "motion" | "detail" | undefined
     *  multiStream?: boolean
     * }}
     */
  }, {
    key: "createCameraVideoTrack",
    value: (function () {
      var _createCameraVideoTrack = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee11(_ref8) {
        var _ref8$cameraId, cameraId, _ref8$encoderConfig, encoderConfig, _ref8$facingMode, facingMode, _ref8$optimizationMod, optimizationMode, _ref8$multiStream, multiStream, cameras, isCamera, foundCamera, videoProfile, cameraConstraints, mediaStream, message, sdkError, _t12, _t13;
        return regenerator_default().wrap(function (_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _ref8$cameraId = _ref8.cameraId, cameraId = _ref8$cameraId === void 0 ? undefined : _ref8$cameraId, _ref8$encoderConfig = _ref8.encoderConfig, encoderConfig = _ref8$encoderConfig === void 0 ? undefined : _ref8$encoderConfig, _ref8$facingMode = _ref8.facingMode, facingMode = _ref8$facingMode === void 0 ? undefined : _ref8$facingMode, _ref8$optimizationMod = _ref8.optimizationMode, optimizationMode = _ref8$optimizationMod === void 0 ? undefined : _ref8$optimizationMod, _ref8$multiStream = _ref8.multiStream, multiStream = _ref8$multiStream === void 0 ? true : _ref8$multiStream;
              if (!cameraId) {
                _context12.next = 2;
                break;
              }
              _context12.next = 1;
              return this.getCameras();
            case 1:
              cameras = _context12.sent;
              if (cameras) {
                isCamera = cameras.some(function (element) {
                  return element.deviceId;
                });
                if (isCamera) {
                  foundCamera = cameras.some(function (element) {
                    return element.deviceId === cameraId;
                  });
                  if (!foundCamera) {
                    console.error("No camera device found for the given cameraId, please check the passed cameraId. The default camera will be used instead.");
                  }
                }
              }
            case 2:
              _context12.prev = 2;
              videoProfile = encoderConfig ? config/* config */.$.videoProfiles[encoderConfig] : config/* config */.$.videoProfiles.h360p_w640p;
              cameraConstraints = {
                video: {
                  // deviceId: {
                  //   exact: cameraId ? cameraId : undefined
                  // },
                  deviceId: cameraId ? {
                    exact: cameraId
                  } : undefined,
                  facingMode: facingMode ? facingMode : undefined,
                  width: videoProfile.width,
                  height: videoProfile.height,
                  // aspectRatio: config.aspectRatios[videoProfile.aspectRatio].value,
                  frameRate: videoProfile.frameRate
                }
              };
              _context12.next = 3;
              return (0,media/* getNavigatorMediaDevices */.lp)(cameraConstraints);
            case 3:
              mediaStream = _context12.sent;
              if (optimizationMode) {
                mediaStream.contentHint = optimizationMode;
              }
              mediaStream.encoderConfig = encoderConfig ? encoderConfig : "h360p_w640p";
              mediaStream.contentHint = optimizationMode ? optimizationMode : "";
              mediaStream.multiStream = multiStream;
              mediaStream.cameraId = cameraId;
              return _context12.abrupt("return", mediaStream);
            case 4:
              _context12.prev = 4;
              _t12 = _context12["catch"](2);
              if (!(_t12.name === "SecurityError")) {
                _context12.next = 5;
                break;
              }
              message = errors/* sdkErrors */.q.ERROR_RN_CAMERA_ACCESS_DENIED_OR_DISMISSED.message;
              _context12.next = 13;
              break;
            case 5:
              if (!(_t12.name === "DOMException")) {
                _context12.next = 6;
                break;
              }
              message = errors/* sdkErrors */.q.ERROR_RN_CAMERA_NOT_FOUND.message;
              _context12.next = 13;
              break;
            case 6:
              if (!(_t12 instanceof DOMException)) {
                _context12.next = 12;
                break;
              }
              _t13 = _t12.name;
              _context12.next = _t13 === "NotAllowedError" ? 7 : _t13 === "NotReadableError" ? 8 : _t13 === "NotFoundError" ? 9 : 10;
              break;
            case 7:
              message = handleNotAllowedError(_t12, "video");
              return _context12.abrupt("continue", 11);
            case 8:
              message = handleNotReadableError(_t12, "video");
              return _context12.abrupt("continue", 11);
            case 9:
              message = errors/* sdkErrors */.q.ERROR_CAMERA_NOT_FOUND.message;
              if (navigator && navigator.userAgent) {
                if (navigator.userAgent.indexOf("Firefox") != -1) {
                  // Occurs when camera is not accessed by the firefox browser, and user allows camera permission
                  message = errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
                }
              }
              return _context12.abrupt("continue", 11);
            case 10:
              message = _t12.message;
              return _context12.abrupt("continue", 11);
            case 11:
              _context12.next = 13;
              break;
            case 12:
              if (_t12.message == "getUserMedia is not implemented in this browser") {
                sdkError = errors/* sdkErrors */.q.ERROR_CAMERA_ACCESS_UNAVAILABLE;
                message = sdkError.message;
              } else {
                message = _t12.message;
              }
            case 13:
              console.error("An error occurred in creating video track, ".concat(message));
              return _context12.abrupt("return", null);
            case 14:
            case "end":
              return _context12.stop();
          }
        }, _callee11, this, [[2, 4]]);
      }));
      function createCameraVideoTrack(_x7) {
        return _createCameraVideoTrack.apply(this, arguments);
      }
      return createCameraVideoTrack;
    }()
    /**
     * @param {{
     *  encoderConfig?: "h360p_30fps" | "h720p_5fps" | "h720p_15fps"
     *       | "h1080p_15fps" | "h1080p_30fps" | undefined,
     *  optimizationMode?: "text"| "motion" | "detail" | undefined
     *  withAudio?: "enable" | "disable"
     * }}
     */
    )
  }, {
    key: "createScreenShareVideoTrack",
    value: (function () {
      var _createScreenShareVideoTrack = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee12(_ref9) {
        var _ref9$encoderConfig, encoderConfig, _ref9$optimizationMod, optimizationMode, _ref9$withAudio, withAudio, _ref9$multiStream, multiStream, screenProfile, screenConstraints, screenStream;
        return regenerator_default().wrap(function (_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _ref9$encoderConfig = _ref9.encoderConfig, encoderConfig = _ref9$encoderConfig === void 0 ? undefined : _ref9$encoderConfig, _ref9$optimizationMod = _ref9.optimizationMode, optimizationMode = _ref9$optimizationMod === void 0 ? undefined : _ref9$optimizationMod, _ref9$withAudio = _ref9.withAudio, withAudio = _ref9$withAudio === void 0 ? "enable" : _ref9$withAudio, _ref9$multiStream = _ref9.multiStream, multiStream = _ref9$multiStream === void 0 ? false : _ref9$multiStream;
              screenProfile = encoderConfig ? config/* config */.$.screenShareProfiles[encoderConfig] : config/* config */.$.screenShareProfiles.h720p_15fps;
              screenConstraints = {
                audio: withAudio === "enable",
                video: {
                  width: screenProfile.resolution.width,
                  height: screenProfile.resolution.height,
                  frameRate: screenProfile.frameRate
                }
              };
              _context13.next = 1;
              return (0,media/* getNavigatorDisplayMediaDevices */.Zu)(screenConstraints);
            case 1:
              screenStream = _context13.sent;
              if (optimizationMode) {
                screenStream.contentHint = optimizationMode;
              }
              screenStream.multiStream = multiStream;
              return _context13.abrupt("return", screenStream);
            case 2:
            case "end":
              return _context13.stop();
          }
        }, _callee12);
      }));
      function createScreenShareVideoTrack(_x8) {
        return _createScreenShareVideoTrack.apply(this, arguments);
      }
      return createScreenShareVideoTrack;
    }()
    /**
     * @param {{
     *  noiseConfig?: {
     *    echoCancellation: boolean,
     *    autoGainControl: boolean,
     *    noiseSuppression: boolean
     *  } | undefined,
     *  encoderConfig?: "speech_low_quality"
     *     | "speech_standard" | "music_standard"
     *     | "standard_stereo" | "high_quality"
     *     | "high_quality_stereo" | undefined
     *  microphoneId?: string | undefined
     * }}
     */
    )
  }, {
    key: "createMicrophoneAudioTrack",
    value: (function () {
      var _createMicrophoneAudioTrack = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee13(_ref0) {
        var _ref0$noiseConfig, noiseConfig, _ref0$encoderConfig, encoderConfig, _ref0$microphoneId, microphoneId, microphones, foundMicrophone, audioProfile, microphoneConstraints, audioStream, message, sdkError, _t14, _t15;
        return regenerator_default().wrap(function (_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _ref0$noiseConfig = _ref0.noiseConfig, noiseConfig = _ref0$noiseConfig === void 0 ? undefined : _ref0$noiseConfig, _ref0$encoderConfig = _ref0.encoderConfig, encoderConfig = _ref0$encoderConfig === void 0 ? undefined : _ref0$encoderConfig, _ref0$microphoneId = _ref0.microphoneId, microphoneId = _ref0$microphoneId === void 0 ? undefined : _ref0$microphoneId;
              if (!microphoneId) {
                _context14.next = 2;
                break;
              }
              _context14.next = 1;
              return this.getMicrophones();
            case 1:
              microphones = _context14.sent;
              if (microphones) {
                if (microphones.some(function (element) {
                  return element.deviceId;
                })) {
                  foundMicrophone = microphones.some(function (element) {
                    return element.deviceId === microphoneId;
                  });
                  if (!foundMicrophone) {
                    console.error("No microphone device found for the given microphoneId, please check the passed microphoneId. The default microphone will be used instead.");
                  }
                }
              }
            case 2:
              _context14.prev = 2;
              audioProfile = encoderConfig ? config/* config */.$.audioProfiles[encoderConfig] : config/* config */.$.audioProfiles.speech_standard;
              microphoneConstraints = {
                audio: {
                  // deviceId: { exact: microphoneId ? microphoneId : undefined },
                  deviceId: microphoneId ? {
                    exact: microphoneId
                  } : undefined,
                  sampleRate: audioProfile.sampleRate,
                  echoCancellation: noiseConfig ? noiseConfig && noiseConfig.acousticEchoCancellation : audioProfile.echoCancellation,
                  autoGainControl: noiseConfig ? noiseConfig && noiseConfig.autoGainControl : audioProfile.autoGainControl,
                  noiseSuppression: noiseConfig ? noiseConfig && noiseConfig.noiseSuppression : audioProfile.noiseSuppression,
                  channelCount: audioProfile.channelCount
                }
              };
              _context14.next = 3;
              return (0,media/* getNavigatorMediaDevices */.lp)(microphoneConstraints);
            case 3:
              audioStream = _context14.sent;
              audioStream.encoderConfig = encoderConfig ? encoderConfig : "speech_standard";
              audioStream.microphoneId = microphoneId;
              return _context14.abrupt("return", audioStream);
            case 4:
              _context14.prev = 4;
              _t14 = _context14["catch"](2);
              if (!(_t14.name === "SecurityError")) {
                _context14.next = 5;
                break;
              }
              message = errors/* sdkErrors */.q.ERROR_RN_MIC_ACCESS_DENIED_OR_DISMISSED.message;
              _context14.next = 13;
              break;
            case 5:
              if (!(_t14.name === "DOMException")) {
                _context14.next = 6;
                break;
              }
              message = errors/* sdkErrors */.q.ERROR_RN_MIC_NOT_FOUND.message;
              _context14.next = 13;
              break;
            case 6:
              if (!(_t14 instanceof DOMException)) {
                _context14.next = 12;
                break;
              }
              _t15 = _t14.name;
              _context14.next = _t15 === "NotAllowedError" ? 7 : _t15 === "NotReadableError" ? 8 : _t15 === "NotFoundError" ? 9 : 10;
              break;
            case 7:
              message = handleNotAllowedError(_t14, "audio");
              return _context14.abrupt("continue", 11);
            case 8:
              message = handleNotReadableError(_t14, "audio");
              return _context14.abrupt("continue", 11);
            case 9:
              message = errors/* sdkErrors */.q.ERROR_MICROPHONE_NOT_FOUND.message;
              if (navigator && navigator.userAgent) {
                if (navigator.userAgent.indexOf("Firefox") != -1) {
                  // Occurs when microphone is not accessed by the firefox browser, and user allows microphone permission
                  message = errors/* sdkErrors */.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS.message;
                }
              }
              return _context14.abrupt("continue", 11);
            case 10:
              message = _t14.message;
              return _context14.abrupt("continue", 11);
            case 11:
              _context14.next = 13;
              break;
            case 12:
              if (_t14.message == "getUserMedia is not implemented in this browser") {
                sdkError = errors/* sdkErrors */.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE;
                message = sdkError.message;
              } else {
                message = _t14.message;
              }
            case 13:
              console.error("An error occurred in creating audio track, ".concat(message));
              return _context14.abrupt("return", null);
            case 14:
            case "end":
              return _context14.stop();
          }
        }, _callee13, this, [[2, 4]]);
      }));
      function createMicrophoneAudioTrack(_x9) {
        return _createMicrophoneAudioTrack.apply(this, arguments);
      }
      return createMicrophoneAudioTrack;
    }())
  }]);
}();
(0,defineProperty/* default */.A)(VideoSDK, "devices", []);
(0,defineProperty/* default */.A)(VideoSDK, "eventEmitter", new events());
(0,defineProperty/* default */.A)(VideoSDK, "Constants", {
  errors: errors/* errors */.s,
  recordingEvents: recordingEvents,
  livestreamEvents: livestreamEvents,
  characterState: CharacterState,
  characterMode: CharacterMode,
  hlsEvents: hlsEvents/* hlsEvents */.V,
  transcriptionEvents: transcriptionEvents,
  modes: modes/* modes */.nI,
  permission: Permission,
  reliabilityMode: reliabilityModes/* reliabilityMode */.y
});
function handleNotAllowedError(error, mediaType) {
  var err = {};
  if (error.message === "Permission denied" || error.message === "Permission dismissed") {
    err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_CAMERA_ACCESS_DENIED_OR_DISMISSED : errors/* sdkErrors */.q.ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED;
  } else if (error.message.includes("The request is not allowed by the user agent")) {
    // This occurs when the user denies permission in the Firefox browser
    err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_OR_AUTOPLAY_ISSUE : errors/* sdkErrors */.q.ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED;
  } else if (error.message === "Permission denied by system") {
    err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS : errors/* sdkErrors */.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS;
  } else {
    err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED : errors/* sdkErrors */.q.ERROR_GET_AUDIO_MEDIA_PERMISSION_DENIED;
  }
  return err.message;
}
function handleNotReadableError(error, mediaType) {
  var err = {};
  if (error.message === "Device in use") {
    err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_CAMERA_IN_USE : errors/* sdkErrors */.q.ERROR_MICROPHONE_IN_USE;
  } else {
    err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_VIDEO_SOURCE_INITIATION_FAILED : errors/* sdkErrors */.q.ERROR_MICROPHONE_IN_USE;
  }
  return err.message;
}

/**@deprecated */
var ZujoSDK = VideoSDK;


/***/ }),

/***/ 1919:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ RoomClient)
});

// NAMESPACE OBJECT: ./node_modules/socket.io-parser/build/esm/index.js
var socket_io_parser_build_esm_namespaceObject = {};
__webpack_require__.r(socket_io_parser_build_esm_namespaceObject);
__webpack_require__.d(socket_io_parser_build_esm_namespaceObject, {
  Decoder: () => (Decoder),
  Encoder: () => (Encoder),
  PacketType: () => (PacketType),
  protocol: () => (build_esm_protocol)
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 3 modules
var slicedToArray = __webpack_require__(296);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules
var toConsumableArray = __webpack_require__(5458);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(2284);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(467);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__(3029);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__(2901);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__(4467);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(4756);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);
;// ./node_modules/engine.io-parser/build/esm/commons.js
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };


;// ./node_modules/engine.io-parser/build/esm/encodePacket.browser.js

const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(data, callback);
        }
    }
    else if (withNativeArrayBuffer &&
        (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(new Blob([data]), callback);
        }
    }
    // plain string
    return callback(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
};
function toArray(data) {
    if (data instanceof Uint8Array) {
        return data;
    }
    else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    else {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
    if (withNativeBlob && packet.data instanceof Blob) {
        return packet.data.arrayBuffer().then(toArray).then(callback);
    }
    else if (withNativeArrayBuffer &&
        (packet.data instanceof ArrayBuffer || isView(packet.data))) {
        return callback(toArray(packet.data));
    }
    encodePacket(packet, false, (encoded) => {
        if (!TEXT_ENCODER) {
            TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
    });
}


;// ./node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
// imported from https://github.com/socketio/base64-arraybuffer
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
const lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
const encode = (arraybuffer) => {
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
const decode = (base64) => {
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};

;// ./node_modules/engine.io-parser/build/esm/decodePacket.browser.js


const decodePacket_browser_withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType),
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),
        };
    }
    const packetType = PACKET_TYPES_REVERSE[type];
    if (!packetType) {
        return ERROR_PACKET;
    }
    return encodedPacket.length > 1
        ? {
            type: PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1),
        }
        : {
            type: PACKET_TYPES_REVERSE[type],
        };
};
const decodeBase64Packet = (data, binaryType) => {
    if (decodePacket_browser_withNativeArrayBuffer) {
        const decoded = decode(data);
        return mapBinary(decoded, binaryType);
    }
    else {
        return { base64: true, data }; // fallback for old browsers
    }
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "blob":
            if (data instanceof Blob) {
                // from WebSocket + binaryType "blob"
                return data;
            }
            else {
                // from HTTP long-polling or WebTransport
                return new Blob([data]);
            }
        case "arraybuffer":
        default:
            if (data instanceof ArrayBuffer) {
                // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
                return data;
            }
            else {
                // from WebTransport (Uint8Array)
                return data.buffer;
            }
    }
};

;// ./node_modules/engine.io-parser/build/esm/index.js



const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        encodePacket(packet, false, (encodedPacket) => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = decodePacket(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
function createPacketEncoderStream() {
    return new TransformStream({
        transform(packet, controller) {
            encodePacketToBinary(packet, (encodedPacket) => {
                const payloadLength = encodedPacket.length;
                let header;
                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
                if (payloadLength < 126) {
                    header = new Uint8Array(1);
                    new DataView(header.buffer).setUint8(0, payloadLength);
                }
                else if (payloadLength < 65536) {
                    header = new Uint8Array(3);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 126);
                    view.setUint16(1, payloadLength);
                }
                else {
                    header = new Uint8Array(9);
                    const view = new DataView(header.buffer);
                    view.setUint8(0, 127);
                    view.setBigUint64(1, BigInt(payloadLength));
                }
                // first bit indicates whether the payload is plain text (0) or binary (1)
                if (packet.data && typeof packet.data !== "string") {
                    header[0] |= 0x80;
                }
                controller.enqueue(header);
                controller.enqueue(encodedPacket);
            });
        },
    });
}
let TEXT_DECODER;
function totalLength(chunks) {
    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
    if (chunks[0].length === size) {
        return chunks.shift();
    }
    const buffer = new Uint8Array(size);
    let j = 0;
    for (let i = 0; i < size; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
            chunks.shift();
            j = 0;
        }
    }
    if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
    }
    return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
    if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
    }
    const chunks = [];
    let state = 0 /* State.READ_HEADER */;
    let expectedLength = -1;
    let isBinary = false;
    return new TransformStream({
        transform(chunk, controller) {
            chunks.push(chunk);
            while (true) {
                if (state === 0 /* State.READ_HEADER */) {
                    if (totalLength(chunks) < 1) {
                        break;
                    }
                    const header = concatChunks(chunks, 1);
                    isBinary = (header[0] & 0x80) === 0x80;
                    expectedLength = header[0] & 0x7f;
                    if (expectedLength < 126) {
                        state = 3 /* State.READ_PAYLOAD */;
                    }
                    else if (expectedLength === 126) {
                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
                    }
                    else {
                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
                    }
                }
                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
                    if (totalLength(chunks) < 2) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 2);
                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
                    if (totalLength(chunks) < 8) {
                        break;
                    }
                    const headerArray = concatChunks(chunks, 8);
                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                    const n = view.getUint32(0);
                    if (n > Math.pow(2, 53 - 32) - 1) {
                        // the maximum safe integer in JavaScript is 2^53 - 1
                        controller.enqueue(ERROR_PACKET);
                        break;
                    }
                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                    state = 3 /* State.READ_PAYLOAD */;
                }
                else {
                    if (totalLength(chunks) < expectedLength) {
                        break;
                    }
                    const data = concatChunks(chunks, expectedLength);
                    controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
                    state = 0 /* State.READ_HEADER */;
                }
                if (expectedLength === 0 || expectedLength > maxPayload) {
                    controller.enqueue(ERROR_PACKET);
                    break;
                }
            }
        },
    });
}
const protocol = 4;


;// ./node_modules/@socket.io/component-emitter/lib/esm/index.js
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

;// ./node_modules/engine.io-client/build/esm/globals.js
const nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
    }
    else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
})();
const globalThisShim = (() => {
    if (typeof self !== "undefined") {
        return self;
    }
    else if (typeof window !== "undefined") {
        return window;
    }
    else {
        return Function("return this")();
    }
})();
const defaultBinaryType = "arraybuffer";
function createCookieJar() { }

;// ./node_modules/engine.io-client/build/esm/util.js

function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
    }
    else {
        obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
        obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
    }
}
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
const BASE64_OVERHEAD = 1.33;
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
function byteLength(obj) {
    if (typeof obj === "string") {
        return utf8Length(obj);
    }
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
    let c = 0, length = 0;
    for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 0x80) {
            length += 1;
        }
        else if (c < 0x800) {
            length += 2;
        }
        else if (c < 0xd800 || c >= 0xe000) {
            length += 3;
        }
        else {
            i++;
            length += 4;
        }
    }
    return length;
}
/**
 * Generates a random 8-characters string.
 */
function randomString() {
    return (Date.now().toString(36).substring(3) +
        Math.random().toString(36).substring(2, 5));
}

;// ./node_modules/engine.io-client/build/esm/contrib/parseqs.js
// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
function parseqs_encode(obj) {
    let str = '';
    for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (str.length)
                str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
    }
    return str;
}
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */
function parseqs_decode(qs) {
    let qry = {};
    let pairs = qs.split('&');
    for (let i = 0, l = pairs.length; i < l; i++) {
        let pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
}

;// ./node_modules/engine.io-client/build/esm/transport.js




class TransportError extends Error {
    constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
    }
}
class Transport extends Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
        super();
        this.writable = false;
        installTimerFunctions(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
        this.supportsBinary = !opts.forceBase64;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
    }
    /**
     * Opens the transport.
     */
    open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
    }
    /**
     * Closes the transport.
     */
    close() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
        if (this.readyState === "open") {
            this.write(packets);
        }
        else {
            // this might happen if the transport was silently closed in the beforeunload event handler
        }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
        const packet = decodePacket(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
        super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) { }
    createUri(schema, query = {}) {
        return (schema +
            "://" +
            this._hostname() +
            this._port() +
            this.opts.path +
            this._query(query));
    }
    _hostname() {
        const hostname = this.opts.hostname;
        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
        if (this.opts.port &&
            ((this.opts.secure && Number(this.opts.port !== 443)) ||
                (!this.opts.secure && Number(this.opts.port) !== 80))) {
            return ":" + this.opts.port;
        }
        else {
            return "";
        }
    }
    _query(query) {
        const encodedQuery = parseqs_encode(query);
        return encodedQuery.length ? "?" + encodedQuery : "";
    }
}

;// ./node_modules/engine.io-client/build/esm/transports/polling.js



class polling_Polling extends Transport {
    constructor() {
        super(...arguments);
        this._polling = false;
    }
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
        this._poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
            this.readyState = "paused";
            onPause();
        };
        if (this._polling || !this.writable) {
            let total = 0;
            if (this._polling) {
                total++;
                this.once("pollComplete", function () {
                    --total || pause();
                });
            }
            if (!this.writable) {
                total++;
                this.once("drain", function () {
                    --total || pause();
                });
            }
        }
        else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    _poll() {
        this._polling = true;
        this.doPoll();
        this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data) {
        const callback = (packet) => {
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose({ description: "transport closed by the server" });
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        decodePayload(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this._polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) {
                this._poll();
            }
            else {
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
        const close = () => {
            this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
            close();
        }
        else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
        this.writable = false;
        encodePayload(packets, (data) => {
            this.doWrite(data, () => {
                this.writable = true;
                this.emitReserved("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "https" : "http";
        const query = this.query || {};
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = randomString();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}

;// ./node_modules/engine.io-client/build/esm/contrib/has-cors.js
// imported from https://github.com/component/has-cors
let value = false;
try {
    value = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
}
catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
}
const hasCORS = value;

;// ./node_modules/engine.io-client/build/esm/transports/polling-xhr.js





function empty() { }
class BaseXHR extends polling_Polling {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
        super(opts);
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty `location.port`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd =
                (typeof location !== "undefined" &&
                    opts.hostname !== location.hostname) ||
                    port !== opts.port;
        }
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data,
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr post error", xhrStatus, context);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
    }
}
class Request extends Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(createRequest, uri, opts) {
        super();
        this.createRequest = createRequest;
        installTimerFunctions(this, opts);
        this._opts = opts;
        this._method = opts.method || "GET";
        this._uri = uri;
        this._data = undefined !== opts.data ? opts.data : null;
        this._create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    _create() {
        var _a;
        const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this._opts.xd;
        const xhr = (this._xhr = this.createRequest(opts));
        try {
            xhr.open(this._method, this._uri, true);
            try {
                if (this._opts.extraHeaders) {
                    // @ts-ignore
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for (let i in this._opts.extraHeaders) {
                        if (this._opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
                        }
                    }
                }
            }
            catch (e) { }
            if ("POST" === this._method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
                catch (e) { }
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            }
            catch (e) { }
            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this._opts.withCredentials;
            }
            if (this._opts.requestTimeout) {
                xhr.timeout = this._opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
                var _a;
                if (xhr.readyState === 3) {
                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(
                    // @ts-ignore
                    xhr.getResponseHeader("set-cookie"));
                }
                if (4 !== xhr.readyState)
                    return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this._onLoad();
                }
                else {
                    // make sure the `error` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(() => {
                        this._onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            xhr.send(this._data);
        }
        catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(() => {
                this._onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this._index = Request.requestsCount++;
            Request.requests[this._index] = this;
        }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    _onError(err) {
        this.emitReserved("error", err, this._xhr);
        this._cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    _cleanup(fromError) {
        if ("undefined" === typeof this._xhr || null === this._xhr) {
            return;
        }
        this._xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this._xhr.abort();
            }
            catch (e) { }
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this._index];
        }
        this._xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    _onLoad() {
        const data = this._xhr.responseText;
        if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this._cleanup();
        }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
        this._cleanup();
    }
}
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    }
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}
const hasXHR2 = (function () {
    const xhr = newRequest({
        xdomain: false,
    });
    return xhr && xhr.responseType !== null;
})();
/**
 * HTTP long-polling based on the built-in `XMLHttpRequest` object.
 *
 * Usage: browser
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
 */
class XHR extends BaseXHR {
    constructor(opts) {
        super(opts);
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
    }
    request(opts = {}) {
        Object.assign(opts, { xd: this.xd }, this.opts);
        return new Request(newRequest, this.uri(), opts);
    }
}
function newRequest(opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
            return new XMLHttpRequest();
        }
    }
    catch (e) { }
    if (!xdomain) {
        try {
            return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        }
        catch (e) { }
    }
}

;// ./node_modules/engine.io-client/build/esm/transports/websocket.js




// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" &&
    typeof navigator.product === "string" &&
    navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport {
    get name() {
        return "websocket";
    }
    doOpen() {
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
            ? {}
            : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws = this.createSocket(uri, protocols, opts);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType;
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
        this.ws.onopen = () => {
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
            description: "websocket connection closed",
            context: closeEvent,
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
    }
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            encodePacket(packet, this.supportsBinary, (data) => {
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    this.doWrite(packet, data);
                }
                catch (e) {
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    nextTick(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.onerror = () => { };
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        const schema = this.opts.secure ? "wss" : "ws";
        const query = this.query || {};
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = randomString();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        return this.createUri(schema, query);
    }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
/**
 * WebSocket transport based on the built-in `WebSocket` object.
 *
 * Usage: browser, Node.js (since v21), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
 * @see https://caniuse.com/mdn-api_websocket
 * @see https://nodejs.org/api/globals.html#websocket
 */
class WS extends BaseWS {
    createSocket(uri, protocols, opts) {
        return !isReactNative
            ? protocols
                ? new WebSocketCtor(uri, protocols)
                : new WebSocketCtor(uri)
            : new WebSocketCtor(uri, protocols, opts);
    }
    doWrite(_packet, data) {
        this.ws.send(data);
    }
}

;// ./node_modules/engine.io-client/build/esm/transports/webtransport.js



/**
 * WebTransport transport based on the built-in `WebTransport` object.
 *
 * Usage: browser, Node.js (with the `@fails-components/webtransport` package)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport
 * @see https://caniuse.com/webtransport
 */
class WT extends Transport {
    get name() {
        return "webtransport";
    }
    doOpen() {
        try {
            // @ts-ignore
            this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this._transport.closed
            .then(() => {
            this.onClose();
        })
            .catch((err) => {
            this.onError("webtransport error", err);
        });
        // note: we could have used async/await, but that would require some additional polyfills
        this._transport.ready.then(() => {
            this._transport.createBidirectionalStream().then((stream) => {
                const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                const reader = stream.readable.pipeThrough(decoderStream).getReader();
                const encoderStream = createPacketEncoderStream();
                encoderStream.readable.pipeTo(stream.writable);
                this._writer = encoderStream.writable.getWriter();
                const read = () => {
                    reader
                        .read()
                        .then(({ done, value }) => {
                        if (done) {
                            return;
                        }
                        this.onPacket(value);
                        read();
                    })
                        .catch((err) => {
                    });
                };
                read();
                const packet = { type: "open" };
                if (this.query.sid) {
                    packet.data = `{"sid":"${this.query.sid}"}`;
                }
                this._writer.write(packet).then(() => this.onOpen());
            });
        });
    }
    write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            this._writer.write(packet).then(() => {
                if (lastPacket) {
                    nextTick(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        var _a;
        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
    }
}

;// ./node_modules/engine.io-client/build/esm/transports/index.js



const transports = {
    websocket: WS,
    webtransport: WT,
    polling: XHR,
};

;// ./node_modules/engine.io-client/build/esm/contrib/parseuri.js
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];
function parse(str) {
    if (str.length > 8000) {
        throw "URI too long";
    }
    const src = str, b = str.indexOf('['), e = str.indexOf(']');
    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }
    let m = re.exec(str || ''), uri = {}, i = 14;
    while (i--) {
        uri[parts[i]] = m[i] || '';
    }
    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);
    return uri;
}
function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.slice(-1) == '/') {
        names.splice(names.length - 1, 1);
    }
    return names;
}
function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });
    return data;
}

;// ./node_modules/engine.io-client/build/esm/socket.js







const withEventListeners = typeof addEventListener === "function" &&
    typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the
    // script, so we create one single event listener here which will forward the event to the socket instances
    addEventListener("offline", () => {
        OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
    }, false);
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that
 * successfully establishes the connection.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithoutUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithoutUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithUpgrade
 * @see Socket
 */
class SocketWithoutUpgrade extends Emitter {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    constructor(uri, opts) {
        super();
        this.binaryType = defaultBinaryType;
        this.writeBuffer = [];
        this._prevBufferLen = 0;
        this._pingInterval = -1;
        this._pingTimeout = -1;
        this._maxPayload = -1;
        /**
         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the
         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.
         */
        this._pingTimeoutTime = Infinity;
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            const parsedUri = parse(uri);
            opts.hostname = parsedUri.host;
            opts.secure =
                parsedUri.protocol === "https" || parsedUri.protocol === "wss";
            opts.port = parsedUri.port;
            if (parsedUri.query)
                opts.query = parsedUri.query;
        }
        else if (opts.host) {
            opts.hostname = parse(opts.host).host;
        }
        installTimerFunctions(this, opts);
        this.secure =
            null != opts.secure
                ? opts.secure
                : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
            // if no port is specified manually, use the protocol default
            opts.port = this.secure ? "443" : "80";
        }
        this.hostname =
            opts.hostname ||
                (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port =
            opts.port ||
                (typeof location !== "undefined" && location.port
                    ? location.port
                    : this.secure
                        ? "443"
                        : "80");
        this.transports = [];
        this._transportsByName = {};
        opts.transports.forEach((t) => {
            const transportName = t.prototype.name;
            this.transports.push(transportName);
            this._transportsByName[transportName] = t;
        });
        this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            addTrailingSlash: true,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024,
            },
            transportOptions: {},
            closeOnBeforeunload: false,
        }, opts);
        this.opts.path =
            this.opts.path.replace(/\/$/, "") +
                (this.opts.addTrailingSlash ? "/" : "");
        if (typeof this.opts.query === "string") {
            this.opts.query = parseqs_decode(this.opts.query);
        }
        if (withEventListeners) {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                this._beforeunloadEventListener = () => {
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                };
                addEventListener("beforeunload", this._beforeunloadEventListener, false);
            }
            if (this.hostname !== "localhost") {
                this._offlineEventListener = () => {
                    this._onClose("transport close", {
                        description: "network connection lost",
                    });
                };
                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
            }
        }
        if (this.opts.withCredentials) {
            this._cookieJar = createCookieJar();
        }
        this._open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    createTransport(name) {
        const query = Object.assign({}, this.opts.query);
        // append engine.io protocol identifier
        query.EIO = protocol;
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id)
            query.sid = this.id;
        const opts = Object.assign({}, this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port,
        }, this.opts.transportOptions[name]);
        return new this._transportsByName[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
    _open() {
        if (this.transports.length === 0) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
            }, 0);
            return;
        }
        const transportName = this.opts.rememberUpgrade &&
            SocketWithoutUpgrade.priorWebsocketSuccess &&
            this.transports.indexOf("websocket") !== -1
            ? "websocket"
            : this.transports[0];
        this.readyState = "opening";
        const transport = this.createTransport(transportName);
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
    setTransport(transport) {
        if (this.transport) {
            this.transport.removeAllListeners();
        }
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport
            .on("drain", this._onDrain.bind(this))
            .on("packet", this._onPacket.bind(this))
            .on("error", this._onError.bind(this))
            .on("close", (reason) => this._onClose("transport close", reason));
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
    onOpen() {
        this.readyState = "open";
        SocketWithoutUpgrade.priorWebsocketSuccess =
            "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
    }
    /**
     * Handles a packet.
     *
     * @private
     */
    _onPacket(packet) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            this.emitReserved("packet", packet);
            // Socket is live - any packet counts
            this.emitReserved("heartbeat");
            switch (packet.type) {
                case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case "ping":
                    this._sendPacket("pong");
                    this.emitReserved("ping");
                    this.emitReserved("pong");
                    this._resetPingTimeout();
                    break;
                case "error":
                    const err = new Error("server error");
                    // @ts-ignore
                    err.code = packet.data;
                    this._onError(err);
                    break;
                case "message":
                    this.emitReserved("data", packet.data);
                    this.emitReserved("message", packet.data);
                    break;
            }
        }
        else {
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
    onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this._pingInterval = data.pingInterval;
        this._pingTimeout = data.pingTimeout;
        this._maxPayload = data.maxPayload;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState)
            return;
        this._resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
    _resetPingTimeout() {
        this.clearTimeoutFn(this._pingTimeoutTimer);
        const delay = this._pingInterval + this._pingTimeout;
        this._pingTimeoutTime = Date.now() + delay;
        this._pingTimeoutTimer = this.setTimeoutFn(() => {
            this._onClose("ping timeout");
        }, delay);
        if (this.opts.autoUnref) {
            this._pingTimeoutTimer.unref();
        }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
    _onDrain() {
        this.writeBuffer.splice(0, this._prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this._prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
            this.emitReserved("drain");
        }
        else {
            this.flush();
        }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
    flush() {
        if ("closed" !== this.readyState &&
            this.transport.writable &&
            !this.upgrading &&
            this.writeBuffer.length) {
            const packets = this._getWritablePackets();
            this.transport.send(packets);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on `drain`
            this._prevBufferLen = packets.length;
            this.emitReserved("flush");
        }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
    _getWritablePackets() {
        const shouldCheckPayloadSize = this._maxPayload &&
            this.transport.name === "polling" &&
            this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
            return this.writeBuffer;
        }
        let payloadSize = 1; // first packet type
        for (let i = 0; i < this.writeBuffer.length; i++) {
            const data = this.writeBuffer[i].data;
            if (data) {
                payloadSize += byteLength(data);
            }
            if (i > 0 && payloadSize > this._maxPayload) {
                return this.writeBuffer.slice(0, i);
            }
            payloadSize += 2; // separator + packet type
        }
        return this.writeBuffer;
    }
    /**
     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
     *
     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
     * `write()` method then the message would not be buffered by the Socket.IO client.
     *
     * @return {boolean}
     * @private
     */
    /* private */ _hasPingExpired() {
        if (!this._pingTimeoutTime)
            return true;
        const hasExpired = Date.now() > this._pingTimeoutTime;
        if (hasExpired) {
            this._pingTimeoutTime = 0;
            nextTick(() => {
                this._onClose("ping timeout");
            }, this.setTimeoutFn);
        }
        return hasExpired;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    write(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a message. Alias of {@link Socket#write}.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @return {Socket} for chaining.
     */
    send(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
    _sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
            fn = data;
            data = undefined;
        }
        if ("function" === typeof options) {
            fn = options;
            options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
            return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options,
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
            this.once("flush", fn);
        this.flush();
    }
    /**
     * Closes the connection.
     */
    close() {
        const close = () => {
            this._onClose("forced close");
            this.transport.close();
        };
        const cleanupAndClose = () => {
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
        };
        const waitForUpgrade = () => {
            // wait for upgrade to finish since we can't send packets while pausing a transport
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
                this.once("drain", () => {
                    if (this.upgrading) {
                        waitForUpgrade();
                    }
                    else {
                        close();
                    }
                });
            }
            else if (this.upgrading) {
                waitForUpgrade();
            }
            else {
                close();
            }
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
    _onError(err) {
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        if (this.opts.tryAllTransports &&
            this.transports.length > 1 &&
            this.readyState === "opening") {
            this.transports.shift();
            return this._open();
        }
        this.emitReserved("error", err);
        this._onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
    _onClose(reason, description) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            // clear timers
            this.clearTimeoutFn(this._pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners("close");
            // ensure transport won't stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (withEventListeners) {
                if (this._beforeunloadEventListener) {
                    removeEventListener("beforeunload", this._beforeunloadEventListener, false);
                }
                if (this._offlineEventListener) {
                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
                    if (i !== -1) {
                        OFFLINE_EVENT_LISTENERS.splice(i, 1);
                    }
                }
            }
            // set ready state
            this.readyState = "closed";
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved("close", reason, description);
            // clean buffers after, so users can still
            // grab the buffers on `close` event
            this.writeBuffer = [];
            this._prevBufferLen = 0;
        }
    }
}
SocketWithoutUpgrade.protocol = protocol;
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.
 *
 * @example
 * import { SocketWithUpgrade, WebSocket } from "engine.io-client";
 *
 * const socket = new SocketWithUpgrade({
 *   transports: [WebSocket]
 * });
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see Socket
 */
class SocketWithUpgrade extends SocketWithoutUpgrade {
    constructor() {
        super(...arguments);
        this._upgrades = [];
    }
    onOpen() {
        super.onOpen();
        if ("open" === this.readyState && this.opts.upgrade) {
            for (let i = 0; i < this._upgrades.length; i++) {
                this._probe(this._upgrades[i]);
            }
        }
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    _probe(name) {
        let transport = this.createTransport(name);
        let failed = false;
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
            if (failed)
                return;
            transport.send([{ type: "ping", data: "probe" }]);
            transport.once("packet", (msg) => {
                if (failed)
                    return;
                if ("pong" === msg.type && "probe" === msg.data) {
                    this.upgrading = true;
                    this.emitReserved("upgrading", transport);
                    if (!transport)
                        return;
                    SocketWithoutUpgrade.priorWebsocketSuccess =
                        "websocket" === transport.name;
                    this.transport.pause(() => {
                        if (failed)
                            return;
                        if ("closed" === this.readyState)
                            return;
                        cleanup();
                        this.setTransport(transport);
                        transport.send([{ type: "upgrade" }]);
                        this.emitReserved("upgrade", transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                }
                else {
                    const err = new Error("probe error");
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved("upgradeError", err);
                }
            });
        };
        function freezeTransport() {
            if (failed)
                return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = (err) => {
            const error = new Error("probe error: " + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
            onerror("transport closed");
        }
        // When the socket is closed while we're probing
        function onclose() {
            onerror("socket closed");
        }
        // When the socket is upgraded while we're probing
        function onupgrade(to) {
            if (transport && to.name !== transport.name) {
                freezeTransport();
            }
        }
        // Remove all listeners on the transport and on self
        const cleanup = () => {
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        if (this._upgrades.indexOf("webtransport") !== -1 &&
            name !== "webtransport") {
            // favor WebTransport
            this.setTimeoutFn(() => {
                if (!failed) {
                    transport.open();
                }
            }, 200);
        }
        else {
            transport.open();
        }
    }
    onHandshake(data) {
        this._upgrades = this._filterUpgrades(data.upgrades);
        super.onHandshake(data);
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
    _filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        for (let i = 0; i < upgrades.length; i++) {
            if (~this.transports.indexOf(upgrades[i]))
                filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
    }
}
/**
 * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established
 * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.
 *
 * This class comes with an upgrade mechanism, which means that once the connection is established with the first
 * low-level transport, it will try to upgrade to a better transport.
 *
 * @example
 * import { Socket } from "engine.io-client";
 *
 * const socket = new Socket();
 *
 * socket.on("open", () => {
 *   socket.send("hello");
 * });
 *
 * @see SocketWithoutUpgrade
 * @see SocketWithUpgrade
 */
class Socket extends SocketWithUpgrade {
    constructor(uri, opts = {}) {
        const o = typeof uri === "object" ? uri : opts;
        if (!o.transports ||
            (o.transports && typeof o.transports[0] === "string")) {
            o.transports = (o.transports || ["polling", "websocket", "webtransport"])
                .map((transportName) => transports[transportName])
                .filter((t) => !!t);
        }
        super(uri, o);
    }
}

;// ./node_modules/engine.io-client/build/esm/transports/polling-fetch.js

/**
 * HTTP long-polling based on the built-in `fetch()` method.
 *
 * Usage: browser, Node.js (since v18), Deno, Bun
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch
 * @see https://caniuse.com/fetch
 * @see https://nodejs.org/api/globals.html#fetch
 */
class Fetch extends (/* unused pure expression or super */ null && (Polling)) {
    doPoll() {
        this._fetch()
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch read error", res.status, res);
            }
            res.text().then((data) => this.onData(data));
        })
            .catch((err) => {
            this.onError("fetch read error", err);
        });
    }
    doWrite(data, callback) {
        this._fetch(data)
            .then((res) => {
            if (!res.ok) {
                return this.onError("fetch write error", res.status, res);
            }
            callback();
        })
            .catch((err) => {
            this.onError("fetch write error", err);
        });
    }
    _fetch(data) {
        var _a;
        const isPost = data !== undefined;
        const headers = new Headers(this.opts.extraHeaders);
        if (isPost) {
            headers.set("content-type", "text/plain;charset=UTF-8");
        }
        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);
        return fetch(this.uri(), {
            method: isPost ? "POST" : "GET",
            body: isPost ? data : null,
            headers,
            credentials: this.opts.withCredentials ? "include" : "omit",
        }).then((res) => {
            var _a;
            // @ts-ignore getSetCookie() was added in Node.js v19.7.0
            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());
            return res;
        });
    }
}

;// ./node_modules/engine.io-client/build/esm/index.js



const esm_protocol = Socket.protocol;












;// ./node_modules/socket.io-client/build/esm/url.js

/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        obj = parse(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}

;// ./node_modules/socket.io-parser/build/esm/is-binary.js
const is_binary_withNativeArrayBuffer = typeof ArrayBuffer === "function";
const is_binary_isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const is_binary_toString = Object.prototype.toString;
const is_binary_withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        is_binary_toString.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        is_binary_toString.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((is_binary_withNativeArrayBuffer && (obj instanceof ArrayBuffer || is_binary_isView(obj))) ||
        (is_binary_withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}

;// ./node_modules/socket.io-parser/build/esm/binary.js

/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (isBinary(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
}
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" &&
            data.num >= 0 &&
            data.num < buffers.length;
        if (isIndexValid) {
            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        }
        else {
            throw new Error("illegal attachments");
        }
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}

;// ./node_modules/socket.io-parser/build/esm/index.js



/**
 * These strings must not be used as event names, as they have a special meaning.
 */
const RESERVED_EVENTS = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener", // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
const build_esm_protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(replacer) {
        this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if (hasBinary(obj)) {
                return this.encodeAsBinary({
                    type: obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK,
                    nsp: obj.nsp,
                    data: obj.data,
                    id: obj.id,
                });
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data, this.replacer);
        }
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = deconstructPacket(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
    return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(reviver) {
        super();
        this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            if (this.reconstructor) {
                throw new Error("got plaintext data when reconstructing a packet");
            }
            packet = this.decodeString(obj);
            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        }
        else if (isBinary(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = this.tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        return p;
    }
    tryParse(str) {
        try {
            return JSON.parse(str, this.reviver);
        }
        catch (e) {
            return false;
        }
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return isObject(payload);
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || isObject(payload);
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return (Array.isArray(payload) &&
                    (typeof payload[0] === "number" ||
                        (typeof payload[0] === "string" &&
                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
        }
    }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = reconstructPacket(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}

;// ./node_modules/socket.io-client/build/esm/on.js
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}

;// ./node_modules/socket.io-client/build/esm/socket.js



/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const socket_RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
});
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */
class socket_Socket extends Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io, nsp, opts) {
        super();
        /**
         * Whether the socket is currently connected to the server.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log(socket.connected); // true
         * });
         *
         * socket.on("disconnect", () => {
         *   console.log(socket.connected); // false
         * });
         */
        this.connected = false;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted by the server.
         */
        this.recovered = false;
        /**
         * Buffer for packets received before the CONNECT packet
         */
        this.receiveBuffer = [];
        /**
         * Buffer for packets that will be sent once the socket is connected
         */
        this.sendBuffer = [];
        /**
         * The queue of packets to be sent with retry in case of failure.
         *
         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
         * @private
         */
        this._queue = [];
        /**
         * A sequence to generate the ID of the {@link QueuedPacket}.
         * @private
         */
        this._queueSeq = 0;
        this.ids = 0;
        /**
         * A map containing acknowledgement handlers.
         *
         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
         *
         * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
         * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
         * - `const value = await socket.emitWithAck("test")`
         *
         * From those that don't:
         *
         * - `socket.emit("test", (value) => { ... });`
         *
         * In the first case, the handlers will be called with an error when:
         *
         * - the timeout is reached
         * - the socket gets disconnected
         *
         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
         * an acknowledgement from the server.
         *
         * @private
         */
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
        return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            on(io, "open", this.onopen.bind(this)),
            on(io, "packet", this.onpacket.bind(this)),
            on(io, "error", this.onerror.bind(this)),
            on(io, "close", this.onclose.bind(this)),
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
        var _a, _b, _c;
        if (socket_RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(args);
            return this;
        }
        const packet = {
            type: PacketType.EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
        const discardPacket = this.flags.volatile && !isTransportWritable;
        if (discardPacket) {
        }
        else if (isConnected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
        var _a;
        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                    this.sendBuffer.splice(i, 1);
                }
            }
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        const fn = (...args) => {
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, args);
        };
        fn.withError = true;
        this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
            const fn = (arg1, arg2) => {
                return arg1 ? reject(arg1) : resolve(arg2);
            };
            fn.withError = true;
            args.push(fn);
            this.emit(ev, ...args);
        });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
            ack = args.pop();
        }
        const packet = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args,
            flags: Object.assign({ fromQueue: true }, this.flags),
        };
        args.push((err, ...responseArgs) => {
            if (packet !== this._queue[0]) {
                // the packet has already been acknowledged
                return;
            }
            const hasError = err !== null;
            if (hasError) {
                if (packet.tryCount > this._opts.retries) {
                    this._queue.shift();
                    if (ack) {
                        ack(err);
                    }
                }
            }
            else {
                this._queue.shift();
                if (ack) {
                    ack(null, ...responseArgs);
                }
            }
            packet.pending = false;
            return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
        if (!this.connected || this._queue.length === 0) {
            return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
            return;
        }
        packet.pending = true;
        packet.tryCount++;
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this._sendConnectPacket(data);
            });
        }
        else {
            this._sendConnectPacket(this.auth);
        }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data) {
        this.packet({
            type: PacketType.CONNECT,
            data: this._pid
                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)
                : data,
        });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
        this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
    _clearAcks() {
        Object.keys(this.acks).forEach((id) => {
            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
            if (!isBuffered) {
                // note: handlers that do not accept an error as first argument are ignored here
                const ack = this.acks[id];
                delete this.acks[id];
                if (ack.withError) {
                    ack.call(this, new Error("socket has been disconnected"));
                }
            }
        });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case PacketType.CONNECT:
                if (packet.data && packet.data.sid) {
                    this.onconnect(packet.data.sid, packet.data.pid);
                }
                else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case PacketType.DISCONNECT:
                this.ondisconnect();
                break;
            case PacketType.CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        if (null != packet.id) {
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
            this._lastOffset = args[args.length - 1];
        }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            self.packet({
                type: PacketType.ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack !== "function") {
            return;
        }
        delete this.acks[packet.id];
        // @ts-ignore FIXME ack is incorrectly inferred as 'never'
        if (ack.withError) {
            packet.data.unshift(null);
        }
        // @ts-ignore
        ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id, pid) {
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid; // defined only if connection state recovery is enabled
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        });
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
        if (this.connected) {
            this.packet({ type: PacketType.DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, packet.data);
            }
        }
    }
}

;// ./node_modules/socket.io-client/build/esm/contrib/backo2.js
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */
function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
}
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */
Backoff.prototype.duration = function () {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */
Backoff.prototype.reset = function () {
    this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */
Backoff.prototype.setMin = function (min) {
    this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */
Backoff.prototype.setMax = function (max) {
    this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */
Backoff.prototype.setJitter = function (jitter) {
    this.jitter = jitter;
};

;// ./node_modules/socket.io-client/build/esm/manager.js






class Manager extends Emitter {
    constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        installTimerFunctions(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || socket_io_parser_build_esm_namespaceObject;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        if (!v) {
            this.skipReconnect = true;
        }
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
        if (~this._readyState.indexOf("open"))
            return this;
        this.engine = new Socket(this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSubDestroy = on(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        const onError = (err) => {
            this.cleanup();
            this._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                this.maybeReconnectOnOpen();
            }
        };
        // emit `error`
        const errorSub = on(socket, "error", onError);
        if (false !== this._timeout) {
            const timeout = this._timeout;
            // set timer
            const timer = this.setTimeoutFn(() => {
                openSubDestroy();
                onError(new Error("timeout"));
                socket.close();
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push(on(socket, "ping", this.onping.bind(this)), on(socket, "data", this.ondata.bind(this)), on(socket, "error", this.onerror.bind(this)), on(socket, "close", this.onclose.bind(this)), 
        // @ts-ignore
        on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        try {
            this.decoder.add(data);
        }
        catch (e) {
            this.onclose("parse error", e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
        nextTick(() => {
            this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new socket_Socket(this, nsp, opts);
            this.nsps[nsp] = socket;
        }
        else if (this._autoConnect && !socket.active) {
            socket.connect();
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
            const socket = this.nsps[nsp];
            if (socket.active) {
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called when:
     *
     * - the low-level engine is closed
     * - the parser encountered a badly formatted packet
     * - all sockets are disconnected
     *
     * @private
     */
    onclose(reason, description) {
        var _a;
        this.cleanup();
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect)
                    return;
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    }
                    else {
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(() => {
                this.clearTimeoutFn(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}

;// ./node_modules/socket.io-client/build/esm/index.js



/**
 * Managers cache.
 */
const cache = {};
function esm_lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = url(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        io = new Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            cache[id] = new Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(esm_lookup, {
    Manager: Manager,
    Socket: socket_Socket,
    io: esm_lookup,
    connect: esm_lookup,
});
/**
 * Protocol version.
 *
 * @public
 */

/**
 * Expose constructors for standalone build.
 *
 * @public
 */



// EXTERNAL MODULE: ./node_modules/mediasoup-client/lib/index.js
var lib = __webpack_require__(76);
// EXTERNAL MODULE: ./node_modules/debug/src/browser.js
var browser = __webpack_require__(7833);
var browser_default = /*#__PURE__*/__webpack_require__.n(browser);
;// ./src/lib/Logger.js



var APP_NAME = "mediasoup-demo";
var Logger = /*#__PURE__*/function () {
  function Logger(prefix) {
    (0,classCallCheck/* default */.A)(this, Logger);
    if (prefix) {
      this._debug = browser_default()("".concat(APP_NAME, ":").concat(prefix));
      this._warn = browser_default()("".concat(APP_NAME, ":WARN:").concat(prefix));
      this._error = browser_default()("".concat(APP_NAME, ":ERROR:").concat(prefix));
    } else {
      this._debug = browser_default()(APP_NAME);
      this._warn = browser_default()("".concat(APP_NAME, ":WARN"));
      this._error = browser_default()("".concat(APP_NAME, ":ERROR"));
    }
    browser_default().disable();
    /* eslint-disable no-console */
    this._debug.log = console.info.bind(console);
    this._warn.log = console.warn.bind(console);
    this._error.log = console.error.bind(console);
    /* eslint-enable no-console */
  }
  return (0,createClass/* default */.A)(Logger, [{
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }, {
    key: "warn",
    get: function get() {
      return this._warn;
    }
  }, {
    key: "error",
    get: function get() {
      return this._error;
    }
  }]);
}();

;// ./src/lib/urlFactory.js



function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var CryptoJS = __webpack_require__(1396);
var KEY = CryptoJS.enc.Latin1.parse("6gf9Oz5Y(6fOWPP@3XPv0Mwp51yfJ0HiZW^0*!9NdUuZ*VdKmRC@f))&^!Iriw)q");
var IV = CryptoJS.enc.Latin1.parse("BHrabik^$W^y*HL@A*$4YKj(");
function getServerConfig(_x) {
  return _getServerConfig.apply(this, arguments);
}
function _getServerConfig() {
  _getServerConfig = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2(_ref) {
    var roomId, secret, signalingBaseUrl, host, iceServers, observabilityJwt, traces, logs, metaData, signalingUrl, socketUrl, socketPath, _yield$fetch$then$cat, data, success, error, observability;
    return regenerator_default().wrap(function (_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          roomId = _ref.roomId, secret = _ref.secret, signalingBaseUrl = _ref.signalingBaseUrl;
          // let host = `${window.location.hostname}:4443`;
          host = "call-api.videosdk.live"; // let host = `${"192.168.0.185"}:4443`;
          iceServers = [];
          observabilityJwt = null;
          traces = {};
          logs = {};
          metaData = {};
          signalingUrl = null;
          socketUrl = null;
          socketPath = null;
          _context2.next = 1;
          return fetch("https://".concat(signalingBaseUrl, "/infra/v1/meetings/init-config"), {
            method: "POST",
            headers: {
              Authorization: secret,
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              roomId: roomId
            })
          }).then(/*#__PURE__*/function () {
            var _ref2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(response) {
              var res;
              return regenerator_default().wrap(function (_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 1;
                    return response.json();
                  case 1:
                    res = _context.sent;
                    return _context.abrupt("return", _objectSpread({
                      success: response.status == 200
                    }, res));
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function (_x2) {
              return _ref2.apply(this, arguments);
            };
          }())["catch"](function (error) {
            return {
              success: false
            };
          });
        case 1:
          _yield$fetch$then$cat = _context2.sent;
          data = _yield$fetch$then$cat.data;
          success = _yield$fetch$then$cat.success;
          error = _yield$fetch$then$cat.error;
          if (success) {
            _context2.next = 2;
            break;
          }
          throw Error(error !== null && error !== void 0 ? error : "Error getting server configurations");
        case 2:
          if (data) {
            host = data.baseUrl;
            observability = data.observability;
            iceServers = AES_DECRYPT(data.iceServers);
            observabilityJwt = observability.jwt;
            traces = observability.traces;
            logs = observability.logs;
            metaData = observability.metaData;
            signalingUrl = data.signalingUrl;
            socketPath = data.socketPath;
            socketUrl = data.socketUrl;
          }
          return _context2.abrupt("return", {
            baseUrl: host,
            iceServers: iceServers,
            observabilityJwt: observabilityJwt,
            traces: traces,
            logs: logs,
            metaData: metaData,
            signalingUrl: signalingUrl,
            socketPath: socketPath,
            socketUrl: socketUrl
          });
        case 3:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _getServerConfig.apply(this, arguments);
}
function AES_DECRYPT(value) {
  try {
    var bytes = CryptoJS.AES.decrypt(value, KEY, {
      iv: IV,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.ZeroPadding
    });
    var plaintext = bytes.toString(CryptoJS.enc.Utf8);
    return JSON.parse(plaintext);
  } catch (error) {
    return [];
  }
}
// EXTERNAL MODULE: ./node_modules/js-cookie/src/js.cookie.js
var js_cookie = __webpack_require__(2215);
var js_cookie_default = /*#__PURE__*/__webpack_require__.n(js_cookie);
;// ./src/lib/cookiesManager.js

var USER_COOKIE = "mediasoup-demo.user";
var DEVICES_COOKIE = "mediasoup-demo.devices";
function getUser() {
  return jsCookie.getJSON(USER_COOKIE);
}
function setUser(_ref) {
  var displayName = _ref.displayName;
  js_cookie_default().set(USER_COOKIE, {
    displayName: displayName
  });
}
function getDevices() {
  return js_cookie_default().getJSON(DEVICES_COOKIE);
}
function setDevices(_ref2) {
  var webcamEnabled = _ref2.webcamEnabled;
  jsCookie.set(DEVICES_COOKIE, {
    webcamEnabled: webcamEnabled
  });
}
// EXTERNAL MODULE: ./node_modules/random-string/lib/random-string.js
var random_string = __webpack_require__(2211);
var random_string_default = /*#__PURE__*/__webpack_require__.n(random_string);
;// ./src/lib/redux/stateActions.js
var setRoomUrl = function setRoomUrl(url) {
  return {
    type: 'SET_ROOM_URL',
    payload: {
      url: url
    }
  };
};
var setRoomState = function setRoomState(state) {
  return {
    type: 'SET_ROOM_STATE',
    payload: {
      state: state
    }
  };
};
var setRoomActiveSpeaker = function setRoomActiveSpeaker(peerId) {
  return {
    type: 'SET_ROOM_ACTIVE_SPEAKER',
    payload: {
      peerId: peerId
    }
  };
};
var setRoomStatsPeerId = function setRoomStatsPeerId(peerId) {
  return {
    type: 'SET_ROOM_STATS_PEER_ID',
    payload: {
      peerId: peerId
    }
  };
};
var setRoomFaceDetection = function setRoomFaceDetection(flag) {
  return {
    type: 'SET_FACE_DETECTION',
    payload: flag
  };
};
var setMe = function setMe(_ref) {
  var peerId = _ref.peerId,
    displayName = _ref.displayName,
    displayNameSet = _ref.displayNameSet,
    device = _ref.device;
  return {
    type: 'SET_ME',
    payload: {
      peerId: peerId,
      displayName: displayName,
      displayNameSet: displayNameSet,
      device: device
    }
  };
};
var setMediaCapabilities = function setMediaCapabilities(_ref2) {
  var canSendMic = _ref2.canSendMic,
    canSendWebcam = _ref2.canSendWebcam;
  return {
    type: 'SET_MEDIA_CAPABILITIES',
    payload: {
      canSendMic: canSendMic,
      canSendWebcam: canSendWebcam
    }
  };
};
var setCanChangeWebcam = function setCanChangeWebcam(flag) {
  return {
    type: 'SET_CAN_CHANGE_WEBCAM',
    payload: flag
  };
};
var setDisplayName = function setDisplayName(displayName) {
  return {
    type: 'SET_DISPLAY_NAME',
    payload: {
      displayName: displayName
    }
  };
};
var setAudioOnlyState = function setAudioOnlyState(enabled) {
  return {
    type: 'SET_AUDIO_ONLY_STATE',
    payload: {
      enabled: enabled
    }
  };
};
var setAudioOnlyInProgress = function setAudioOnlyInProgress(flag) {
  return {
    type: 'SET_AUDIO_ONLY_IN_PROGRESS',
    payload: {
      flag: flag
    }
  };
};
var setAudioMutedState = function setAudioMutedState(enabled) {
  return {
    type: 'SET_AUDIO_MUTED_STATE',
    payload: {
      enabled: enabled
    }
  };
};
var setRestartIceInProgress = function setRestartIceInProgress(flag) {
  return {
    type: 'SET_RESTART_ICE_IN_PROGRESS',
    payload: {
      flag: flag
    }
  };
};
var addProducer = function addProducer(producer) {
  return {
    type: 'ADD_PRODUCER',
    payload: {
      producer: producer
    }
  };
};
var removeProducer = function removeProducer(producerId) {
  return {
    type: 'REMOVE_PRODUCER',
    payload: {
      producerId: producerId
    }
  };
};
var setProducerPaused = function setProducerPaused(producerId) {
  return {
    type: 'SET_PRODUCER_PAUSED',
    payload: {
      producerId: producerId
    }
  };
};
var setProducerResumed = function setProducerResumed(producerId) {
  return {
    type: 'SET_PRODUCER_RESUMED',
    payload: {
      producerId: producerId
    }
  };
};
var setProducerTrack = function setProducerTrack(producerId, track) {
  return {
    type: 'SET_PRODUCER_TRACK',
    payload: {
      producerId: producerId,
      track: track
    }
  };
};
var setProducerScore = function setProducerScore(producerId, score) {
  return {
    type: 'SET_PRODUCER_SCORE',
    payload: {
      producerId: producerId,
      score: score
    }
  };
};
var addDataProducer = function addDataProducer(dataProducer) {
  return {
    type: 'ADD_DATA_PRODUCER',
    payload: {
      dataProducer: dataProducer
    }
  };
};
var removeDataProducer = function removeDataProducer(dataProducerId) {
  return {
    type: 'REMOVE_DATA_PRODUCER',
    payload: {
      dataProducerId: dataProducerId
    }
  };
};
var setWebcamInProgress = function setWebcamInProgress(flag) {
  return {
    type: 'SET_WEBCAM_IN_PROGRESS',
    payload: {
      flag: flag
    }
  };
};
var setShareInProgress = function setShareInProgress(flag) {
  return {
    type: 'SET_SHARE_IN_PROGRESS',
    payload: {
      flag: flag
    }
  };
};
var addPeer = function addPeer(peer) {
  return {
    type: 'ADD_PEER',
    payload: {
      peer: peer
    }
  };
};
var removePeer = function removePeer(peerId) {
  return {
    type: 'REMOVE_PEER',
    payload: {
      peerId: peerId
    }
  };
};
var setPeerDisplayName = function setPeerDisplayName(displayName, peerId) {
  return {
    type: 'SET_PEER_DISPLAY_NAME',
    payload: {
      displayName: displayName,
      peerId: peerId
    }
  };
};
var addConsumer = function addConsumer(consumer, peerId) {
  return {
    type: 'ADD_CONSUMER',
    payload: {
      consumer: consumer,
      peerId: peerId
    }
  };
};
var removeConsumer = function removeConsumer(consumerId, peerId) {
  return {
    type: 'REMOVE_CONSUMER',
    payload: {
      consumerId: consumerId,
      peerId: peerId
    }
  };
};
var setConsumerPaused = function setConsumerPaused(consumerId, originator) {
  return {
    type: 'SET_CONSUMER_PAUSED',
    payload: {
      consumerId: consumerId,
      originator: originator
    }
  };
};
var setConsumerResumed = function setConsumerResumed(consumerId, originator) {
  return {
    type: 'SET_CONSUMER_RESUMED',
    payload: {
      consumerId: consumerId,
      originator: originator
    }
  };
};
var setConsumerCurrentLayers = function setConsumerCurrentLayers(consumerId, spatialLayer, temporalLayer) {
  return {
    type: 'SET_CONSUMER_CURRENT_LAYERS',
    payload: {
      consumerId: consumerId,
      spatialLayer: spatialLayer,
      temporalLayer: temporalLayer
    }
  };
};
var stateActions_setConsumerPreferredLayers = function setConsumerPreferredLayers(consumerId, spatialLayer, temporalLayer) {
  return {
    type: 'SET_CONSUMER_PREFERRED_LAYERS',
    payload: {
      consumerId: consumerId,
      spatialLayer: spatialLayer,
      temporalLayer: temporalLayer
    }
  };
};
var stateActions_setConsumerPriority = function setConsumerPriority(consumerId, priority) {
  return {
    type: 'SET_CONSUMER_PRIORITY',
    payload: {
      consumerId: consumerId,
      priority: priority
    }
  };
};
var setConsumerTrack = function setConsumerTrack(consumerId, track) {
  return {
    type: 'SET_CONSUMER_TRACK',
    payload: {
      consumerId: consumerId,
      track: track
    }
  };
};
var setConsumerScore = function setConsumerScore(consumerId, score) {
  return {
    type: 'SET_CONSUMER_SCORE',
    payload: {
      consumerId: consumerId,
      score: score
    }
  };
};
var addDataConsumer = function addDataConsumer(dataConsumer, peerId) {
  return {
    type: 'ADD_DATA_CONSUMER',
    payload: {
      dataConsumer: dataConsumer,
      peerId: peerId
    }
  };
};
var removeDataConsumer = function removeDataConsumer(dataConsumerId, peerId) {
  return {
    type: 'REMOVE_DATA_CONSUMER',
    payload: {
      dataConsumerId: dataConsumerId,
      peerId: peerId
    }
  };
};
var addNotification = function addNotification(notification) {
  return {
    type: 'ADD_NOTIFICATION',
    payload: {
      notification: notification
    }
  };
};
var removeNotification = function removeNotification(notificationId) {
  return {
    type: 'REMOVE_NOTIFICATION',
    payload: {
      notificationId: notificationId
    }
  };
};
var removeAllNotifications = function removeAllNotifications() {
  return {
    type: 'REMOVE_ALL_NOTIFICATIONS'
  };
};
;// ./src/lib/redux/requestActions.js



// This returns a redux-thunk action (a function).
var notify = function notify(_ref) {
  var _ref$type = _ref.type,
    type = _ref$type === void 0 ? 'info' : _ref$type,
    text = _ref.text,
    title = _ref.title,
    timeout = _ref.timeout;
  if (!timeout) {
    switch (type) {
      case 'info':
        timeout = 3000;
        break;
      case 'error':
        timeout = 5000;
        break;
    }
  }
  var notification = {
    id: random_string_default()({
      length: 6
    }).toLowerCase(),
    type: type,
    title: title,
    text: text,
    timeout: timeout
  };
  return function (dispatch) {
    dispatch(addNotification(notification));
    setTimeout(function () {
      dispatch(removeNotification(notification.id));
    }, timeout);
  };
};
// EXTERNAL MODULE: ./node_modules/events/events.js
var events = __webpack_require__(7007);
// EXTERNAL MODULE: ./src/lib/sdkCapabilities.js
var sdkCapabilities = __webpack_require__(1803);
// EXTERNAL MODULE: ./src/config.js
var config = __webpack_require__(9027);
// EXTERNAL MODULE: ./src/constants/errors.js
var errors = __webpack_require__(7080);
;// ./src/constants/meetingConnectionState.js
var state = {
  CONNECTING: "CONNECTING",
  CONNECTED: "CONNECTED",
  RECONNECTING: "RECONNECTING",
  FAILED: "FAILED",
  DISCONNECTED: "DISCONNECTED"
};
// EXTERNAL MODULE: ./node_modules/@videosdk.live/room-stats/dist/videosdk-room-stats.js
var videosdk_room_stats = __webpack_require__(5414);
// EXTERNAL MODULE: ./src/constants/modes.js
var modes = __webpack_require__(2107);
// EXTERNAL MODULE: ./src/constants/hlsEvents.js
var hlsEvents = __webpack_require__(5071);
;// ./src/lib/open-telemetry/helpers.js
var SPAN_ID_BYTES = 8;
var TRACE_ID_BYTES = 16;
var SHARED_CHAR_CODES_ARRAY = Array(32);
function getTraceId() {
  for (var i = 0; i < TRACE_ID_BYTES * 2; i++) {
    SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
    // valid hex characters in the range 48-57 and 97-102
    if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
      SHARED_CHAR_CODES_ARRAY[i] += 39;
    }
  }
  return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, TRACE_ID_BYTES * 2));
}
function getSpanId() {
  for (var i = 0; i < SPAN_ID_BYTES * 2; i++) {
    SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
    // valid hex characters in the range 48-57 and 97-102
    if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
      SHARED_CHAR_CODES_ARRAY[i] += 39;
    }
  }
  return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, SPAN_ID_BYTES * 2));
}
function getCurrentTimeInNano() {
  // Get current time in milliseconds since the Unix epoch
  var currentTimeMillis = new Date().getTime();

  // Convert milliseconds to nanoseconds (1 millisecond = 1,000,000 nanoseconds)
  var currentTimeNano = currentTimeMillis * 1e6;

  // Format the result as a 19-digit number (padded with zeros if necessary)
  var formattedTimeNano = currentTimeNano.toString().padEnd(19, "0");
  return Number(formattedTimeNano);
}

// generate random string of n characters
function getRandomString(length) {
  var characters = "0123456789abcdefghijklmnopqrstuvwxyz"; // characters used in string
  var result = ""; // initialize the result variable passed out of the function
  for (var i = length; i > 0; i--) {
    result += characters[Math.floor(Math.random() * characters.length)];
  }
  return result;
}

// console.log(randomString(6));


;// ./src/lib/open-telemetry/OTEL.js







function OTEL_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function OTEL_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? OTEL_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : OTEL_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }

var VideoSDKTelemetery = /*#__PURE__*/function () {
  function VideoSDKTelemetery(_ref) {
    var _this = this;
    var roomId = _ref.roomId,
      peerId = _ref.peerId,
      sdkName = _ref.sdkName,
      observabilityJwt = _ref.observabilityJwt,
      metaData = _ref.metaData,
      traces = _ref.traces;
    (0,classCallCheck/* default */.A)(this, VideoSDKTelemetery);
    this._traceId = getTraceId();
    this._rootSpanId = getSpanId();
    this._observabilityJwt = observabilityJwt;
    this._tracesEnabled = traces.enabled;
    this._tracesEndpoint = traces.endPoint;
    var randomString = getRandomString(8);
    this._spans = [];
    this._traceJSON = {
      resourceSpans: [{
        resource: {
          attributes: [{
            key: "service.name",
            value: {
              stringValue: "videosdk-otel"
            }
          }, {
            key: "telemetry.sdk.language",
            value: {
              stringValue: "webjs"
            }
          }, {
            key: "telemetry.sdk.name",
            value: {
              stringValue: "opentelemetry"
            }
          }, {
            key: "telemetry.sdk.version",
            value: {
              stringValue: "1.14.0"
            }
          }, {
            key: "sdk-version",
            value: {
              stringValue: "0.3.4"
            }
          }],
          droppedAttributesCount: 0
        },
        scopeSpans: [{
          scope: {
            name: randomString
          },
          spans: []
        }]
      }]
    };
    if (this._tracesEnabled) {
      this.addRootSpan(roomId, peerId, sdkName, metaData);
      setInterval(function () {
        _this.processQueue();
      }, 4000);
    }
  }
  return (0,createClass/* default */.A)(VideoSDKTelemetery, [{
    key: "addRootSpan",
    value: function addRootSpan(roomId, peerId, sdkName, metaData) {
      var rootSpan = {
        traceId: this._traceId,
        spanId: this._rootSpanId,
        name: "room_".concat(roomId, "_peer_").concat(peerId, "_sdk_").concat(sdkName),
        kind: 1,
        startTimeUnixNano: getCurrentTimeInNano(),
        endTimeUnixNano: getCurrentTimeInNano(),
        attributes: [{
          key: "roomId",
          value: {
            stringValue: roomId
          }
        }, {
          key: "peerId",
          value: {
            stringValue: peerId
          }
        }, {
          key: "sdkName",
          value: {
            stringValue: sdkName
          }
        }, {
          key: "userId",
          value: {
            stringValue: metaData.userId
          }
        }, {
          key: "email",
          value: {
            stringValue: metaData.email
          }
        }],
        droppedAttributesCount: 0,
        events: [],
        droppedEventsCount: 0,
        status: {
          code: 0
        },
        links: [],
        droppedLinksCount: 0
      };
      this._spans.push(rootSpan);
    }
  }, {
    key: "addSpanToTrace",
    value: function addSpanToTrace(spanObj) {
      this._spans.push(spanObj);
    }
  }, {
    key: "trace",
    value: function trace(_ref2) {
      var spanName = _ref2.spanName,
        _ref2$attributes = _ref2.attributes,
        attributes = _ref2$attributes === void 0 ? {} : _ref2$attributes,
        _ref2$span = _ref2.span,
        span = _ref2$span === void 0 ? undefined : _ref2$span;
      if (this._tracesEnabled) {
        var spanId = getSpanId();
        var startTimeUnixNano = getCurrentTimeInNano();
        var spanObj = {
          traceId: this._traceId,
          spanId: spanId,
          parentSpanId: span || this._rootSpanId,
          name: spanName,
          kind: 1,
          startTimeUnixNano: startTimeUnixNano,
          droppedAttributesCount: 0,
          events: [],
          droppedEventsCount: 0,
          links: [],
          droppedLinksCount: 0
        };
        if (Object.keys(attributes).length > 0) {
          spanObj.attributes = Object.entries(attributes).map(function (_ref3) {
            var _ref4 = (0,slicedToArray/* default */.A)(_ref3, 2),
              key = _ref4[0],
              value = _ref4[1];
            return {
              key: key,
              value: {
                stringValue: value
              }
            };
          });
        }
        this.addSpanToTrace(spanObj);
        return spanId;
      }
    }
  }, {
    key: "traceAutoComplete",
    value: function traceAutoComplete(_ref5) {
      var spanName = _ref5.spanName,
        _ref5$attributes = _ref5.attributes,
        attributes = _ref5$attributes === void 0 ? {} : _ref5$attributes,
        _ref5$status = _ref5.status,
        status = _ref5$status === void 0 ? 1 : _ref5$status,
        _ref5$span = _ref5.span,
        span = _ref5$span === void 0 ? undefined : _ref5$span,
        _ref5$message = _ref5.message,
        message = _ref5$message === void 0 ? "SUCCESS" : _ref5$message;
      if (this._tracesEnabled) {
        var spanId = getSpanId();
        var startTimeUnixNano = getCurrentTimeInNano();
        var endTimeUnixNano = getCurrentTimeInNano();
        var spanObj = {
          traceId: this._traceId,
          spanId: spanId,
          parentSpanId: span || this._rootSpanId,
          name: spanName,
          kind: 1,
          startTimeUnixNano: startTimeUnixNano,
          endTimeUnixNano: endTimeUnixNano,
          droppedAttributesCount: 0,
          events: [],
          droppedEventsCount: 0,
          links: [],
          droppedLinksCount: 0,
          status: {
            code: status,
            message: message
          }
        };
        if (Object.keys(attributes).length > 0) {
          spanObj.attributes = Object.entries(attributes).map(function (_ref6) {
            var _ref7 = (0,slicedToArray/* default */.A)(_ref6, 2),
              key = _ref7[0],
              value = _ref7[1];
            return {
              key: key,
              value: {
                stringValue: value
              }
            };
          });
        }
        this.addSpanToTrace(spanObj);
      }
    }
  }, {
    key: "completeSpan",
    value: function completeSpan(_ref8) {
      var span = _ref8.span,
        status = _ref8.status,
        message = _ref8.message,
        _ref8$attributes = _ref8.attributes,
        attributes = _ref8$attributes === void 0 ? {} : _ref8$attributes;
      if (this._tracesEnabled) {
        // Get the current time in nanoseconds
        var endTimeUnixNano = getCurrentTimeInNano();

        // Map over the spans array and update the relevant span
        this._spans = this._spans.map(function (obj) {
          // Check if the current object's spanId matches the specified span
          if (obj.spanId !== span) {
            // If not, return the original object unchanged
            return obj;
          }

          // Map over attributes and create an array of key-value pairs
          var updatedAttributes = Object.entries(attributes).map(function (_ref9) {
            var _ref0 = (0,slicedToArray/* default */.A)(_ref9, 2),
              key = _ref0[0],
              value = _ref0[1];
            return {
              key: key,
              value: {
                stringValue: value
              }
            };
          });

          // Update obj.attributes with the new attributes, handling the case when it's undefined
          obj.attributes = obj.attributes ? [].concat((0,toConsumableArray/* default */.A)(obj.attributes), (0,toConsumableArray/* default */.A)(updatedAttributes)) : updatedAttributes;

          // Return the updated object with the new status, message, and endTimeUnixNano
          return OTEL_objectSpread(OTEL_objectSpread({}, obj), {}, {
            status: {
              code: status,
              message: message
            },
            endTimeUnixNano: endTimeUnixNano
          });
        });
      }
    }
  }, {
    key: "processQueue",
    value: function processQueue() {
      var _this2 = this;
      if (this._spans.length > 0) {
        this._traceJSON.resourceSpans[0].scopeSpans[0].spans = this._spans;
        this._spans = [];
        var requestOptions = {
          method: "POST",
          headers: {
            Authorization: this._observabilityJwt,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(this._traceJSON)
        };
        fetch(this._tracesEndpoint, requestOptions).then(/*#__PURE__*/function () {
          var _ref1 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(response) {
            return regenerator_default().wrap(function (_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _this2._traceJSON.resourceSpans[0].scopeSpans[0].spans = [];
                  _context.next = 1;
                  return response.text();
                case 1:
                  return _context.abrupt("return", _context.sent);
                case 2:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x) {
            return _ref1.apply(this, arguments);
          };
        }()).then(function (data) {})["catch"](function (error) {
          _this2._spans = _this2._traceJSON.resourceSpans[0].scopeSpans[0].spans;
          console.error("There was a problem with the POST request:", error);
        });
      }
    }
  }]);
}();

;// ./src/lib/open-telemetry/videosdkLogs.js





function videosdkLogs_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function videosdkLogs_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? videosdkLogs_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : videosdkLogs_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var VideoSDKLogs = /*#__PURE__*/function () {
  function VideoSDKLogs(_ref) {
    var roomId = _ref.roomId,
      peerId = _ref.peerId,
      logs = _ref.logs,
      observabilityJwt = _ref.observabilityJwt,
      deviceInfo = _ref.deviceInfo,
      sessionId = _ref.sessionId,
      debugMode = _ref.debugMode;
    (0,classCallCheck/* default */.A)(this, VideoSDKLogs);
    var browserUserAgent = deviceInfo.browserUserAgent,
      deviceUserAgent = deviceInfo.deviceUserAgent,
      platform = deviceInfo.platform;
    this._peerId = peerId;
    this._roomId = roomId;
    this._logs = logs;
    this._observabilityJwt = observabilityJwt;
    this._deviceInfo = deviceInfo;
    this._sessionId = sessionId;
    this._debugMode = debugMode;
    this.browserOrDeviceInfo = browserUserAgent ? {
      browserName: browserUserAgent.browser.name,
      browserVersion: browserUserAgent.browser.version,
      osName: browserUserAgent.os.name,
      osVersion: browserUserAgent.os.version,
      platform: platform
    } : deviceUserAgent ? videosdkLogs_objectSpread({
      platform: platform
    }, deviceUserAgent) : null;
  }
  return (0,createClass/* default */.A)(VideoSDKLogs, [{
    key: "pushLogs",
    value: function () {
      var _pushLogs = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(_ref2) {
        var logType, logText, attributes, _ref2$dashboardLog, dashboardLog, _this$_logs, enabled, endPoint;
        return regenerator_default().wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              logType = _ref2.logType, logText = _ref2.logText, attributes = _ref2.attributes, _ref2$dashboardLog = _ref2.dashboardLog, dashboardLog = _ref2$dashboardLog === void 0 ? false : _ref2$dashboardLog;
              _this$_logs = this._logs, enabled = _this$_logs.enabled, endPoint = _this$_logs.endPoint;
              if (!enabled) {
                _context.next = 2;
                break;
              }
              _context.next = 1;
              return fetch(endPoint, {
                method: "POST",
                headers: {
                  Authorization: this._observabilityJwt,
                  "Content-Type": "application/json"
                },
                body: JSON.stringify({
                  logType: logType,
                  logText: logText,
                  attributes: videosdkLogs_objectSpread(videosdkLogs_objectSpread({}, attributes), {}, {
                    roomId: this._roomId,
                    peerId: this._peerId,
                    SDK: "".concat(this._deviceInfo.sdkType, "-sdk"),
                    SDK_VERSION: this._deviceInfo.sdkVersion,
                    sessionId: this._sessionId
                  }, this.browserOrDeviceInfo),
                  debugMode: this._debugMode,
                  dashboardLog: dashboardLog
                })
              }).then(function (response) {
                return response.json();
              })["catch"](function (error) {
                console.log("error", error);
                return {};
              });
            case 1:
              return _context.abrupt("return", _context.sent);
            case 2:
              return _context.abrupt("return", null);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function pushLogs(_x) {
        return _pushLogs.apply(this, arguments);
      }
      return pushLogs;
    }()
  }]);
}();

// EXTERNAL MODULE: ./src/lib/media.js
var media = __webpack_require__(4973);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js + 1 modules
var possibleConstructorReturn = __webpack_require__(388);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(3954);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__(5501);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
var setPrototypeOf = __webpack_require__(3662);
;// ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}

;// ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}

;// ./node_modules/@babel/runtime/helpers/esm/construct.js


function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && (0,setPrototypeOf/* default */.A)(p, r.prototype), p;
}

;// ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js




function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper(t) {
    if (null === t || !_isNativeFunction(t)) return t;
    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t)) return r.get(t);
      r.set(t, Wrapper);
    }
    function Wrapper() {
      return _construct(t, arguments, (0,getPrototypeOf/* default */.A)(this).constructor);
    }
    return Wrapper.prototype = Object.create(t.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), (0,setPrototypeOf/* default */.A)(Wrapper, t);
  }, _wrapNativeSuper(t);
}

;// ./src/e2ee/errors.js







function _callSuper(t, o, e) { return o = (0,getPrototypeOf/* default */.A)(o), (0,possibleConstructorReturn/* default */.A)(t, errors_isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0,getPrototypeOf/* default */.A)(t).constructor) : o.apply(t, e)); }
function errors_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (errors_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var VideoSdkError = /*#__PURE__*/function (_Error) {
  function VideoSdkError(code, message) {
    var _this;
    (0,classCallCheck/* default */.A)(this, VideoSdkError);
    _this = _callSuper(this, VideoSdkError, [message || 'an error has occured']);
    (0,defineProperty/* default */.A)(_this, "code", void 0);
    _this.name = 'VideoSdkError';
    _this.code = code;
    return _this;
  }
  (0,inherits/* default */.A)(VideoSdkError, _Error);
  return (0,createClass/* default */.A)(VideoSdkError);
}(/*#__PURE__*/_wrapNativeSuper(Error));
var CryptorErrorReason;
(function (CryptorErrorReason) {
  CryptorErrorReason[CryptorErrorReason["InvalidKey"] = 0] = "InvalidKey";
  CryptorErrorReason[CryptorErrorReason["MissingKey"] = 1] = "MissingKey";
  CryptorErrorReason[CryptorErrorReason["InternalError"] = 2] = "InternalError";
})(CryptorErrorReason || (CryptorErrorReason = {}));
// export class CryptorError extends VideoSdkError {
//     constructor(message, reason = CryptorErrorReason.InternalError, participantIdentity) {
//         super(40, message);
//         this.reason = reason;
//         this.participantIdentity = participantIdentity;
//     }
// }

var DeviceUnsupportedError = /*#__PURE__*/function (_VideoSdkError2) {
  function DeviceUnsupportedError(message) {
    var _this2;
    (0,classCallCheck/* default */.A)(this, DeviceUnsupportedError);
    _this2 = _callSuper(this, DeviceUnsupportedError, [21, message !== null && message !== void 0 ? message : 'device is unsupported']);
    _this2.name = 'DeviceUnsupportedError';
    return _this2;
  }
  (0,inherits/* default */.A)(DeviceUnsupportedError, _VideoSdkError2);
  return (0,createClass/* default */.A)(DeviceUnsupportedError);
}(VideoSdkError);
// EXTERNAL MODULE: ./src/e2ee/constants.js
var constants = __webpack_require__(1806);
// EXTERNAL MODULE: ./src/e2ee/events.js
var e2ee_events = __webpack_require__(6746);
// EXTERNAL MODULE: ./src/e2ee/utils.js
var utils = __webpack_require__(8278);
;// ./src/utils/mediaKind.js
function normalizeKind(share, kind) {
  return share ? kind == "audio" ? "shareAudio" : "share" : kind;
}
;// ./src/e2ee/E2eeManager.js






function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

function E2eeManager_callSuper(t, o, e) { return o = (0,getPrototypeOf/* default */.A)(o), (0,possibleConstructorReturn/* default */.A)(t, E2eeManager_isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0,getPrototypeOf/* default */.A)(t).constructor) : o.apply(t, e)); }
function E2eeManager_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (E2eeManager_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }



// import { isLocalTrack } from '../room/utils';




/**
 * @experimental
 */

var E2EEManager = /*#__PURE__*/function (_EventEmitter) {
  function E2EEManager(options) {
    var _this;
    (0,classCallCheck/* default */.A)(this, E2EEManager);
    _this = E2eeManager_callSuper(this, E2EEManager);
    _this.onWorkerMessage = function (ev) {
      var _a, _b;
      var _ev$data = ev.data,
        kind = _ev$data.kind,
        data = _ev$data.data;
      switch (kind) {
        case "error":
          console.error(data.error.message);
          _this.emit(e2ee_events/* EncryptionEvent */.KS.EncryptionError, data.error);
          break;
        case "initAck":
          if (data.enabled) {
            _this.keyProvider.getKeys().forEach(function (keyInfo) {
              _this.postKey(keyInfo);
            });
          }
          break;
        case "enable":
          if (data.enabled) {
            _this.keyProvider.getKeys().forEach(function (keyInfo) {
              _this.postKey(keyInfo);
            });
          }
          if (_this.encryptionEnabled !== data.enabled && data.participantIdentity === _this.room._peerId) {
            _this.emit(e2ee_events/* EncryptionEvent */.KS.ParticipantEncryptionStatusChanged, data.enabled, _this.room.localParticipant);
            _this.encryptionEnabled = data.enabled;
          } else if (data.participantIdentity) {
            var participant = (_b = _this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);
            if (!participant) {
              throw TypeError("couldn't set encryption status, participant not found".concat(data.participantIdentity));
            }
            _this.emit(e2ee_events/* EncryptionEvent */.KS.ParticipantEncryptionStatusChanged, data.enabled, participant);
          }
          break;
        case "ratchetKey":
          _this.keyProvider.emit(e2ee_events/* KeyProviderEvent */.fo.KeyRatcheted, data.material, data.keyIndex);
          break;
        case "e2eeStateChange":
          _this.emit(e2ee_events/* EncryptionEvent */.KS.E2EEStateChange, data);
          break;
        default:
          console.log("unknown message kind", ev);
          break;
      }
    };
    _this.onWorkerError = function (ev) {
      var _ev$error;
      console.error("Worker encountered an error:", ev);
      console.error("Error message:", ev.message);
      console.error("Error filename:", ev.filename);
      console.error("Error line number:", ev.lineno);
      console.error("Error stack:", (_ev$error = ev.error) === null || _ev$error === void 0 ? void 0 : _ev$error.stack); // If the worker provides a stack trac
    };
    _this.keyProvider = options.keyProvider;
    _this.worker = options.worker;
    _this.encryptionEnabled = false;
    return _this;
  }
  /**
   * @internal
   */
  (0,inherits/* default */.A)(E2EEManager, _EventEmitter);
  return (0,createClass/* default */.A)(E2EEManager, [{
    key: "setup",
    value: function setup(room) {
      if (!(0,utils/* isE2EESupported */.Ag)()) {
        throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
      }
      console.info("setting up e2ee");
      if (room !== this.room) {
        this.room = room;
        this.setupEventListeners(room, this.keyProvider);
        // this.worker = new Worker('');
        this.handleE2EEManagerEvents();
        var msg = {
          kind: "init",
          data: {
            keyProviderOptions: this.keyProvider.getOptions()
          }
        };
        console.log("msg", msg);
        if (this.worker) {
          console.info("initializing worker", {
            worker: this.worker
          });
          this.worker.onmessage = this.onWorkerMessage;
          this.worker.onerror = this.onWorkerError;
          this.worker.postMessage(msg);
        }
      }
    }
    /**
     * @internal
     */
  }, {
    key: "setParticipantCryptorEnabled",
    value: function setParticipantCryptorEnabled(enabled, participantIdentity) {
      console.debug("set e2ee to ".concat(enabled, " for participant ").concat(participantIdentity));
      this.postEnable(enabled, participantIdentity);
    }
    /**
     * @internal
     */
  }, {
    key: "setSifTrailer",
    value: function setSifTrailer(trailer) {
      if (!trailer || trailer.length === 0) {
        console.warn("ignoring server sent trailer as it's empty");
      } else {
        this.postSifTrailer(trailer);
      }
    }
    // setupEngine(engine) {
    //   engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap) => {
    //     this.postRTPMap(rtpMap);
    //   });
    // }
  }, {
    key: "setupEventListeners",
    value: function setupEventListeners(room, keyProvider) {
      var _this2 = this;
      keyProvider.on(e2ee_events/* KeyProviderEvent */.fo.SetKey, function (keyInfo) {
        console.log("### keyInfo", keyInfo);
        _this2.postKey(keyInfo);
      }).on(e2ee_events/* KeyProviderEvent */.fo.RatchetRequest, function (participantId, keyIndex) {
        return _this2.postRatchetRequest(participantId, keyIndex);
      });
    }
  }, {
    key: "postRatchetRequest",
    value: function postRatchetRequest(participantIdentity, keyIndex) {
      if (!this.worker) {
        throw Error("could not ratchet key, worker is missing");
      }
      var msg = {
        kind: "ratchetRequest",
        data: {
          participantIdentity: participantIdentity,
          keyIndex: keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
  }, {
    key: "postKey",
    value: function postKey(_ref) {
      var key = _ref.key,
        participantIdentity = _ref.participantIdentity,
        keyIndex = _ref.keyIndex;
      var _a;
      if (!this.worker) {
        throw Error("could not set key, worker is missing");
      }
      var msg = {
        kind: "setKey",
        data: {
          participantIdentity: participantIdentity,
          isPublisher: participantIdentity === this.room._peerId,
          key: key,
          keyIndex: keyIndex
        }
      };
      this.worker.postMessage(msg);
    }
  }, {
    key: "postEnable",
    value: function postEnable(enabled, participantIdentity) {
      if (this.worker) {
        var enableMsg = {
          kind: "enable",
          data: {
            enabled: enabled,
            participantIdentity: participantIdentity
          }
        };
        this.worker.postMessage(enableMsg);
      } else {
        throw new ReferenceError("failed to enable e2ee, worker is not ready");
      }
    }
  }, {
    key: "postRTPMap",
    value: function postRTPMap(map) {
      var _a;
      if (!this.worker) {
        throw TypeError("could not post rtp map, worker is missing");
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a._peerId)) {
        throw TypeError("could not post rtp map, local participant identity is missing");
      }
      var msg = {
        kind: "setRTPMap",
        data: {
          map: map,
          participantIdentity: this.room._peerId
        }
      };
      this.worker.postMessage(msg);
    }
  }, {
    key: "postSifTrailer",
    value: function postSifTrailer(trailer) {
      if (!this.worker) {
        throw Error("could not post SIF trailer, worker is missing");
      }
      var msg = {
        kind: "setSifTrailer",
        data: {
          trailer: trailer
        }
      };
      this.worker.postMessage(msg);
    }
  }, {
    key: "setupE2EEReceiver",
    value: function setupE2EEReceiver(consumer, peerId) {
      var _consumer$appData;
      this.handleReceiver(consumer, consumer.rtpReceiver, consumer.track.id, peerId, this.extractCodec(consumer.rtpParameters.codecs), normalizeKind((_consumer$appData = consumer.appData) === null || _consumer$appData === void 0 ? void 0 : _consumer$appData.share, consumer.kind));
    }
  }, {
    key: "setupE2EESender",
    value: function setupE2EESender(producer) {
      var _producer$appData;
      if (!producer) {
        console.error("Producer is required to setup E2EE sender");
        return;
      }
      this.handleSender(producer.rtpSender, producer.track.id, this.extractCodec(producer.rtpParameters.codecs), normalizeKind((_producer$appData = producer.appData) === null || _producer$appData === void 0 ? void 0 : _producer$appData.share, producer.kind), this.room._peerId);
    }
    /**
     * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
     * a frame decoder.
     *
     */
  }, {
    key: "handleReceiver",
    value: (function () {
      var _handleReceiver = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(consumer, receiver, trackId, participantIdentity, codec, mediaKind) {
        var options, _consumer$appData2, _msg, writable, readable, msg;
        return regenerator_default().wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.worker) {
                _context.next = 1;
                break;
              }
              return _context.abrupt("return");
            case 1:
              if (!(0,utils/* isScriptTransformSupported */.Wm)()) {
                _context.next = 2;
                break;
              }
              options = {
                kind: "decode",
                participantIdentity: participantIdentity,
                trackId: consumer.track.id,
                codec: codec
              }; // @ts-ignore
              receiver.transform = new RTCRtpScriptTransform(this.worker, options);
              _context.next = 5;
              break;
            case 2:
              if (!(constants/* E2EE_FLAG */.$Q in receiver && codec)) {
                _context.next = 3;
                break;
              }
              // only update codec
              _msg = {
                kind: "updateCodec",
                data: {
                  trackId: trackId,
                  codec: codec,
                  participantIdentity: participantIdentity
                }
              };
              this.worker.postMessage(_msg);
              return _context.abrupt("return");
            case 3:
              // @ts-ignore
              writable = receiver.writableStream; // @ts-ignore
              readable = receiver.readableStream;
              if (!(!writable || !readable)) {
                _context.next = 4;
                break;
              }
              console.error("no writable or readable stream");
              return _context.abrupt("return");
            case 4:
              msg = {
                kind: "decode",
                data: {
                  readableStream: readable,
                  writableStream: writable,
                  trackId: trackId,
                  codec: codec,
                  participantIdentity: participantIdentity,
                  mediaKind: mediaKind,
                  peerId: (_consumer$appData2 = consumer.appData) === null || _consumer$appData2 === void 0 ? void 0 : _consumer$appData2.peerId
                }
              };
              this.worker.postMessage(msg, [readable, writable]);
            case 5:
              // @ts-ignore
              receiver[constants/* E2EE_FLAG */.$Q] = true;
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function handleReceiver(_x, _x2, _x3, _x4, _x5, _x6) {
        return _handleReceiver.apply(this, arguments);
      }
      return handleReceiver;
    }()
    /**
     * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
     * a frame encoder.
     *
     */
    )
  }, {
    key: "handleSender",
    value: function handleSender(sender, trackId, codec, mediaKind, peerId) {
      var _a;
      if (constants/* E2EE_FLAG */.$Q in sender || !this.worker) {
        console.error("### sender already set up");
        return;
      }
      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a._peerId) || this.room._peerId === '') {
        throw TypeError('local identity needs to be known in order to set up encrypted sender');
      }
      if ((0,utils/* isScriptTransformSupported */.Wm)()) {
        console.info("### initialize script transform");
        var options = {
          kind: "encode",
          participantIdentity: this.room._peerId,
          trackId: trackId,
          codec: codec,
          mediaKind: mediaKind,
          peerId: peerId
        };
        // @ts-ignore
        sender.transform = new RTCRtpScriptTransform(this.worker, options);
      } else {
        // @ts-ignore
        try {
          var senderStreams = sender.senderStreams;
          if (senderStreams) {
            var msg = {
              kind: "encode",
              data: {
                readableStream: senderStreams.readable,
                writableStream: senderStreams.writable,
                codec: codec,
                trackId: trackId,
                participantIdentity: this.room._peerId,
                mediaKind: mediaKind,
                peerId: peerId
              }
            };
            this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);
          } else {
            console.error("Error no sender streams found");
          }
        } catch (error) {
          console.log("Error in handle sender ", error);
        }
      }
      // @ts-ignore
      sender[constants/* E2EE_FLAG */.$Q] = true;
    }
  }, {
    key: "handleE2EEManagerEvents",
    value: function handleE2EEManagerEvents() {
      var _this3 = this;
      this.on("NEW_CONSUMER", function (_ref2) {
        var consumer = _ref2.consumer,
          peerId = _ref2.peerId;
        console.log("NEW_CONSUMER", consumer);
        _this3.setupE2EEReceiver(consumer, peerId);
      });
      this.on("NEW_PRODUCER", function (producer) {
        _this3.setupE2EESender(producer);
      });
    }
  }, {
    key: "extractCodec",
    value: function extractCodec(codecs) {
      var codec = "";
      var _iterator = _createForOfIteratorHelper(codecs),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _codec2 = _step.value;
          var _codec = _codec2.mimeType.split("/")[1].toLowerCase();
          if (this.kind === "audio") {
            if (constants/* SUPPORTED_AUDIO_MIME_TYPES */.Ts.includes(_codec)) {
              _codec2 = _codec;
              break;
            }
          } else {
            if (constants/* SUPPORTED_VIDEO_MIME_TYPES */.ue.includes(_codec)) {
              _codec2 = _codec;
              break;
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return codec;
    }
  }]);
}(events.EventEmitter);
;// ./src/e2ee/worker/e2eeWorkerFactory.js


var WORKER_URL = "https://cdn.videosdk.live/e2ee/0.0.1/bundle.js";
function createE2EEWorker() {
  return _createE2EEWorker.apply(this, arguments);
}
function _createE2EEWorker() {
  _createE2EEWorker = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee() {
    var response, workerCode, blob, blobUrl;
    return regenerator_default().wrap(function (_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 1;
          return fetch(WORKER_URL);
        case 1:
          response = _context.sent;
          if (response.ok) {
            _context.next = 2;
            break;
          }
          throw new Error("Failed to load worker script: ".concat(response.statusText));
        case 2:
          _context.next = 3;
          return response.text();
        case 3:
          workerCode = _context.sent;
          blob = new Blob([workerCode], {
            type: 'application/javascript'
          });
          blobUrl = URL.createObjectURL(blob);
          return _context.abrupt("return", new Worker(blobUrl));
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _createE2EEWorker.apply(this, arguments);
}
// EXTERNAL MODULE: ./src/e2ee/KeyProvider.js
var KeyProvider = __webpack_require__(9633);
// EXTERNAL MODULE: ./src/index.js + 35 modules
var src = __webpack_require__(1853);
// EXTERNAL MODULE: ./src/constants/reliabilityModes.js
var reliabilityModes = __webpack_require__(2067);
;// ./src/lib/RoomClient.js








function RoomClient_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function RoomClient_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? RoomClient_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : RoomClient_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function RoomClient_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = RoomClient_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function RoomClient_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return RoomClient_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? RoomClient_arrayLikeToArray(r, a) : void 0; } }
function RoomClient_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
























// import E2EEWorker from "../e2ee/worker/e2ee.worker?worker"

var VIDEO_LAYERS = {
  sd: {
    low: {
      s: 0,
      t: 2
    },
    med: {
      s: 0,
      t: 2
    },
    high: {
      s: 1,
      t: 2
    },
    s0t0: {
      s: 0,
      t: 0
    },
    s0t1: {
      s: 0,
      t: 1
    },
    s0t2: {
      s: 0,
      t: 2
    },
    s1t0: {
      s: 1,
      t: 0
    },
    s1t1: {
      s: 1,
      t: 1
    },
    s1t2: {
      s: 1,
      t: 2
    },
    s2t0: {
      s: 2,
      t: 0
    },
    s2t1: {
      s: 2,
      t: 1
    },
    s2t2: {
      s: 2,
      t: 2
    }
  },
  hd: {
    low: {
      s: 0,
      t: 2
    },
    med: {
      s: 1,
      t: 2
    },
    high: {
      s: 2,
      t: 2
    },
    s0t0: {
      s: 0,
      t: 0
    },
    s0t1: {
      s: 0,
      t: 1
    },
    s0t2: {
      s: 0,
      t: 2
    },
    s1t0: {
      s: 1,
      t: 0
    },
    s1t1: {
      s: 1,
      t: 1
    },
    s1t2: {
      s: 1,
      t: 2
    },
    s2t0: {
      s: 2,
      t: 0
    },
    s2t1: {
      s: 2,
      t: 1
    },
    s2t2: {
      s: 2,
      t: 2
    }
  }
};
var VIDEO_CONSTRAINS = {
  qvga: {
    width: {
      ideal: 320
    },
    height: {
      ideal: 240
    }
  },
  vga: {
    width: {
      ideal: 640
    },
    height: {
      ideal: 480
    }
  },
  // sd: { width: { ideal: 640 }, height: { ideal: 360 }, frameRate: { max: 24 } },
  sd: {
    width: {
      ideal: 1280
    },
    height: {
      ideal: 720
    },
    frameRate: {
      ideal: 24
    }
  },
  hd: {
    width: {
      ideal: 1280
    },
    height: {
      ideal: 720
    },
    frameRate: {
      ideal: 24
    }
  }

  // hd: { width: { ideal: 960 }, height: { ideal: 540 }, frameRate: { max: 24 } },
  // hd: { width: { ideal: 854 }, height: { ideal: 480 }, frameRate: { max: 24 } },
  // hd: { width: { ideal: 640 }, height: { ideal: 360 }, frameRate: { max: 24 } },
};

// WARNING : googDscp deprecated
// const PC_PROPRIETARY_CONSTRAINTS = {
//   optional: [{ googDscp: true }],
// };

// Used for simulcast webcam video.
var WEBCAM_SIMULCAST_ENCODINGS = {
  sd: [{
    scaleResolutionDownBy: 6
  }, {
    scaleResolutionDownBy: 4
  }, {
    scaleResolutionDownBy: 2
  }],
  // 1280x720
  hd: [{
    scaleResolutionDownBy: 4
  }, {
    scaleResolutionDownBy: 2
  }, {
    scaleResolutionDownBy: 1
  }]
};

// Used for VP9 webcam video.
var WEBCAM_KSVC_ENCODINGS = [{
  scalabilityMode: "S3T3_KEY"
}];

// Used for simulcast screen sharing.
var SCREEN_SHARING_SIMULCAST_ENCODINGS = [
// { dtx: true, maxBitrate: 1500000 },
{
  dtx: true,
  maxFramerate: 30
}];

// Used for VP9 screen sharing.
var SCREEN_SHARING_SVC_ENCODINGS = [{
  scalabilityMode: "S3T3",
  dtx: true
}];
var EXTERNAL_VIDEO_SRC = "/resources/videos/video-audio-stereo.mp4";
var logger = new Logger("RoomClient");
var store;
var _RoomClient_brand = /*#__PURE__*/new WeakSet();
var RoomClient = /*#__PURE__*/function () {
  function RoomClient(_ref) {
    var roomId = _ref.roomId,
      peerId = _ref.peerId,
      secret = _ref.secret,
      displayName = _ref.displayName,
      device = _ref.device,
      handlerName = _ref.handlerName,
      useSimulcast = _ref.useSimulcast,
      forceTcp = _ref.forceTcp,
      mode = _ref.mode,
      forceH264 = _ref.forceH264,
      forceVP9 = _ref.forceVP9,
      svc = _ref.svc,
      datachannel = _ref.datachannel,
      externalVideo = _ref.externalVideo,
      micEnabled = _ref.micEnabled,
      webcamEnabled = _ref.webcamEnabled,
      maxResolution = _ref.maxResolution,
      useSpartialLayerAnalytics = _ref.useSpartialLayerAnalytics,
      _deviceInfo = _ref._deviceInfo,
      customCameraVideoTrack = _ref.customCameraVideoTrack,
      customMicrophoneAudioTrack = _ref.customMicrophoneAudioTrack,
      autoConsume = _ref.autoConsume,
      preferredProtocol = _ref.preferredProtocol,
      signalingBaseUrl = _ref.signalingBaseUrl,
      metaData = _ref.metaData,
      defaultCameraIndex = _ref.defaultCameraIndex,
      debugMode = _ref.debugMode,
      _keyProvider = _ref.keyProvider;
    (0,classCallCheck/* default */.A)(this, RoomClient);
    _classPrivateMethodInitSpec(this, _RoomClient_brand);
    (0,defineProperty/* default */.A)(this, "e2eeManager", null);
    logger.debug('constructor() [roomId:"%s", peerId:"%s", displayName:"%s", device:%s]', roomId, peerId, displayName, device.flag);

    // data collect with partial layers
    // @type {Boolean}
    this.useSpartialLayerAnalytics = useSpartialLayerAnalytics || false;

    //analytics device data
    this._deviceInfo = _deviceInfo;
    this._eventEmitter = new events.EventEmitter();

    // Closed flag.
    // @type {Boolean}
    this._closed = false;

    // Display name.
    // @type {String}
    this._displayName = displayName;

    // Device info.
    // @type {Object}
    this._device = device;

    // Whether we want to force RTC over TCP.
    // @type {Boolean}
    this._forceTcp = forceTcp;

    //Whether to prefer UDP or TCP Protocol
    this._preferredProtocol = preferredProtocol;
    var produce;
    var consume;
    switch (mode) {
      case modes/* modes */.nI.CONFERENCE:
      case modes/* modes */.nI.SEND_AND_RECV:
        produce = true;
        consume = true;
        break;
      case modes/* modes */.nI.RECV_ONLY:
        produce = false;
        consume = true;
        break;
      default:
        produce = false;
        consume = false;
    }

    // mode can be either SEND_AND_RECV or RECV_ONLY or SIGNALLING_ONLY
    // @type {String}
    this._mode = mode;

    // Whether we want to produce audio/video.
    // @type {Boolean}
    this._produce = produce;

    // Whether we should consume.
    // @type {Boolean}
    this._consume = consume;

    // Force H264 codec for sending.
    this._forceH264 = Boolean(forceH264);

    // Force VP9 codec for sending.
    this._forceVP9 = Boolean(forceVP9);

    // Enable mic while producing.
    this._micEnabled = Boolean(micEnabled);

    // Enable webcam while producing.
    this._webcamEnabled = Boolean(webcamEnabled);

    // External video.
    // @type {HTMLVideoElement}
    this._externalVideo = null;

    // MediaStream of the external video.
    // @type {MediaStream}
    this._externalVideoStream = null;

    // Next expected dataChannel test number.
    // @type {Number}
    this._nextDataChannelTestNumber = 0;
    if (externalVideo) {
      this._externalVideo = document.createElement("video");
      this._externalVideo.controls = true;
      // this._externalVideo.muted = true;
      this._externalVideo.loop = true;
      this._externalVideo.setAttribute("playsinline", "");
      this._externalVideo.src = externalVideo;
      this._externalVideo.play()["catch"](function (error) {
        return logger.warn("externalVideo.play() failed:%o", error);
      });
    }

    // Custom mediasoup-client handler name (to override default browser
    // detection if desired).
    // @type {String}
    this._handlerName = handlerName;

    // Whether simulcast should be used.
    // @type {Boolean}
    this._useSimulcast = useSimulcast;

    // Socket URL.
    // @type {String}
    this._socketUrl = "";
    this._secret = secret;
    this._peerId = peerId;
    this._roomId = roomId;

    // meeting server base url
    this._baseUrl = "";

    // websocket instance.
    // @type {io}
    this._webSocket = null;

    // mediasoup-client Device instance.
    // @type {mediasoupClient.Device}
    this._mediasoupDevice = null;

    // mediasoup Transport for sending.
    // @type {mediasoupClient.Transport}
    this._sendTransport = null;

    // mediasoup Transport for receiving.
    // @type {mediasoupClient.Transport}
    this._recvTransport = null;

    // Local mic mediasoup Producer.
    // @type {mediasoupClient.Producer}
    this._micProducer = null;

    // Local webcam mediasoup Producer.
    // @type {mediasoupClient.Producer}
    this._webcamProducer = null;

    // Local share mediasoup Producer.
    // @type {mediasoupClient.Producer}
    this._shareProducer = null;

    // Local share audio mediasoup Producer.
    // @type {mediasoupClient.Producer}
    this._shareAudioProducer = null;

    // Local Reliable DataProducer.
    // @type {mediasoupClient.DataProducer}
    this._reliableDataProducer = null;

    // Local UnReliable DataProducer.
    // @type {mediasoupClient.DataProducer}
    this._unreliableDataProducer = null;

    // mediasoup Consumers.
    // @type {Map<String, mediasoupClient.Consumer>}
    this._consumers = new Map();

    // mediasoup DataConsumers.
    // @type {Map<String, mediasoupClient.DataConsumer>}
    this._dataConsumers = new Map();

    //Map of Mics MediaDeviceInfo indexed by DeviceId.
    //@type {Map<string,MediaDeviceInfo>}
    this._mics = new Map();

    //Local Webcam
    //@type {object} with:
    //-{MediaDeviceInfo} [device]
    this._mic = {
      device: null
    };

    // Map of webcam MediaDeviceInfos indexed by deviceId.
    // @type {Map<String, MediaDeviceInfos>}
    this._webcams = new Map();

    // Local Webcam.
    // @type {Object} with:
    // - {MediaDeviceInfo} [device]
    // - {String} [resolution] - 'qvga' / 'vga' / 'sd' / 'hd'.
    this._webcam = {
      device: null,
      resolution: maxResolution || "hd"
    };

    //Pin Participant lists
    this._pinnedParticipants = new Map();

    // Set custom SVC scalability mode.
    if (svc) {
      WEBCAM_KSVC_ENCODINGS[0].scalabilityMode = "".concat(svc, "_KEY");
      SCREEN_SHARING_SVC_ENCODINGS[0].scalabilityMode = svc;
    }

    //custom Camerea Video Track
    //@type MediaStream
    this.customCameraVideoTrack = customCameraVideoTrack;

    //custom Microphone Track
    //@type MediaStream
    this.customMicrophoneAudioTrack = customMicrophoneAudioTrack;

    //auto create consumers
    //@type boolean
    this._autoConsume = autoConsume;
    //stun-turn server urls and credentials
    //@type array
    this._iceServers = [];

    // Define your configuration
    var configuration = {
      refreshEvery: 1000,
      // Optional. Refresh every 5 seconds
      startAfter: 1000,
      // Optional. Start collecting stats after 1 seconds
      verbose: false // Optional. Display verbose logs or not.
    };
    this._metrics = new videosdk_room_stats.VideoSDKMetrics(configuration);
    this._stats = {};
    this._latestStats = {};
    this._isWebsocketAlive = false;
    this._pingWebsocketInterval = null;
    this._pingInternetInterval = null;
    this._pingWebsocketFailedCounter = 0;
    this._pongInternetCounter = 0;
    this._transportState = "";
    this._openTelemetry = null;
    this._videosdkLogs = null;
    this._signalingBaseUrl = signalingBaseUrl ? signalingBaseUrl : "api.videosdk.live";
    this._metaData = metaData;
    this._defaultCameraIndex = defaultCameraIndex;
    this._debugMode = Boolean(debugMode);
    this._meetingConnectionState = null;
    this._sendTransportInternal = null;
    if (_keyProvider) {
      if (_keyProvider instanceof KeyProvider/* ExternalE2EEKeyProvider */.l) {
        _assertClassBrand(_RoomClient_brand, this, _setupE2EE).call(this, _keyProvider);
      } else {
        throw new Error("keyProvider should be an instance of ExternalE2EEKeyProvider");
      }
    }
  }

  /**
   *
   * @param {
      'ADD_PEER' | 'REMOVE_PEER' |
      'ADD_PRODUCER' | 'REMOVE_PRODUCER' |
      'ADD_CONSUMER' | 'REMOVE_CONSUMER' |
      'SET_ROOM_ACTIVE_SPEAKER' | 'DATA' |
      'ENTRY_REQUESTED' | 'ENTRY_RESPONDED' | 
      'RECORDING_STARTED' | 'RECORDING_STOPPED' | 'RECORDING_STATE_CHANGED' |
      'LIVESTREAM_STARTED' | 'LIVESTREAM_STOPPED' |
      'TRANSCRIPTION_STATE_CHANGED' | 'TRANSCRIPTION_TEXT' |
      'WHITEBOARD_STARTED' | 'WHITEBOARD_STOPPED' |
      'CHARACTER_STATE_CHANGED' | 'CHARACTER_MESSAGE' | 'ADD_CHARACTER' | 'REMOVE_CHARACTER'|
      'VIDEO_STATE_CHANGED' | 'VIDEO_SEEKED' | 
      'VIDEO_QUALITY_CHANGED' |
      'WEBCAM_REQUESTED' | 'MIC_REQUESTED' | 'PARTICIPANT_MEDIA_STATE_CHANGED' |  'MEETING_STATE_CHANGED'
    } eventType
   * @param {*} listener
   */
  return (0,createClass/* default */.A)(RoomClient, [{
    key: "on",
    value: function on(eventType, listener) {
      this._eventEmitter.on(eventType, listener);
    }
  }, {
    key: "softClose",
    value: function softClose() {
      var _this$_openTelemetry;
      // Create a span for soft close operation
      var softCloseSpan = (_this$_openTelemetry = this._openTelemetry) === null || _this$_openTelemetry === void 0 ? void 0 : _this$_openTelemetry.trace({
        name: "softClose() Start "
      });
      try {
        var _this$_openTelemetry2, _this$_openTelemetry3, _this$_openTelemetry4;
        // Remove Current Meeting Participants map
        this._eventEmitter.emit("REMOVE_PARTICIPANTS_FOR_SWITCH_MEETING");

        // Create child span for consumer cleanup
        var consumerCleanupSpan = (_this$_openTelemetry2 = this._openTelemetry) === null || _this$_openTelemetry2 === void 0 ? void 0 : _this$_openTelemetry2.trace({
          name: "Consumer Cleanup",
          parentSpan: softCloseSpan,
          attributes: {
            "videosdk.consumers.count": this._consumers.size || 0
          }
        });

        // Close All Consumers
        var _iterator = RoomClient_createForOfIteratorHelper(this._consumers.values()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var consumer = _step.value;
            consumer.close();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        (_this$_openTelemetry3 = this._openTelemetry) === null || _this$_openTelemetry3 === void 0 || _this$_openTelemetry3.completeSpan({
          span: consumerCleanupSpan,
          status: 1,
          message: "Closed ".concat(this._consumers.size, " consumers successfully")
        });

        // Complete the main soft close span
        (_this$_openTelemetry4 = this._openTelemetry) === null || _this$_openTelemetry4 === void 0 || _this$_openTelemetry4.completeSpan({
          span: softCloseSpan,
          status: 1,
          message: "Soft close completed successfully"
        });
      } catch (error) {
        var _this$_openTelemetry5;
        // Handle any errors and complete spans with error status
        (_this$_openTelemetry5 = this._openTelemetry) === null || _this$_openTelemetry5 === void 0 || _this$_openTelemetry5.completeSpan({
          span: softCloseSpan,
          status: 2,
          message: "Soft close failed: ".concat(error.message)
        });
        console.error(error);
      }
    }
  }, {
    key: "close",
    value: function close(_ref2) {
      var _this$_openTelemetry7, _this$_openTelemetry8, _this$_openTelemetry9, _this$_videosdkLogs2, _this$_openTelemetry0;
      var _ref2$sendLeft = _ref2.sendLeft,
        sendLeft = _ref2$sendLeft === void 0 ? true : _ref2$sendLeft;
      if (sendLeft) {
        var _this$_openTelemetry6, _this$_videosdkLogs;
        (_this$_openTelemetry6 = this._openTelemetry) === null || _this$_openTelemetry6 === void 0 || _this$_openTelemetry6.traceAutoComplete({
          spanName: "Meeting is in CLOSING State",
          status: 1
        });
        (_this$_videosdkLogs = this._videosdkLogs) === null || _this$_videosdkLogs === void 0 || _this$_videosdkLogs.pushLogs({
          logText: "Meeting is in CLOSING State",
          logType: "INFO"
        });
      }
      if (this._closed) return;
      this._closed = true;
      if (this._pingWebsocketInterval) clearInterval(this._pingWebsocketInterval);
      this._pingWebsocketInterval = null;
      if (this._pingInternetInterval) clearInterval(this._pingInternetInterval);
      this._pingInternetInterval = null;
      if (this._sendTransportInternal) clearInterval(this._sendTransportInternal);
      this._sendTransportInternal = null;
      // Close websocket
      this._webSocket.close();
      if (this._metrics.running) {
        this._metrics.stopAllProbes();
      }
      logger.debug("close()");
      var internalSpan = (_this$_openTelemetry7 = this._openTelemetry) === null || _this$_openTelemetry7 === void 0 ? void 0 : _this$_openTelemetry7.trace({
        spanName: "Closing Trasnport"
      });

      // Close mediasoup Transports.
      if (this._sendTransport) this._sendTransport.close();
      if (this._recvTransport) this._recvTransport.close();
      (_this$_openTelemetry8 = this._openTelemetry) === null || _this$_openTelemetry8 === void 0 || _this$_openTelemetry8.completeSpan({
        span: internalSpan,
        status: 1,
        message: "Closed Trasnport"
      });
      store.dispatch(setRoomState("closed"));
      if (sendLeft) this.emitMeetingStateChange(state.DISCONNECTED);
      (_this$_openTelemetry9 = this._openTelemetry) === null || _this$_openTelemetry9 === void 0 || _this$_openTelemetry9.traceAutoComplete({
        spanName: "Meeting is in CLOSED State",
        status: 1
      });
      (_this$_videosdkLogs2 = this._videosdkLogs) === null || _this$_videosdkLogs2 === void 0 || _this$_videosdkLogs2.pushLogs({
        logText: "Meeting is in CLOSED State",
        logType: "INFO"
      });
      if (sendLeft) this._eventEmitter.emit("MEETING_LEFT");
      (_this$_openTelemetry0 = this._openTelemetry) === null || _this$_openTelemetry0 === void 0 || _this$_openTelemetry0.traceAutoComplete({
        spanName: "Emitted MEETING_LEFT Event",
        status: 1
      });
    }
  }, {
    key: "join",
    value: function () {
      var _join = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee1() {
        var _this = this;
        var _this$_openTelemetry1, _this$_openTelemetry10, _this$_videosdkLogs3, _yield$getServerConfi, baseUrl, iceServers, logs, observabilityJwt, traces, metaData, signalingUrl, socketPath, socketUrl, _this$_videosdkLogs14, _t7;
        return regenerator_default().wrap(function (_context1) {
          while (1) switch (_context1.prev = _context1.next) {
            case 0:
              _context1.prev = 0;
              _context1.next = 1;
              return getServerConfig({
                roomId: this._roomId,
                secret: this._secret,
                signalingBaseUrl: this._signalingBaseUrl
              });
            case 1:
              _yield$getServerConfi = _context1.sent;
              baseUrl = _yield$getServerConfi.baseUrl;
              iceServers = _yield$getServerConfi.iceServers;
              logs = _yield$getServerConfi.logs;
              observabilityJwt = _yield$getServerConfi.observabilityJwt;
              traces = _yield$getServerConfi.traces;
              metaData = _yield$getServerConfi.metaData;
              signalingUrl = _yield$getServerConfi.signalingUrl;
              socketPath = _yield$getServerConfi.socketPath;
              socketUrl = _yield$getServerConfi.socketUrl;
              this._baseUrl = baseUrl;
              this._socketUrl = "wss://".concat(socketUrl ? socketUrl : this._baseUrl, "/?roomId=").concat(this._roomId, "&peerId=").concat(this._peerId, "&secret=").concat(this._secret, "&mode=").concat(this._mode, "&lib=socket");
              this._iceServers = iceServers;
              this._tracesEnabled = traces.enabled;
              this._openTelemetry = new VideoSDKTelemetery((0,defineProperty/* default */.A)({
                roomId: this._roomId,
                peerId: this._peerId,
                sdkName: "".concat(this._deviceInfo.sdkType, "-sdk"),
                traces: traces,
                logs: logs,
                observabilityJwt: observabilityJwt,
                metaData: metaData
              }, "traces", traces));

              // this._videosdkLogs = new VideoSDKLogs({
              //   roomId: this._roomId,
              //   peerId: this._peerId,
              //   sdkName: `${this._deviceInfo.sdkType}-sdk`,
              //   logs,
              //   observabilityJwt,
              // });

              this._joinSpan = (_this$_openTelemetry1 = this._openTelemetry) === null || _this$_openTelemetry1 === void 0 ? void 0 : _this$_openTelemetry1.trace({
                spanName: "Join() Calling",
                attributes: {
                  DeviceInfo: JSON.stringify(this._deviceInfo),
                  mode: this._mode,
                  displayName: this._displayName,
                  multiStream: this._useSimulcast,
                  micEnabled: this._micEnabled,
                  webcamEnabled: this._webcamEnabled,
                  CustomVideoTrack: !!this.customCameraVideoTrack,
                  CustomMicTrack: !!this.customMicrophoneAudioTrack,
                  signalingUrl: signalingUrl ? signalingUrl : "signalingUrl not specify"
                }
              });
              this._webSocket = esm_lookup(this._socketUrl, {
                transports: ["websocket"],
                reconnectionAttempts: 10,
                reconnectionDelay: 5000,
                reconnection: true,
                path: "".concat(socketPath !== null && socketPath !== void 0 ? socketPath : "", "/socket.io")
              });
              this.emitMeetingStateChange(state.CONNECTING);
              store.dispatch(setRoomState("connecting"));
              (_this$_openTelemetry10 = this._openTelemetry) === null || _this$_openTelemetry10 === void 0 || _this$_openTelemetry10.traceAutoComplete({
                spanName: "Meeting is in CONNECTING State",
                span: this._joinSpan,
                status: 1
              });
              (_this$_videosdkLogs3 = this._videosdkLogs) === null || _this$_videosdkLogs3 === void 0 || _this$_videosdkLogs3.pushLogs({
                logText: "Meeting is in CONNECTING State",
                logType: "INFO"
              });

              //Websocket first gives this event when connection request is sent
              this._webSocket.on("connect", function () {});

              //Websocket gives this event when connection is succesfully established
              this._webSocket.on("connectionSuccess", function () {
                var _this$_openTelemetry11, _this$_videosdkLogs4;
                _this._isWebsocketAlive = true;
                _this._closed = false;
                if (_this._mode === (modes/* modes */.nI.RECV_ONLY || modes/* modes */.nI.SIGNALLING_ONLY)) {
                  _this.emitMeetingStateChange(state.CONNECTED);
                }
                (_this$_openTelemetry11 = _this._openTelemetry) === null || _this$_openTelemetry11 === void 0 || _this$_openTelemetry11.traceAutoComplete({
                  spanName: "Meeting is in CONNECTED State",
                  span: _this._joinSpan,
                  status: 1
                });
                (_this$_videosdkLogs4 = _this._videosdkLogs) === null || _this$_videosdkLogs4 === void 0 || _this$_videosdkLogs4.pushLogs({
                  logText: "Meeting is in CONNECTED State",
                  logType: "INFO"
                });
                _this.requestEntry();
              });

              //Websocket gives this event when disconnection happens, with a reason. For few reason reconnection happens automatically
              this._webSocket.on("disconnect", function (reason) {
                var _this$_videosdkLogs5;
                (_this$_videosdkLogs5 = _this._videosdkLogs) === null || _this$_videosdkLogs5 === void 0 || _this$_videosdkLogs5.pushLogs({
                  logText: "Meeting is in Websocket Disconnect State",
                  logType: "INFO",
                  attributes: {
                    reason: reason
                  },
                  dashboardLog: true
                });
                if (reason === "transport close" || reason === "transport error") {
                  if (_this.customMicrophoneAudioTrack) {
                    var _this$customMicrophon;
                    (_this$customMicrophon = _this.customMicrophoneAudioTrack) === null || _this$customMicrophon === void 0 || _this$customMicrophon.getTracks().forEach(function (track) {
                      track.stop();
                    });
                    _this.customMicrophoneAudioTrack = null;
                  }
                  if (_this.customCameraVideoTrack) {
                    var _this$customCameraVid;
                    (_this$customCameraVid = _this.customCameraVideoTrack) === null || _this$customCameraVid === void 0 || _this$customCameraVid.getTracks().forEach(function (track) {
                      track.stop();
                    });
                    _this.customCameraVideoTrack = null;
                  }
                  if (_this._sendTransport) {
                    var _this$_sendTransport;
                    (_this$_sendTransport = _this._sendTransport) === null || _this$_sendTransport === void 0 || _this$_sendTransport.close();
                    _this._sendTransport = null;
                  }
                  if (_this._recvTransport) {
                    var _this$_recvTransport;
                    (_this$_recvTransport = _this._recvTransport) === null || _this$_recvTransport === void 0 || _this$_recvTransport.close();
                    _this._recvTransport = null;
                  }
                }
              });

              //Websocket gives this event when All Reconnection attempts (10) are exhausted
              this._webSocket.io.on("reconnect_failed", function () {
                if (_this._closed) return;
                _this.close({
                  sendLeft: true
                });
              });

              //Websocket gives this event when connection fails while trying to reconnect
              this._webSocket.on("connect_error", function (error) {
                if (_this._webSocket.active && _this._webSocket.io._reconnecting) {
                  var _this$_openTelemetry12, _this$_videosdkLogs6, _this$customMicrophon2, _this$customCameraVid2;
                  (_this$_openTelemetry12 = _this._openTelemetry) === null || _this$_openTelemetry12 === void 0 || _this$_openTelemetry12.traceAutoComplete({
                    spanName: "Meeting is in RECONNECTING State",
                    span: _this._joinSpan,
                    status: 1
                  });
                  (_this$_videosdkLogs6 = _this._videosdkLogs) === null || _this$_videosdkLogs6 === void 0 || _this$_videosdkLogs6.pushLogs({
                    logText: "Meeting is in RECONNECTING State",
                    logType: "INFO",
                    attributes: {
                      error: error.message
                    }
                  });
                  store.dispatch(notify({
                    type: "error",
                    text: "WebSocket Reconnecting"
                  }));
                  _this.emitMeetingStateChange(state.RECONNECTING);
                  if (_this._sendTransport) {
                    var _this$_sendTransport2;
                    (_this$_sendTransport2 = _this._sendTransport) === null || _this$_sendTransport2 === void 0 || _this$_sendTransport2.close();
                    _this._sendTransport = null;
                  }
                  if (_this._recvTransport) {
                    var _this$_recvTransport2;
                    (_this$_recvTransport2 = _this._recvTransport) === null || _this$_recvTransport2 === void 0 || _this$_recvTransport2.close();
                    _this._recvTransport = null;
                  }
                  (_this$customMicrophon2 = _this.customMicrophoneAudioTrack) === null || _this$customMicrophon2 === void 0 || _this$customMicrophon2.getTracks().forEach(function (track) {
                    track.stop();
                  });
                  _this.customMicrophoneAudioTrack = null;
                  (_this$customCameraVid2 = _this.customCameraVideoTrack) === null || _this$customCameraVid2 === void 0 || _this$customCameraVid2.getTracks().forEach(function (track) {
                    track.stop();
                  });
                  _this.customCameraVideoTrack = null;
                } else {
                  // the connection was denied by the server
                  // in that case, `socket.connect()` must be manually called in order to reconnect
                  console.log("Error while trying to reconnect", error.message);
                }
              });

              //Websocket gives this event when connection is succesfully closed
              this._webSocket.on("close", function () {
                console.log("MEETING close");
                if (_this._closed) return;
                _this.close({
                  sendLeft: true
                });
              });
              this._webSocket.on("newConsumer", /*#__PURE__*/function () {
                var _ref3 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(request, accept) {
                  var _this$_openTelemetry13, _this$_openTelemetry15;
                  var newConsumerSpan, _this$_openTelemetry14, peerId, producerId, id, kind, rtpParameters, type, appData, producerPaused, span, _this$_openTelemetry16, _this$_openTelemetry17, _this$_openTelemetry18, _this$_openTelemetry19, consumer, _mediasoupClient$pars, spatialLayers, temporalLayers, action, _this$_openTelemetry20, _this$_openTelemetry21, _this$_openTelemetry22, _this$_videosdkLogs7, _t;
                  return regenerator_default().wrap(function (_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        newConsumerSpan = (_this$_openTelemetry13 = _this._openTelemetry) === null || _this$_openTelemetry13 === void 0 ? void 0 : _this$_openTelemetry13.trace({
                          spanName: "Websocket REQ: newConsumer",
                          attributes: {
                            request: JSON.stringify(request)
                          }
                        });
                        if (_this._consume) {
                          _context.next = 1;
                          break;
                        }
                        // reject(403, "I do not want to consume");
                        accept({
                          errorCode: 403,
                          message: "I do not want to consume",
                          method: "newConsumer"
                        });
                        (_this$_openTelemetry14 = _this._openTelemetry) === null || _this$_openTelemetry14 === void 0 || _this$_openTelemetry14.completeSpan({
                          span: newConsumerSpan,
                          status: 2,
                          message: "I do not want to consume"
                        });
                        return _context.abrupt("return");
                      case 1:
                        peerId = request.peerId, producerId = request.producerId, id = request.id, kind = request.kind, rtpParameters = request.rtpParameters, type = request.type, appData = request.appData, producerPaused = request.producerPaused;
                        span = (_this$_openTelemetry15 = _this._openTelemetry) === null || _this$_openTelemetry15 === void 0 ? void 0 : _this$_openTelemetry15.trace({
                          spanName: "Creating Consumer",
                          span: newConsumerSpan
                        });
                        _context.prev = 2;
                        _context.next = 3;
                        return _this._recvTransport.consume({
                          id: id,
                          producerId: producerId,
                          kind: kind,
                          rtpParameters: rtpParameters,
                          appData: RoomClient_objectSpread(RoomClient_objectSpread({}, appData), {}, {
                            peerId: peerId
                          }),
                          // Trick.
                          onRtpReceiver: function onRtpReceiver(receiver) {
                            if (_this.e2eeManager) {
                              var writable = receiver.writableStream;
                              // @ts-ignore
                              var readable = receiver.readableStream;
                              if (!writable || !readable) {
                                // @ts-ignore
                                var receiverStreams = receiver.createEncodedStreams();
                                // @ts-ignore
                                receiver.writableStream = receiverStreams.writable;
                                writable = receiverStreams.writable;
                                // @ts-ignore
                                receiver.readableStream = receiverStreams.readable;
                                readable = receiverStreams.readable;
                              }
                            }
                          }
                        });
                      case 3:
                        consumer = _context.sent;
                        _mediasoupClient$pars = lib/* parseScalabilityMode */.s$(consumer.rtpParameters.encodings[0].scalabilityMode), spatialLayers = _mediasoupClient$pars.spatialLayers, temporalLayers = _mediasoupClient$pars.temporalLayers;
                        consumer.spatialLayers = spatialLayers;
                        consumer.temporalLayers = temporalLayers;
                        consumer.currentSpatialLayers = spatialLayers - 1;
                        consumer.currentTemporalLayers = temporalLayers - 1;

                        // Store in the map.
                        _this._consumers.set(consumer.id, consumer);
                        consumer.on("transportclose", function () {
                          _this._consumers["delete"](consumer.id);
                          var action = removeConsumer(consumer.id, peerId);
                          store.dispatch(action);
                          _this._eventEmitter.emit(action.type, action.payload);
                        });
                        (_this$_openTelemetry16 = _this._openTelemetry) === null || _this$_openTelemetry16 === void 0 || _this$_openTelemetry16.completeSpan({
                          span: span,
                          status: 1,
                          message: "Consumer Created"
                        });
                        span = (_this$_openTelemetry17 = _this._openTelemetry) === null || _this$_openTelemetry17 === void 0 ? void 0 : _this$_openTelemetry17.trace({
                          spanName: "Sending Stream Enabled Event",
                          span: newConsumerSpan
                        });
                        action = addConsumer({
                          id: consumer.id,
                          type: type,
                          locallyPaused: false,
                          remotelyPaused: producerPaused,
                          rtpParameters: consumer.rtpParameters,
                          spatialLayers: spatialLayers,
                          temporalLayers: temporalLayers,
                          currentSpatialLayer: spatialLayers - 1,
                          currentTemporalLayer: temporalLayers - 1,
                          preferredSpatialLayer: spatialLayers - 1,
                          preferredTemporalLayer: temporalLayers - 1,
                          priority: 1,
                          codec: consumer.rtpParameters.codecs[0].mimeType.split("/")[1],
                          track: consumer.track,
                          appData: appData,
                          instance: consumer
                        }, peerId);
                        store.dispatch(action);
                        _this._eventEmitter.emit(action.type, action.payload);

                        // We are ready. Answer the websocket request so the server will
                        // resume this Consumer (which was paused for now if video).
                        accept();

                        // If audio-only mode is enabled, pause it.
                        if (consumer.kind === "video" && store.getState().me.audioOnly) _this._pauseConsumer(consumer);
                        (_this$_openTelemetry18 = _this._openTelemetry) === null || _this$_openTelemetry18 === void 0 || _this$_openTelemetry18.completeSpan({
                          span: span,
                          status: 1,
                          message: "Event Send Successfully"
                        });
                        (_this$_openTelemetry19 = _this._openTelemetry) === null || _this$_openTelemetry19 === void 0 || _this$_openTelemetry19.completeSpan({
                          span: newConsumerSpan,
                          status: 1,
                          message: "New Consumer Created Successfully",
                          attributes: {
                            "consumer.consumerId": consumer.id
                          }
                        });
                        if (consumer.kind == "video" && consumer.appData.share) {
                          (_this$_openTelemetry20 = _this._openTelemetry) === null || _this$_openTelemetry20 === void 0 || _this$_openTelemetry20.traceAutoComplete({
                            spanName: "Presenter Changed",
                            span: newConsumerSpan,
                            attributes: {
                              "peer.id": peerId
                            }
                          });
                        }
                        if (_this.e2eeManager) {
                          _this.e2eeManager.emit("NEW_CONSUMER", {
                            consumer: consumer,
                            peerId: _this._peerId
                          });
                        }
                        _context.next = 5;
                        break;
                      case 4:
                        _context.prev = 4;
                        _t = _context["catch"](2);
                        (_this$_openTelemetry21 = _this._openTelemetry) === null || _this$_openTelemetry21 === void 0 || _this$_openTelemetry21.completeSpan({
                          span: span,
                          status: 2,
                          message: "Error creating a Consumer: ".concat(_t)
                        });
                        (_this$_openTelemetry22 = _this._openTelemetry) === null || _this$_openTelemetry22 === void 0 || _this$_openTelemetry22.completeSpan({
                          span: newConsumerSpan,
                          status: 2,
                          message: "Error creating a Consumer: ".concat(_t)
                        });
                        store.dispatch(notify({
                          type: "error",
                          text: "Error creating a Consumer: ".concat(_t)
                        }));
                        (_this$_videosdkLogs7 = _this._videosdkLogs) === null || _this$_videosdkLogs7 === void 0 || _this$_videosdkLogs7.pushLogs({
                          logText: "Error creating a Consumer",
                          logType: "ERROR",
                          attributes: {
                            error: _t.message
                          }
                        });
                        throw _t;
                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee, null, [[2, 4]]);
                }));
                return function (_x, _x2) {
                  return _ref3.apply(this, arguments);
                };
              }());
              this._webSocket.on("newDataConsumer", /*#__PURE__*/function () {
                var _ref4 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2(request, accept) {
                  var peerId, dataProducerId, id, sctpStreamParameters, label, protocol, appData, dataConsumer, _t2;
                  return regenerator_default().wrap(function (_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        if (_this._consume) {
                          _context2.next = 1;
                          break;
                        }
                        // reject(403, "I do not want to data consume");
                        accept({
                          errorCode: 403,
                          message: "I do not want to data consume",
                          method: "newConsumer"
                        });
                        return _context2.abrupt("return");
                      case 1:
                        peerId = request.peerId, dataProducerId = request.dataProducerId, id = request.id, sctpStreamParameters = request.sctpStreamParameters, label = request.label, protocol = request.protocol, appData = request.appData;
                        _context2.prev = 2;
                        _context2.next = 3;
                        return _this._recvTransport.consumeData({
                          id: id,
                          dataProducerId: dataProducerId,
                          sctpStreamParameters: sctpStreamParameters,
                          label: label,
                          protocol: protocol,
                          appData: RoomClient_objectSpread(RoomClient_objectSpread({}, appData), {}, {
                            peerId: peerId
                          }) // Trick.
                        });
                      case 3:
                        dataConsumer = _context2.sent;
                        // Store in the map.
                        _this._dataConsumers.set(dataConsumer.id, dataConsumer);
                        dataConsumer.on("transportclose", function () {
                          _this._dataConsumers["delete"](dataConsumer.id);
                        });
                        dataConsumer.on("open", function () {
                          logger.debug('DataConsumer "open" event');
                        });
                        dataConsumer.on("close", function () {
                          logger.warn('DataConsumer "close" event');
                          _this._dataConsumers["delete"](dataConsumer.id);
                          store.dispatch(notify({
                            type: "error",
                            text: "DataConsumer closed"
                          }));
                        });
                        dataConsumer.on("error", function (error) {
                          logger.error('DataConsumer "error" event:%o', error);
                          store.dispatch(notify({
                            type: "error",
                            text: "DataConsumer error: ".concat(error)
                          }));
                        });
                        dataConsumer.on("message", function (message) {
                          var payload;
                          logger.debug('DataConsumer "message" event [streamId:%d]', dataConsumer.sctpStreamParameters.streamId);
                          if (message instanceof ArrayBuffer) {
                            var bytes = new Uint8Array(message);
                            payload = bytes;
                          } else {
                            payload = message;
                          }
                          var _store$getState = store.getState(),
                            peers = _store$getState.peers;
                          var peersArray = Object.keys(peers).map(function (_peerId) {
                            return peers[_peerId];
                          });
                          var sendingPeer = peersArray.find(function (peer) {
                            return peer.dataConsumers.includes(dataConsumer.id);
                          });
                          switch (dataConsumer.label) {
                            case "reliable_data_producer":
                              {
                                if (!sendingPeer) {
                                  logger.warn('DataConsumer "message" from unknown peer');
                                  break;
                                }
                                store.dispatch(notify({
                                  title: "".concat(sendingPeer.displayName, " says:"),
                                  text: message,
                                  timeout: 5000
                                }));
                                _this._eventEmitter.emit("DATA", {
                                  payload: payload,
                                  from: sendingPeer.id,
                                  timestamp: Date.now(),
                                  reliability: reliabilityModes/* reliabilityMode */.y.RELIABLE
                                });
                                break;
                              }
                            case "unreliable_data_producer":
                              {
                                if (!sendingPeer) {
                                  logger.warn('DataConsumer "message" from unknown peer');
                                  break;
                                }
                                store.dispatch(notify({
                                  title: "".concat(sendingPeer.displayName, " says:"),
                                  text: message,
                                  timeout: 5000
                                }));
                                _this._eventEmitter.emit("DATA", {
                                  payload: payload,
                                  from: sendingPeer.id,
                                  timestamp: Date.now(),
                                  reliability: reliabilityModes/* reliabilityMode */.y.UNRELIABLE
                                });
                                break;
                              }
                          }
                        });
                        store.dispatch(addDataConsumer({
                          id: dataConsumer.id,
                          sctpStreamParameters: dataConsumer.sctpStreamParameters,
                          label: dataConsumer.label,
                          protocol: dataConsumer.protocol
                        }, peerId));

                        // We are ready. Answer the websocket request.
                        accept();
                        _context2.next = 5;
                        break;
                      case 4:
                        _context2.prev = 4;
                        _t2 = _context2["catch"](2);
                        logger.error('"newDataConsumer" request failed:%o', _t2);
                        store.dispatch(notify({
                          type: "error",
                          text: "Error creating a DataConsumer: ".concat(_t2)
                        }));

                        // throw error;
                      case 5:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2, null, [[2, 4]]);
                }));
                return function (_x3, _x4) {
                  return _ref4.apply(this, arguments);
                };
              }());
              this._webSocket.on("enableMic", /*#__PURE__*/function () {
                var _ref5 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee3(request, accept) {
                  var _this$_openTelemetry23, peerId, _this$_videosdkLogs8;
                  return regenerator_default().wrap(function (_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        try {
                          peerId = request.peerId;
                          (_this$_openTelemetry23 = _this._openTelemetry) === null || _this$_openTelemetry23 === void 0 || _this$_openTelemetry23.traceAutoComplete({
                            spanName: "Emitting MIC_REQUESTED & Websocket REQ: enableMic for ".concat(peerId),
                            status: 1
                          });
                          _this._eventEmitter.emit("MIC_REQUESTED", {
                            peerId: peerId
                          });
                          accept();
                        } catch (error) {
                          logger.error('"enableMic" request failed:%o', error);
                          (_this$_videosdkLogs8 = _this._videosdkLogs) === null || _this$_videosdkLogs8 === void 0 || _this$_videosdkLogs8.pushLogs({
                            logText: "Error enableMic request failed",
                            logType: "ERROR",
                            attributes: {
                              error: error.message
                            }
                          });
                          _this._emitError({
                            code: 3027,
                            message: error.message
                          });
                        }
                      case 1:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3);
                }));
                return function (_x5, _x6) {
                  return _ref5.apply(this, arguments);
                };
              }());
              this._webSocket.on("disableMic", /*#__PURE__*/function () {
                var _ref6 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee4(request, accept) {
                  var disableMicSpan, _this$_openTelemetry24, _this$_openTelemetry25, _this$_openTelemetry26, _this$_videosdkLogs9, _t3;
                  return regenerator_default().wrap(function (_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.prev = 0;
                        disableMicSpan = (_this$_openTelemetry24 = _this._openTelemetry) === null || _this$_openTelemetry24 === void 0 ? void 0 : _this$_openTelemetry24.trace({
                          spanName: "Websocket REQ: disableMic"
                        });
                        _context4.next = 1;
                        return _this.disableMic(false, disableMicSpan);
                      case 1:
                        (_this$_openTelemetry25 = _this._openTelemetry) === null || _this$_openTelemetry25 === void 0 || _this$_openTelemetry25.completeSpan({
                          span: disableMicSpan,
                          status: 1,
                          message: "Request Completed"
                        });
                        accept();
                        _context4.next = 3;
                        break;
                      case 2:
                        _context4.prev = 2;
                        _t3 = _context4["catch"](0);
                        (_this$_openTelemetry26 = _this._openTelemetry) === null || _this$_openTelemetry26 === void 0 || _this$_openTelemetry26.completeSpan({
                          span: disableMicSpan,
                          status: 2,
                          message: "disableMic request failed ".concat(_t3)
                        });
                        (_this$_videosdkLogs9 = _this._videosdkLogs) === null || _this$_videosdkLogs9 === void 0 || _this$_videosdkLogs9.pushLogs({
                          logText: "Error disableMic request failed",
                          logType: "ERROR",
                          attributes: {
                            error: _t3.message
                          }
                        });
                        _this._emitError({
                          code: 3028,
                          message: _t3.message
                        });
                      case 3:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee4, null, [[0, 2]]);
                }));
                return function (_x7, _x8) {
                  return _ref6.apply(this, arguments);
                };
              }());
              this._webSocket.on("enableWebcam", /*#__PURE__*/function () {
                var _ref7 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee5(request, accept) {
                  var _this$_openTelemetry27, peerId, _this$_videosdkLogs0;
                  return regenerator_default().wrap(function (_context5) {
                    while (1) switch (_context5.prev = _context5.next) {
                      case 0:
                        try {
                          peerId = request.peerId;
                          (_this$_openTelemetry27 = _this._openTelemetry) === null || _this$_openTelemetry27 === void 0 || _this$_openTelemetry27.traceAutoComplete({
                            spanName: "Emitting WEBCAM_REQUESTED & Websocket REQ: enableWebcam for ".concat(peerId),
                            status: 1
                          });
                          _this._eventEmitter.emit("WEBCAM_REQUESTED", {
                            peerId: peerId
                          });
                          accept();
                        } catch (error) {
                          logger.error('"enableWebcam" request failed:%o', error);
                          (_this$_videosdkLogs0 = _this._videosdkLogs) === null || _this$_videosdkLogs0 === void 0 || _this$_videosdkLogs0.pushLogs({
                            logText: "Error enableWebcam request failed",
                            logType: "ERROR",
                            attributes: {
                              error: error.message
                            }
                          });
                          _this._emitError({
                            code: 3029,
                            message: error.message
                          });
                        }
                      case 1:
                      case "end":
                        return _context5.stop();
                    }
                  }, _callee5);
                }));
                return function (_x9, _x0) {
                  return _ref7.apply(this, arguments);
                };
              }());
              this._webSocket.on("disableWebcam", /*#__PURE__*/function () {
                var _ref8 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee6(request, accept) {
                  var disableWebcamSpan, _this$_openTelemetry28, _this$_openTelemetry29, _this$_openTelemetry30, _this$_videosdkLogs1, _t4;
                  return regenerator_default().wrap(function (_context6) {
                    while (1) switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.prev = 0;
                        disableWebcamSpan = (_this$_openTelemetry28 = _this._openTelemetry) === null || _this$_openTelemetry28 === void 0 ? void 0 : _this$_openTelemetry28.trace({
                          spanName: "Websocket REQ: disableWebcam"
                        });
                        _context6.next = 1;
                        return _this.disableWebcam(disableWebcamSpan);
                      case 1:
                        (_this$_openTelemetry29 = _this._openTelemetry) === null || _this$_openTelemetry29 === void 0 || _this$_openTelemetry29.completeSpan({
                          span: disableWebcamSpan,
                          status: 1,
                          message: "Request Completed"
                        });
                        accept();
                        _context6.next = 3;
                        break;
                      case 2:
                        _context6.prev = 2;
                        _t4 = _context6["catch"](0);
                        (_this$_openTelemetry30 = _this._openTelemetry) === null || _this$_openTelemetry30 === void 0 || _this$_openTelemetry30.completeSpan({
                          span: disableWebcamSpan,
                          status: 2,
                          message: "disableWebcam request failed ".concat(_t4)
                        });
                        (_this$_videosdkLogs1 = _this._videosdkLogs) === null || _this$_videosdkLogs1 === void 0 || _this$_videosdkLogs1.pushLogs({
                          logText: "Error disableWebcam request failed",
                          logType: "ERROR",
                          attributes: {
                            error: _t4.message
                          }
                        });
                        _this._emitError({
                          code: 3030,
                          message: _t4.message
                        });
                      case 3:
                      case "end":
                        return _context6.stop();
                    }
                  }, _callee6, null, [[0, 2]]);
                }));
                return function (_x1, _x10) {
                  return _ref8.apply(this, arguments);
                };
              }());
              this._webSocket.on("pinStateChanged", /*#__PURE__*/function () {
                var _ref9 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee7(request, accept) {
                  var pinStateChangedSpan, _this$_openTelemetry31, _this$_openTelemetry32, peerId, _state, pinnedBy, pinPeer, _this$_openTelemetry33, _this$_videosdkLogs10, _t5;
                  return regenerator_default().wrap(function (_context7) {
                    while (1) switch (_context7.prev = _context7.next) {
                      case 0:
                        _context7.prev = 0;
                        peerId = request.peerId, _state = request.state, pinnedBy = request.pinnedBy;
                        pinStateChangedSpan = (_this$_openTelemetry31 = _this._openTelemetry) === null || _this$_openTelemetry31 === void 0 ? void 0 : _this$_openTelemetry31.trace({
                          spanName: "Websocket REQ: pinStateChanged",
                          attributes: {
                            requestData: JSON.stringify({
                              peerId: peerId,
                              state: _state,
                              pinnedBy: pinnedBy
                            })
                          }
                        });

                        // check for peer

                        if (!_this._pinnedParticipants.has(peerId)) {
                          _this._pinnedParticipants.set(peerId, {
                            cam: false,
                            share: false
                          });
                        }
                        pinPeer = _this._pinnedParticipants.get(peerId);
                        if (_state.cam != undefined) {
                          pinPeer.cam = _state.cam;
                        }
                        if (_state.share != undefined) {
                          pinPeer.share = _state.share;
                        }

                        // set update state
                        _this._pinnedParticipants.set(peerId, pinPeer);
                        _this._eventEmitter.emit("PIN_STATE_CHANGED", {
                          peerId: peerId,
                          state: _state,
                          pinnedBy: pinnedBy
                        });

                        // delete if both were false or current state is false
                        if (pinPeer.share == false && pinPeer.cam == false) {
                          _this._pinnedParticipants["delete"](peerId);
                        }
                        (_this$_openTelemetry32 = _this._openTelemetry) === null || _this$_openTelemetry32 === void 0 || _this$_openTelemetry32.completeSpan({
                          span: pinStateChangedSpan,
                          status: 1,
                          message: "Request Completed",
                          attributes: {
                            _pinnedParticipants: JSON.stringify(_this._pinnedParticipants)
                          }
                        });
                        accept();
                        _context7.next = 2;
                        break;
                      case 1:
                        _context7.prev = 1;
                        _t5 = _context7["catch"](0);
                        (_this$_openTelemetry33 = _this._openTelemetry) === null || _this$_openTelemetry33 === void 0 || _this$_openTelemetry33.completeSpan({
                          span: pinStateChangedSpan,
                          status: 2,
                          message: "pinStateChanged request failed"
                        });
                        (_this$_videosdkLogs10 = _this._videosdkLogs) === null || _this$_videosdkLogs10 === void 0 || _this$_videosdkLogs10.pushLogs({
                          logText: "Error pinStateChanged request failed",
                          logType: "ERROR",
                          attributes: {
                            error: _t5.message
                          }
                        });
                        throw _t5;
                      case 2:
                      case "end":
                        return _context7.stop();
                    }
                  }, _callee7, null, [[0, 1]]);
                }));
                return function (_x11, _x12) {
                  return _ref9.apply(this, arguments);
                };
              }());
              this._webSocket.on("switchRoom", /*#__PURE__*/function () {
                var _ref0 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee8(request, accept) {
                  return regenerator_default().wrap(function (_context8) {
                    while (1) switch (_context8.prev = _context8.next) {
                      case 0:
                        _this._eventEmitter.emit("SWITCH_ROOM", request);
                        accept();
                      case 1:
                      case "end":
                        return _context8.stop();
                    }
                  }, _callee8);
                }));
                return function (_x13, _x14) {
                  return _ref0.apply(this, arguments);
                };
              }());
              this._webSocket.on("statsData", /*#__PURE__*/function () {
                var _ref1 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee9(request, accept) {
                  return regenerator_default().wrap(function (_context9) {
                    while (1) switch (_context9.prev = _context9.next) {
                      case 0:
                        accept({
                          peerId: _this._peerId,
                          statsData: _this._stats
                        });
                        _this._stats = {};
                      case 1:
                      case "end":
                        return _context9.stop();
                    }
                  }, _callee9);
                }));
                return function (_x15, _x16) {
                  return _ref1.apply(this, arguments);
                };
              }());
              this._webSocket.on("notification", /*#__PURE__*/function () {
                var _ref10 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee0(notification) {
                  var payload, _this$_videosdkLogs11, _this$_openTelemetry34, error, peerId, kind, newState, _this$_openTelemetry35, _this$_videosdkLogs12, producerId, score, _this$_openTelemetry36, id, name, internalSpan, _this$_openTelemetry37, _this$_openTelemetry38, _this$_openTelemetry39, _id, decision, sessionId, switchingRoomId, entryResponseSpan, _this$_openTelemetry41, _this$_openTelemetry40, _this$_openTelemetry42, peer, action, _this$_openTelemetry43, _this$_videosdkLogs13, _this$_openTelemetry44, _peerId2, _action, _peerId3, displayName, oldDisplayName, _this$_openTelemetry45, consumerId, consumer, _peerId4, _action2, _consumerId, _consumer, _consumerId2, _consumer2, _consumer3$appData, _consumerId3, spatialLayer, temporalLayer, _consumer3, _consumerId4, _score, dataConsumerId, dataConsumer, _peerId5, _peerId6, _action3, _this$_openTelemetry46, _this$_openTelemetry47, _this$_openTelemetry48, _this$_openTelemetry49, _this$_openTelemetry50, downstreamUrl, _state2, url, _this$_openTelemetry51, character, _action4, _this$_openTelemetry52, _id2, _action5, _this$_openTelemetry53, currentTime, _this$_openTelemetry54, _this$_openTelemetry55, transportId, iceParameters, _internalSpan, meetingId, _meetingId, reason, _meetingId2, _reason, _decision, decidedBy, _meetingId3, _peerId7, _meetingId4, _displayName, _t6;
                  return regenerator_default().wrap(function (_context0) {
                    while (1) switch (_context0.prev = _context0.next) {
                      case 0:
                        payload = notification;
                        logger.debug('proto "notification" event [method:%s, data:%o]', notification.method, payload);
                        _t6 = notification.method;
                        _context0.next = _t6 === "error" ? 1 : _t6 === "participantMediaStateChanged" ? 2 : _t6 === "producerScore" ? 3 : _t6 === "entryRequested" ? 4 : _t6 === "entryResponded" ? 5 : _t6 === "newPeer" ? 9 : _t6 === "peerClosed" ? 10 : _t6 === "peerDisplayNameChanged" ? 11 : _t6 === "consumerClosed" ? 12 : _t6 === "consumerPaused" ? 14 : _t6 === "consumerResumed" ? 16 : _t6 === "consumerLayersChanged" ? 18 : _t6 === "consumerScore" ? 20 : _t6 === "dataConsumerClosed" ? 21 : _t6 === "activeSpeaker" ? 23 : _t6 === "consumerResumedSubManager" ? 24 : _t6 === "consumerPausedSubManager" ? 25 : _t6 === "transcriptionStateChanged" ? 26 : _t6 === "transcriptionText" ? 27 : _t6 === "recordingStateChanged" ? 28 : _t6 === "recordingStarted" ? 29 : _t6 === "recordingStopped" ? 30 : _t6 === "livestreamStateChanged" ? 31 : _t6 === "livestreamStarted" ? 32 : _t6 === "livestreamStopped" ? 33 : _t6 === "hlsStateChanged" ? 34 : _t6 === "hlsPlayableStateChanged" ? 35 : _t6 === "hlsStarted" ? 36 : _t6 === "hlsStopped" ? 37 : _t6 === "whiteboardStarted" ? 38 : _t6 === "whiteboardStopped" ? 39 : _t6 === "addCharacter" ? 40 : _t6 === "removeCharacter" ? 41 : _t6 === "characterStateChanged" ? 42 : _t6 === "characterMessage" ? 43 : _t6 === "userMessage" ? 44 : _t6 === "characterData" ? 45 : _t6 === "characterError" ? 46 : _t6 === "videoStatusChanged" ? 47 : _t6 === "videoSeeked" ? 48 : _t6 === "connectionOpen" ? 49 : _t6 === "connectionClose" ? 50 : _t6 === "connectionChatMessage" ? 51 : _t6 === "connectionParticipantJoined" ? 52 : _t6 === "connectionParticipantLeft" ? 53 : _t6 === "pubsubMessage" ? 54 : _t6 === "peerModeChanged" ? 55 : _t6 === "restartIce" ? 56 : _t6 === "mediaRelayStarted" ? 57 : _t6 === "mediaRelayStopped" ? 58 : _t6 === "mediaRelayError" ? 59 : _t6 === "mediaRelayRequestResponse" ? 60 : _t6 === "mediaRelayRequestReceived" ? 61 : 62;
                        break;
                      case 1:
                        error = payload;
                        _this._eventEmitter.emit("ERROR", error);
                        (_this$_videosdkLogs11 = _this._videosdkLogs) === null || _this$_videosdkLogs11 === void 0 || _this$_videosdkLogs11.pushLogs({
                          logText: "Error in Meeting Session",
                          logType: "ERROR",
                          attributes: {
                            error: error.message
                          }
                        });
                        (_this$_openTelemetry34 = _this._openTelemetry) === null || _this$_openTelemetry34 === void 0 || _this$_openTelemetry34.traceAutoComplete({
                          spanName: "Emitted `ERROR` Event",
                          attributes: {
                            error: error.message
                          },
                          status: 2
                        });
                        return _context0.abrupt("continue", 63);
                      case 2:
                        try {
                          peerId = payload.peerId, kind = payload.kind, newState = payload.newState;
                          _this._eventEmitter.emit("PARTICIPANT_MEDIA_STATE_CHANGED", {
                            peerId: peerId,
                            kind: kind,
                            newState: newState
                          });
                          if (kind == "video") {
                            (_this$_openTelemetry35 = _this._openTelemetry) === null || _this$_openTelemetry35 === void 0 || _this$_openTelemetry35.traceAutoComplete({
                              spanName: "".concat(peerId, " has ").concat(newState ? "enable" : "disable", " ").concat(kind),
                              status: 1
                            });
                          }
                        } catch (error) {
                          logger.error('"newProducer" request failed:%o', error);
                          (_this$_videosdkLogs12 = _this._videosdkLogs) === null || _this$_videosdkLogs12 === void 0 || _this$_videosdkLogs12.pushLogs({
                            logText: "Error newProducer request failed",
                            logType: "ERROR",
                            attributes: {
                              error: error.message
                            }
                          });
                        }
                      case 3:
                        producerId = payload.producerId, score = payload.score;
                        store.dispatch(setProducerScore(producerId, score));
                        return _context0.abrupt("continue", 63);
                      case 4:
                        id = payload.id, name = payload.name;
                        internalSpan = (_this$_openTelemetry36 = _this._openTelemetry) === null || _this$_openTelemetry36 === void 0 ? void 0 : _this$_openTelemetry36.trace({
                          spanName: "Websocket Noti: entryRequested",
                          span: _this._joinSpan,
                          attributes: {
                            data: JSON.stringify({
                              id: id,
                              name: name
                            })
                          }
                        });
                        if (id !== _this._peerId) {
                          _this._eventEmitter.emit("ENTRY_REQUESTED", {
                            id: id,
                            name: name
                          });
                          (_this$_openTelemetry37 = _this._openTelemetry) === null || _this$_openTelemetry37 === void 0 || _this$_openTelemetry37.completeSpan({
                            span: internalSpan,
                            status: 1,
                            message: "EntryResponded Recieved"
                          });
                        } else {
                          (_this$_openTelemetry38 = _this._openTelemetry) === null || _this$_openTelemetry38 === void 0 || _this$_openTelemetry38.completeSpan({
                            span: internalSpan,
                            status: 2,
                            message: "Entry Request Failed"
                          });
                        }
                        return _context0.abrupt("continue", 63);
                      case 5:
                        _id = payload.id, decision = payload.decision, sessionId = payload.sessionId, switchingRoomId = payload.switchingRoomId; // Create a span for entry response handling
                        entryResponseSpan = (_this$_openTelemetry39 = _this._openTelemetry) === null || _this$_openTelemetry39 === void 0 ? void 0 : _this$_openTelemetry39.trace({
                          name: "Entry Response Handling",
                          attributes: {
                            "peer.id": _id,
                            "entry.decision": decision,
                            switching_room: !!switchingRoomId
                          }
                        }); // Emit the event once
                        _this._eventEmitter.emit("ENTRY_RESPONDED", {
                          id: _id,
                          decision: decision
                        });
                        if (!(_id === _this._peerId && decision === "allowed")) {
                          _context0.next = 7;
                          break;
                        }
                        if (!switchingRoomId) {
                          _context0.next = 6;
                          break;
                        }
                        (_this$_openTelemetry40 = _this._openTelemetry) === null || _this$_openTelemetry40 === void 0 || _this$_openTelemetry40.completeSpan({
                          span: entryResponseSpan,
                          status: 1,
                          message: "Switching room initiated"
                        });
                        _this.softClose();
                        _this.switchingRoom(switchingRoomId);
                        return _context0.abrupt("continue", 63);
                      case 6:
                        _this._videosdkLogs = new VideoSDKLogs({
                          roomId: _this._roomId,
                          peerId: _this._peerId,
                          logs: logs,
                          observabilityJwt: observabilityJwt,
                          deviceInfo: _this._deviceInfo,
                          sessionId: sessionId,
                          debugMode: _this._debugMode
                        });
                        _this.joinRoom();
                        (_this$_openTelemetry41 = _this._openTelemetry) === null || _this$_openTelemetry41 === void 0 || _this$_openTelemetry41.completeSpan({
                          span: entryResponseSpan,
                          status: 1,
                          message: "EntryResponded Recieved"
                        });
                        _context0.next = 8;
                        break;
                      case 7:
                        (_this$_openTelemetry42 = _this._openTelemetry) === null || _this$_openTelemetry42 === void 0 || _this$_openTelemetry42.completeSpan({
                          span: _this._joinSpan,
                          status: 2,
                          message: "Join Request Denied"
                        });
                      case 8:
                        return _context0.abrupt("continue", 63);
                      case 9:
                        peer = payload;
                        action = addPeer(RoomClient_objectSpread(RoomClient_objectSpread({}, peer), {}, {
                          consumers: [],
                          dataConsumers: []
                        }));
                        store.dispatch(action);
                        _this._eventEmitter.emit(action.type, action.payload);
                        store.dispatch(notify({
                          text: "".concat(peer.displayName, " has joined the room")
                        }));
                        try {
                          (_this$_openTelemetry43 = _this._openTelemetry) === null || _this$_openTelemetry43 === void 0 || _this$_openTelemetry43.traceAutoComplete({
                            spanName: "Websocket Noti: newPeer ".concat(peer.displayName),
                            attributes: {
                              peerData: JSON.stringify(peer)
                            }
                          });
                        } catch (error) {
                          (_this$_videosdkLogs13 = _this._videosdkLogs) === null || _this$_videosdkLogs13 === void 0 || _this$_videosdkLogs13.pushLogs({
                            logText: "Error Websocket Noti: newPeer",
                            logType: "ERROR",
                            attributes: {
                              error: error.message
                            }
                          });
                          console.error(error);
                        }
                        return _context0.abrupt("continue", 63);
                      case 10:
                        _peerId2 = payload.peerId;
                        _action = removePeer(_peerId2);
                        store.dispatch(_action);
                        _this._eventEmitter.emit(_action.type, _action.payload);
                        (_this$_openTelemetry44 = _this._openTelemetry) === null || _this$_openTelemetry44 === void 0 || _this$_openTelemetry44.traceAutoComplete({
                          spanName: "Websocket Noti: peerClosed for ".concat(_peerId2)
                        });
                        return _context0.abrupt("continue", 63);
                      case 11:
                        _peerId3 = payload.peerId, displayName = payload.displayName, oldDisplayName = payload.oldDisplayName;
                        store.dispatch(setPeerDisplayName(displayName, _peerId3));
                        store.dispatch(notify({
                          text: "".concat(oldDisplayName, " is now ").concat(displayName)
                        }));
                        return _context0.abrupt("continue", 63);
                      case 12:
                        consumerId = payload.consumerId;
                        consumer = _this._consumers.get(consumerId);
                        if (consumer) {
                          _context0.next = 13;
                          break;
                        }
                        return _context0.abrupt("continue", 63);
                      case 13:
                        consumer.close();
                        _this._consumers["delete"](consumerId);
                        _peerId4 = consumer.appData.peerId;
                        _action2 = removeConsumer(consumerId, _peerId4);
                        _this._eventEmitter.emit("STREAM_STATE_CHANGED", {
                          state: "ended",
                          peerId: _peerId4,
                          streamId: consumer._track.id
                        });
                        store.dispatch(_action2);
                        _this._eventEmitter.emit(_action2.type, _action2.payload);
                        (_this$_openTelemetry45 = _this._openTelemetry) === null || _this$_openTelemetry45 === void 0 || _this$_openTelemetry45.traceAutoComplete({
                          spanName: "Websocket Noti: consumerClosed for id ".concat(consumerId),
                          attributes: {
                            consumerData: JSON.stringify(consumer)
                          }
                        });
                        return _context0.abrupt("continue", 63);
                      case 14:
                        _consumerId = payload.consumerId;
                        _consumer = _this._consumers.get(_consumerId);
                        if (_consumer) {
                          _context0.next = 15;
                          break;
                        }
                        return _context0.abrupt("continue", 63);
                      case 15:
                        _consumer.pause();
                        store.dispatch(setConsumerPaused(_consumerId, "remote"));
                        _this._eventEmitter.emit("CONSUMER_PAUSED", {
                          consumerId: _consumerId,
                          peerId: _consumer.appData.peerId
                        });
                        return _context0.abrupt("continue", 63);
                      case 16:
                        _consumerId2 = payload.consumerId;
                        _consumer2 = _this._consumers.get(_consumerId2);
                        _this._eventEmitter.emit("STREAM_STATE_CHANGED", {
                          state: "active",
                          peerId: _consumer2.appData.peerId,
                          streamId: _consumer2._track.id
                        });
                        if (_consumer2) {
                          _context0.next = 17;
                          break;
                        }
                        return _context0.abrupt("continue", 63);
                      case 17:
                        _consumer2.resume();
                        store.dispatch(setConsumerResumed(_consumerId2, "remote"));
                        _this._eventEmitter.emit("CONSUMER_RESUMED", {
                          consumerId: _consumerId2,
                          peerId: _consumer2.appData.peerId
                        });
                        return _context0.abrupt("continue", 63);
                      case 18:
                        _consumerId3 = payload.consumerId, spatialLayer = payload.spatialLayer, temporalLayer = payload.temporalLayer;
                        _consumer3 = _this._consumers.get(_consumerId3);
                        _consumer3.currentSpatialLayer = spatialLayer;
                        _consumer3.currentTemporalLayer = temporalLayer;
                        if (_consumer3) {
                          _context0.next = 19;
                          break;
                        }
                        return _context0.abrupt("continue", 63);
                      case 19:
                        if (((_consumer3$appData = _consumer3.appData) === null || _consumer3$appData === void 0 || (_consumer3$appData = _consumer3$appData.encodings) === null || _consumer3$appData === void 0 ? void 0 : _consumer3$appData.length) > 1) {
                          _this._eventEmitter.emit("VIDEO_QUALITY_CHANGED", {
                            peerId: _consumer3.appData.peerId,
                            prevQuality: _consumer3.spatialLayers - 1 - _consumer3.currentSpatialLayer == 0 ? "HIGH" : _consumer3.spatialLayers - 1 - _consumer3.currentSpatialLayer == 1 ? "MEDIUM" : "LOW",
                            currentQuality: _consumer3.spatialLayers - 1 - spatialLayer == 0 ? "HIGH" : _consumer3.spatialLayers - 1 - spatialLayer == 1 ? "MEDIUM" : "LOW"
                          });

                          // this._videosdkLogs?.pushLogs({
                          //   logText: `Consumer Peer ${consumer.appData.peerId} changed to ${consumer.spatialLayers - 1 - spatialLayer == 0
                          //     ? "HIGH"
                          //     : consumer.spatialLayers - 1 - spatialLayer == 1
                          //       ? "MEDIUM"
                          //       : "LOW"
                          //     }, previous quality was ${consumer.spatialLayers - 1 - consumer.currentSpatialLayer == 0
                          //       ? "HIGH"
                          //       : consumer.spatialLayers - 1 - consumer.currentSpatialLayer ==
                          //         1
                          //         ? "MEDIUM"
                          //         : "LOW"
                          //     }`,
                          //   logType: "INFO",
                          //   attributes: {
                          //     spatialLayer,
                          //     temporalLayer,
                          //     consumerId: consumerId,
                          //   },
                          // });
                        } else {
                          // this._eventEmitter.emit("VIDEO_QUALITY_CHANGED", {
                          //   peerId: consumer.appData.peerId,
                          //   prevQuality: "HIGH",
                          //   currentQuality: "HIGH",
                          // });
                          // this._videosdkLogs?.pushLogs({
                          //   logText: `Consumer Peer ${consumer.appData.peerId} changed to HIGH, previous quality was HIGH`,
                          //   logType: "INFO",
                          //   attributes: {
                          //     consumerId: consumerId,
                          //   },
                          // });
                        }
                        _consumer3.currentSpatialLayer = spatialLayer;
                        _consumer3.currentTemporalLayer = temporalLayer;
                        store.dispatch(setConsumerCurrentLayers(_consumerId3, spatialLayer, temporalLayer));
                        return _context0.abrupt("continue", 63);
                      case 20:
                        _consumerId4 = payload.consumerId, _score = payload.score;
                        store.dispatch(setConsumerScore(_consumerId4, _score));
                        return _context0.abrupt("continue", 63);
                      case 21:
                        dataConsumerId = payload.dataConsumerId;
                        dataConsumer = _this._dataConsumers.get(dataConsumerId);
                        if (dataConsumer) {
                          _context0.next = 22;
                          break;
                        }
                        return _context0.abrupt("continue", 63);
                      case 22:
                        dataConsumer.close();
                        _this._dataConsumers["delete"](dataConsumerId);
                        _peerId5 = dataConsumer.appData.peerId;
                        store.dispatch(removeDataConsumer(dataConsumerId, _peerId5));
                        return _context0.abrupt("continue", 63);
                      case 23:
                        _peerId6 = payload.peerId;
                        _action3 = setRoomActiveSpeaker(_peerId6);
                        store.dispatch(_action3);
                        _this._eventEmitter.emit(_action3.type, _action3.payload);
                        return _context0.abrupt("continue", 63);
                      case 24:
                        _this._eventEmitter.emit("SUB_MANAGER_RESUMED", payload);
                        return _context0.abrupt("continue", 63);
                      case 25:
                        _this._eventEmitter.emit("SUB_MANAGER_PAUSED", payload);
                        return _context0.abrupt("continue", 63);
                      case 26:
                        _this._eventEmitter.emit("TRANSCRIPTION_STATE_CHANGED", payload);
                        (_this$_openTelemetry46 = _this._openTelemetry) === null || _this$_openTelemetry46 === void 0 || _this$_openTelemetry46.traceAutoComplete({
                          spanName: "Emitted TRANSCRIPTION_STATE_CHANGED, status : ".concat(payload.status),
                          attributes: {
                            data: JSON.stringify(payload)
                          },
                          status: 1
                        });
                        return _context0.abrupt("continue", 63);
                      case 27:
                        _this._eventEmitter.emit("TRANSCRIPTION_TEXT", payload);
                        return _context0.abrupt("continue", 63);
                      case 28:
                        //pass notification data for recordingStatus.
                        _this._eventEmitter.emit("RECORDING_STATE_CHANGED", payload);
                        (_this$_openTelemetry47 = _this._openTelemetry) === null || _this$_openTelemetry47 === void 0 || _this$_openTelemetry47.traceAutoComplete({
                          spanName: "Emitted RECORDING_STATE_CHANGED, status : ".concat(payload.status),
                          attributes: {
                            data: JSON.stringify(payload)
                          },
                          status: 1
                        });
                        return _context0.abrupt("continue", 63);
                      case 29:
                        _this._eventEmitter.emit("RECORDING_STARTED", {});
                        return _context0.abrupt("continue", 63);
                      case 30:
                        _this._eventEmitter.emit("RECORDING_STOPPED", {});
                        return _context0.abrupt("continue", 63);
                      case 31:
                        //pass notification data for recordingStatus.
                        _this._eventEmitter.emit("LIVESTREAM_STATE_CHANGED", payload);
                        (_this$_openTelemetry48 = _this._openTelemetry) === null || _this$_openTelemetry48 === void 0 || _this$_openTelemetry48.traceAutoComplete({
                          spanName: "Emitted LIVESTREAM_STATE_CHANGED, status : ".concat(payload.status),
                          attributes: {
                            data: JSON.stringify(payload)
                          },
                          status: 1
                        });
                        return _context0.abrupt("continue", 63);
                      case 32:
                        _this._eventEmitter.emit("LIVESTREAM_STARTED", {});
                        return _context0.abrupt("continue", 63);
                      case 33:
                        _this._eventEmitter.emit("LIVESTREAM_STOPPED", {});
                        return _context0.abrupt("continue", 63);
                      case 34:
                        //pass notification data for hlsStatus.
                        _this._eventEmitter.emit("HLS_STATE_CHANGED", payload);
                        (_this$_openTelemetry49 = _this._openTelemetry) === null || _this$_openTelemetry49 === void 0 || _this$_openTelemetry49.traceAutoComplete({
                          spanName: "Emitted HLS_STATE_CHANGED, status : ".concat(payload.status),
                          attributes: {
                            data: JSON.stringify(payload)
                          },
                          status: 1
                        });
                        return _context0.abrupt("continue", 63);
                      case 35:
                        //pass notification data for hlsStatus.
                        if (payload.isPlayable) {
                          _this._eventEmitter.emit("HLS_STATE_CHANGED", RoomClient_objectSpread(RoomClient_objectSpread({}, payload), {}, {
                            status: hlsEvents/* hlsEvents */.V.HLS_PLAYABLE
                          }));
                          (_this$_openTelemetry50 = _this._openTelemetry) === null || _this$_openTelemetry50 === void 0 || _this$_openTelemetry50.traceAutoComplete({
                            spanName: "Websocket Noti: hlsPlayableStateChanged",
                            status: 1
                          });
                        }
                        return _context0.abrupt("continue", 63);
                      case 36:
                        downstreamUrl = payload.downstreamUrl;
                        _this._eventEmitter.emit("HLS_STARTED", downstreamUrl);
                        return _context0.abrupt("continue", 63);
                      case 37:
                        _this._eventEmitter.emit("HLS_STOPPED", {});
                        return _context0.abrupt("continue", 63);
                      case 38:
                        _state2 = payload.state, url = payload.url;
                        if (_state2) {
                          _this._eventEmitter.emit("WHITEBOARD_STARTED", {
                            state: _state2
                          });
                        } else if (url) {
                          _this._eventEmitter.emit("WHITEBOARD_STARTED", {
                            url: url
                          });
                        }
                        return _context0.abrupt("continue", 63);
                      case 39:
                        _this._eventEmitter.emit("WHITEBOARD_STOPPED", {});
                        return _context0.abrupt("continue", 63);
                      case 40:
                        character = payload; // ADD_PEER
                        _action4 = addPeer(RoomClient_objectSpread(RoomClient_objectSpread({}, character), {}, {
                          consumers: [],
                          dataConsumers: []
                        }));
                        store.dispatch(_action4);
                        _this._eventEmitter.emit("ADD_CHARACTER", payload);
                        (_this$_openTelemetry51 = _this._openTelemetry) === null || _this$_openTelemetry51 === void 0 || _this$_openTelemetry51.traceAutoComplete({
                          spanName: "Emitted ADD_CHARACTER : ".concat(payload),
                          attributes: {
                            data: JSON.stringify(payload)
                          },
                          status: 1
                        });
                        return _context0.abrupt("continue", 63);
                      case 41:
                        _id2 = payload.id;
                        _action5 = removePeer(_id2);
                        store.dispatch(_action5);
                        _this._eventEmitter.emit("REMOVE_CHARACTER", payload);
                        (_this$_openTelemetry52 = _this._openTelemetry) === null || _this$_openTelemetry52 === void 0 || _this$_openTelemetry52.traceAutoComplete({
                          spanName: "Emitted REMOVE_CHARACTER : ".concat(payload),
                          attributes: {
                            data: JSON.stringify(payload)
                          },
                          status: 1
                        });
                        return _context0.abrupt("continue", 63);
                      case 42:
                        _this._eventEmitter.emit("CHARACTER_STATE_CHANGED", payload);
                        (_this$_openTelemetry53 = _this._openTelemetry) === null || _this$_openTelemetry53 === void 0 || _this$_openTelemetry53.traceAutoComplete({
                          spanName: "Emitted CHARACTER_STATE_CHANGED, status : ".concat(payload.status),
                          attributes: {
                            data: JSON.stringify(payload)
                          },
                          status: 1
                        });
                        return _context0.abrupt("continue", 63);
                      case 43:
                        _this._eventEmitter.emit("CHARACTER_MESSAGE", payload);
                        return _context0.abrupt("continue", 63);
                      case 44:
                        _this._eventEmitter.emit("USER_MESSAGE", payload);
                        return _context0.abrupt("continue", 63);
                      case 45:
                        _this._eventEmitter.emit("CHARACTER_DATA", payload);
                        return _context0.abrupt("continue", 63);
                      case 46:
                        _this._eventEmitter.emit("CHARACTER_ERROR", payload);
                        return _context0.abrupt("continue", 63);
                      case 47:
                        _this._eventEmitter.emit("VIDEO_STATE_CHANGED", payload);
                        return _context0.abrupt("continue", 63);
                      case 48:
                        currentTime = payload.currentTime;
                        _this._eventEmitter.emit("VIDEO_SEEKED", {
                          currentTime: currentTime
                        });
                        return _context0.abrupt("continue", 63);
                      case 49:
                        _this._eventEmitter.emit("CONNECTION_OPEN", payload);
                        return _context0.abrupt("continue", 63);
                      case 50:
                        _this._eventEmitter.emit("CONNECTION_CLOSE", payload);
                        return _context0.abrupt("continue", 63);
                      case 51:
                        _this._eventEmitter.emit("CONNECTION_CHAT_MESSAGE", payload);
                        return _context0.abrupt("continue", 63);
                      case 52:
                        _this._eventEmitter.emit("CONNECTION_PARTICIPANT_JOIN", payload);
                        return _context0.abrupt("continue", 63);
                      case 53:
                        _this._eventEmitter.emit("CONNECTION_PARTICIPANT_LEFT", payload);
                        return _context0.abrupt("continue", 63);
                      case 54:
                        _this._eventEmitter.emit("PUBSUB_MESSAGE", payload);
                        return _context0.abrupt("continue", 63);
                      case 55:
                        _this._eventEmitter.emit("PEER_MODE_CHANGED", payload);
                        (_this$_openTelemetry54 = _this._openTelemetry) === null || _this$_openTelemetry54 === void 0 || _this$_openTelemetry54.traceAutoComplete({
                          spanName: "Emitted PEER_MODE_CHANGED",
                          attributes: {
                            data: JSON.stringify(payload)
                          },
                          status: 1
                        });
                        return _context0.abrupt("continue", 63);
                      case 56:
                        transportId = payload.transportId, iceParameters = payload.iceParameters;
                        _internalSpan = (_this$_openTelemetry55 = _this._openTelemetry) === null || _this$_openTelemetry55 === void 0 ? void 0 : _this$_openTelemetry55.trace({
                          spanName: "Websocket Noti: restartIce for transportId :".concat(transportId),
                          attributes: {
                            iceParameters: JSON.stringify(iceParameters)
                          }
                        });
                        _this.handleRemoteRestartIce({
                          transportId: transportId,
                          iceParameters: iceParameters,
                          internalSpan: _internalSpan
                        });
                        return _context0.abrupt("continue", 63);
                      case 57:
                        meetingId = notification.meetingId;
                        _this._eventEmitter.emit("MEDIA_RELAY_STARTED", {
                          meetingId: meetingId
                        });
                        return _context0.abrupt("continue", 63);
                      case 58:
                        _meetingId = notification.meetingId, reason = notification.reason;
                        _this._eventEmitter.emit("MEDIA_RELAY_STOPPED", {
                          meetingId: _meetingId,
                          reason: reason
                        });
                        return _context0.abrupt("continue", 63);
                      case 59:
                        _meetingId2 = notification.meetingId, _reason = notification.reason;
                        _this._eventEmitter.emit("MEDIA_RELAY_ERROR", {
                          meetingId: _meetingId2,
                          reason: _reason
                        });
                        return _context0.abrupt("continue", 63);
                      case 60:
                        _decision = notification.decision, decidedBy = notification.decidedBy, _meetingId3 = notification.meetingId;
                        _this._eventEmitter.emit("MEDIA_RELAY_REQUEST_RESPONSE", {
                          decision: _decision,
                          decidedBy: decidedBy,
                          meetingId: _meetingId3
                        });
                        return _context0.abrupt("continue", 63);
                      case 61:
                        _peerId7 = notification.peerId, _meetingId4 = notification.meetingId, _displayName = notification.displayName;
                        _this._eventEmitter.emit("MEDIA_RELAY_REQUEST_RECEIVED", {
                          peerId: _peerId7,
                          meetingId: _meetingId4,
                          displayName: _displayName
                        });
                        return _context0.abrupt("continue", 63);
                      case 62:
                        logger.error('unknown Websocket notification.method "%s"', notification.method);
                      case 63:
                      case "end":
                        return _context0.stop();
                    }
                  }, _callee0);
                }));
                return function (_x17) {
                  return _ref10.apply(this, arguments);
                };
              }());
              _context1.next = 3;
              break;
            case 2:
              _context1.prev = 2;
              _t7 = _context1["catch"](0);
              (_this$_videosdkLogs14 = this._videosdkLogs) === null || _this$_videosdkLogs14 === void 0 || _this$_videosdkLogs14.pushLogs({
                logText: "Error initializing the meeting :: ".concat(_t7),
                logType: "ERROR",
                attributes: {
                  error: _t7
                }
              });
              this.emitMeetingStateChange(state.FAILED);
            case 3:
            case "end":
              return _context1.stop();
          }
        }, _callee1, this, [[0, 2]]);
      }));
      function join() {
        return _join.apply(this, arguments);
      }
      return join;
    }()
  }, {
    key: "requestEntry",
    value: function () {
      var _requestEntry = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee10() {
        var _this$_openTelemetry56, _this$_openTelemetry57;
        var requestEntrySpan;
        return regenerator_default().wrap(function (_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              requestEntrySpan = (_this$_openTelemetry56 = this._openTelemetry) === null || _this$_openTelemetry56 === void 0 ? void 0 : _this$_openTelemetry56.trace({
                spanName: "Requesting Entry",
                span: this._joinSpan
              });
              _context10.next = 1;
              return this._socketRequest("requestEntry", {
                name: this._displayName
              });
            case 1:
              (_this$_openTelemetry57 = this._openTelemetry) === null || _this$_openTelemetry57 === void 0 || _this$_openTelemetry57.completeSpan({
                span: requestEntrySpan,
                status: 1,
                message: "Entry Requested Successfully"
              });
            case 2:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function requestEntry() {
        return _requestEntry.apply(this, arguments);
      }
      return requestEntry;
    }()
  }, {
    key: "respondEntry",
    value: function () {
      var _respondEntry = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee11(peerId, decision) {
        var _this$_openTelemetry58, _this$_openTelemetry59;
        var respondEntrySpan;
        return regenerator_default().wrap(function (_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              respondEntrySpan = (_this$_openTelemetry58 = this._openTelemetry) === null || _this$_openTelemetry58 === void 0 ? void 0 : _this$_openTelemetry58.trace({
                spanName: "Responding Entry",
                attributes: {
                  peerId: peerId,
                  decision: decision
                },
                span: this._joinSpan
              });
              _context11.next = 1;
              return this._socketRequest("respondEntry", {
                id: peerId,
                decision: decision
              });
            case 1:
              (_this$_openTelemetry59 = this._openTelemetry) === null || _this$_openTelemetry59 === void 0 || _this$_openTelemetry59.completeSpan({
                message: "Entry Responded Successfully",
                span: respondEntrySpan,
                status: 1
              });
            case 2:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function respondEntry(_x18, _x19) {
        return _respondEntry.apply(this, arguments);
      }
      return respondEntry;
    }()
  }, {
    key: "startTranscription",
    value: function () {
      var _startTranscription = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee12(config) {
        var _this$_openTelemetry60, _this$_openTelemetry62;
        var startTranscriptionSpan, _this$_openTelemetry61, _this$_videosdkLogs15, _t8;
        return regenerator_default().wrap(function (_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              logger.debug("startTranscription()");
              startTranscriptionSpan = (_this$_openTelemetry60 = this._openTelemetry) === null || _this$_openTelemetry60 === void 0 ? void 0 : _this$_openTelemetry60.trace({
                spanName: "startTranscription() Start",
                attributes: {
                  config: config ? JSON.stringify(config) : "config Not Specify"
                }
              });
              _context12.prev = 1;
              _context12.next = 2;
              return this._socketRequest("startTranscription", {
                config: config
              });
            case 2:
              _context12.next = 4;
              break;
            case 3:
              _context12.prev = 3;
              _t8 = _context12["catch"](1);
              logger.error("startTranscription() | failed:%o", _t8);
              (_this$_openTelemetry61 = this._openTelemetry) === null || _this$_openTelemetry61 === void 0 || _this$_openTelemetry61.completeSpan({
                span: startTranscriptionSpan,
                status: 2,
                message: "startTranscription() failed"
              });
              (_this$_videosdkLogs15 = this._videosdkLogs) === null || _this$_videosdkLogs15 === void 0 || _this$_videosdkLogs15.pushLogs({
                logText: "Error startTranscription() failed",
                logType: "ERROR",
                attributes: {
                  error: _t8.message
                }
              });
              this._emitError({
                code: 4031,
                message: _t8.message
              });
            case 4:
              (_this$_openTelemetry62 = this._openTelemetry) === null || _this$_openTelemetry62 === void 0 || _this$_openTelemetry62.completeSpan({
                span: startTranscriptionSpan,
                status: 1,
                message: "startTranscription() End"
              });
            case 5:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this, [[1, 3]]);
      }));
      function startTranscription(_x20) {
        return _startTranscription.apply(this, arguments);
      }
      return startTranscription;
    }()
  }, {
    key: "stopTranscription",
    value: function () {
      var _stopTranscription = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee13() {
        var _this$_openTelemetry63, _this$_openTelemetry65;
        var stopTranscriptionSpan, _this$_openTelemetry64, _this$_videosdkLogs16, _t9;
        return regenerator_default().wrap(function (_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              logger.debug("stopTranscription()");
              stopTranscriptionSpan = (_this$_openTelemetry63 = this._openTelemetry) === null || _this$_openTelemetry63 === void 0 ? void 0 : _this$_openTelemetry63.trace({
                spanName: "stopTranscription() Start"
              });
              _context13.prev = 1;
              _context13.next = 2;
              return this._socketRequest("stopTranscription", {});
            case 2:
              _context13.next = 4;
              break;
            case 3:
              _context13.prev = 3;
              _t9 = _context13["catch"](1);
              (_this$_openTelemetry64 = this._openTelemetry) === null || _this$_openTelemetry64 === void 0 || _this$_openTelemetry64.completeSpan({
                span: stopTranscriptionSpan,
                status: 2,
                message: "stopTranscription() failed"
              });
              (_this$_videosdkLogs16 = this._videosdkLogs) === null || _this$_videosdkLogs16 === void 0 || _this$_videosdkLogs16.pushLogs({
                logText: "Error stopTranscription() failed",
                logType: "ERROR",
                attributes: {
                  error: _t9.message
                }
              });
              this._emitError({
                code: 4032,
                message: _t9.message
              });
            case 4:
              (_this$_openTelemetry65 = this._openTelemetry) === null || _this$_openTelemetry65 === void 0 || _this$_openTelemetry65.completeSpan({
                span: stopTranscriptionSpan,
                status: 1,
                message: "stopTranscription() End"
              });
            case 5:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this, [[1, 3]]);
      }));
      function stopTranscription() {
        return _stopTranscription.apply(this, arguments);
      }
      return stopTranscription;
    }()
  }, {
    key: "pauseAllConsumers",
    value: function () {
      var _pauseAllConsumers = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee14(kind) {
        var _this$_openTelemetry66, _this$_openTelemetry68;
        var pauseConsumersSpan, _response$consumersWi, response, success, _response$consumersWi2, _response, _this$_openTelemetry67, _this$_videosdkLogs17, _t0;
        return regenerator_default().wrap(function (_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              pauseConsumersSpan = (_this$_openTelemetry66 = this._openTelemetry) === null || _this$_openTelemetry66 === void 0 ? void 0 : _this$_openTelemetry66.trace({
                spanName: "pauseAllConsumers() Start",
                attributes: {
                  kind: kind ? kind : "Kind not specified"
                }
              });
              _context14.prev = 1;
              _context14.next = 2;
              return this._socketRequest("pauseAllConsumers", {
                kind: kind === undefined ? "all" : kind
              });
            case 2:
              response = _context14.sent;
              success = false;
              if (!((response === null || response === void 0 || (_response$consumersWi = response.consumersWithIssues) === null || _response$consumersWi === void 0 ? void 0 : _response$consumersWi.length) > 0)) {
                _context14.next = 4;
                break;
              }
              _context14.next = 3;
              return this._socketRequest("pauseAllConsumers", {
                kind: kind === undefined ? "all" : kind
              });
            case 3:
              _response = _context14.sent;
              if ((_response === null || _response === void 0 || (_response$consumersWi2 = _response.consumersWithIssues) === null || _response$consumersWi2 === void 0 ? void 0 : _response$consumersWi2.length) === 0) {
                success = true;
              }
              _context14.next = 5;
              break;
            case 4:
              success = true;
            case 5:
              if (success) {
                this._eventEmitter.emit("ALL_CONSUMERS_PAUSED", {
                  kind: kind
                });
              }
              _context14.next = 7;
              break;
            case 6:
              _context14.prev = 6;
              _t0 = _context14["catch"](1);
              logger.error("pauseAllConsumers() | failed:%o", _t0);
              (_this$_openTelemetry67 = this._openTelemetry) === null || _this$_openTelemetry67 === void 0 || _this$_openTelemetry67.completeSpan({
                span: pauseConsumersSpan,
                status: 2,
                message: "pauseAllConsumers() failed"
              });
              (_this$_videosdkLogs17 = this._videosdkLogs) === null || _this$_videosdkLogs17 === void 0 || _this$_videosdkLogs17.pushLogs({
                logText: "Error pauseAllConsumers() failed",
                logType: "ERROR",
                attributes: {
                  error: _t0.message
                }
              });
            case 7:
              (_this$_openTelemetry68 = this._openTelemetry) === null || _this$_openTelemetry68 === void 0 || _this$_openTelemetry68.completeSpan({
                span: pauseConsumersSpan,
                status: 1,
                message: "pauseAllConsumers() End"
              });
            case 8:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this, [[1, 6]]);
      }));
      function pauseAllConsumers(_x21) {
        return _pauseAllConsumers.apply(this, arguments);
      }
      return pauseAllConsumers;
    }()
  }, {
    key: "resumeAllConsumers",
    value: function () {
      var _resumeAllConsumers = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee15(kind) {
        var _this$_openTelemetry69, _this$_openTelemetry71;
        var resumeConsumersSpan, _response$consumersWi3, response, success, _response2$consumersW, _response2, _this$_openTelemetry70, _this$_videosdkLogs18, _t1;
        return regenerator_default().wrap(function (_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              resumeConsumersSpan = (_this$_openTelemetry69 = this._openTelemetry) === null || _this$_openTelemetry69 === void 0 ? void 0 : _this$_openTelemetry69.trace({
                spanName: "resumeAllConsumers() Start",
                attributes: {
                  kind: kind ? kind : "Kind not specified"
                }
              });
              _context15.prev = 1;
              _context15.next = 2;
              return this._socketRequest("resumeAllConsumers", {
                kind: kind === undefined ? "all" : kind
              });
            case 2:
              response = _context15.sent;
              success = false;
              if (!((response === null || response === void 0 || (_response$consumersWi3 = response.consumersWithIssues) === null || _response$consumersWi3 === void 0 ? void 0 : _response$consumersWi3.length) > 0)) {
                _context15.next = 4;
                break;
              }
              _context15.next = 3;
              return this._socketRequest("resumeAllConsumers", {
                kind: kind === undefined ? "all" : kind
              });
            case 3:
              _response2 = _context15.sent;
              if ((_response2 === null || _response2 === void 0 || (_response2$consumersW = _response2.consumersWithIssues) === null || _response2$consumersW === void 0 ? void 0 : _response2$consumersW.length) === 0) {
                success = true;
              }
              _context15.next = 5;
              break;
            case 4:
              success = true;
            case 5:
              if (success) {
                this._eventEmitter.emit("ALL_CONSUMERS_RESUMED", {
                  kind: kind
                });
              }
              _context15.next = 7;
              break;
            case 6:
              _context15.prev = 6;
              _t1 = _context15["catch"](1);
              logger.error("resumeAllConsumers() | failed:%o", _t1);
              (_this$_openTelemetry70 = this._openTelemetry) === null || _this$_openTelemetry70 === void 0 || _this$_openTelemetry70.completeSpan({
                span: resumeConsumersSpan,
                status: 2,
                message: "resumeAllConsumers() failed"
              });
              (_this$_videosdkLogs18 = this._videosdkLogs) === null || _this$_videosdkLogs18 === void 0 || _this$_videosdkLogs18.pushLogs({
                logText: "Error resumeAllConsumers() failed",
                logType: "ERROR",
                attributes: {
                  error: _t1.message
                }
              });
            case 7:
              (_this$_openTelemetry71 = this._openTelemetry) === null || _this$_openTelemetry71 === void 0 || _this$_openTelemetry71.completeSpan({
                span: resumeConsumersSpan,
                status: 1,
                message: "resumeAllConsumers() End"
              });
            case 8:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this, [[1, 6]]);
      }));
      function resumeAllConsumers(_x22) {
        return _resumeAllConsumers.apply(this, arguments);
      }
      return resumeAllConsumers;
    }()
  }, {
    key: "startRecording",
    value: function () {
      var _startRecording = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee16(webhookUrl, awsDirPath, config, transcription) {
        var _this$_openTelemetry72, _this$_openTelemetry74;
        var startRecordingSpan, _this$_openTelemetry73, _this$_videosdkLogs19, _t10;
        return regenerator_default().wrap(function (_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              logger.debug("startRecording()");
              startRecordingSpan = (_this$_openTelemetry72 = this._openTelemetry) === null || _this$_openTelemetry72 === void 0 ? void 0 : _this$_openTelemetry72.trace({
                spanName: "startRecording() Start",
                attributes: {
                  webhookUrl: webhookUrl ? webhookUrl : "webhookUrl Not Specify",
                  awsDirPath: awsDirPath ? awsDirPath : "awsDirPath Not Specify",
                  config: config ? JSON.stringify(config) : "config Not Specify",
                  transcription: transcription ? JSON.stringify(transcription) : "transcription Not Specify"
                }
              });
              _context16.prev = 1;
              _context16.next = 2;
              return this._socketRequest("startRecording", {
                webhookUrl: webhookUrl,
                awsDirPath: awsDirPath,
                config: config,
                transcription: transcription
              });
            case 2:
              _context16.next = 4;
              break;
            case 3:
              _context16.prev = 3;
              _t10 = _context16["catch"](1);
              logger.error("startRecording() | failed:%o", _t10);
              (_this$_openTelemetry73 = this._openTelemetry) === null || _this$_openTelemetry73 === void 0 || _this$_openTelemetry73.completeSpan({
                span: startRecordingSpan,
                status: 2,
                message: "startRecording() failed"
              });
              (_this$_videosdkLogs19 = this._videosdkLogs) === null || _this$_videosdkLogs19 === void 0 || _this$_videosdkLogs19.pushLogs({
                logText: "Error startRecording() failed",
                logType: "ERROR",
                attributes: {
                  error: _t10.message
                }
              });
              this._emitError({
                code: 4011,
                message: _t10.message
              });
            case 4:
              (_this$_openTelemetry74 = this._openTelemetry) === null || _this$_openTelemetry74 === void 0 || _this$_openTelemetry74.completeSpan({
                span: startRecordingSpan,
                status: 1,
                message: "startRecording() End"
              });
            case 5:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this, [[1, 3]]);
      }));
      function startRecording(_x23, _x24, _x25, _x26) {
        return _startRecording.apply(this, arguments);
      }
      return startRecording;
    }()
  }, {
    key: "stopRecording",
    value: function () {
      var _stopRecording = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee17() {
        var _this$_openTelemetry75, _this$_openTelemetry77;
        var stopRecordingSpan, _this$_openTelemetry76, _this$_videosdkLogs20, _t11;
        return regenerator_default().wrap(function (_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              if (!this._closed) {
                _context17.next = 1;
                break;
              }
              return _context17.abrupt("return");
            case 1:
              logger.debug("stopRecording()");
              stopRecordingSpan = (_this$_openTelemetry75 = this._openTelemetry) === null || _this$_openTelemetry75 === void 0 ? void 0 : _this$_openTelemetry75.trace({
                spanName: "stopRecording() Start"
              });
              _context17.prev = 2;
              _context17.next = 3;
              return this._socketRequest("stopRecording", {});
            case 3:
              _context17.next = 5;
              break;
            case 4:
              _context17.prev = 4;
              _t11 = _context17["catch"](2);
              (_this$_openTelemetry76 = this._openTelemetry) === null || _this$_openTelemetry76 === void 0 || _this$_openTelemetry76.completeSpan({
                span: stopRecordingSpan,
                status: 2,
                message: "stopRecording() failed"
              });
              (_this$_videosdkLogs20 = this._videosdkLogs) === null || _this$_videosdkLogs20 === void 0 || _this$_videosdkLogs20.pushLogs({
                logText: "Error stopRecording() failed",
                logType: "ERROR",
                attributes: {
                  error: _t11.message
                }
              });
              this._emitError({
                code: 4012,
                message: _t11.message
              });
            case 5:
              (_this$_openTelemetry77 = this._openTelemetry) === null || _this$_openTelemetry77 === void 0 || _this$_openTelemetry77.completeSpan({
                span: stopRecordingSpan,
                status: 1,
                message: "stopRecording() End"
              });
            case 6:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this, [[2, 4]]);
      }));
      function stopRecording() {
        return _stopRecording.apply(this, arguments);
      }
      return stopRecording;
    }()
  }, {
    key: "startLivestream",
    value: function () {
      var _startLivestream = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee18(outputs, config) {
        var _this$_openTelemetry78, _this$_openTelemetry80;
        var startLivestreamSpan, _this$_openTelemetry79, _this$_videosdkLogs21, _t12;
        return regenerator_default().wrap(function (_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              logger.debug("startLivestream()");
              startLivestreamSpan = (_this$_openTelemetry78 = this._openTelemetry) === null || _this$_openTelemetry78 === void 0 ? void 0 : _this$_openTelemetry78.trace({
                spanName: "startLivestream() Start",
                attributes: {
                  outputs: outputs ? JSON.stringify(outputs) : "outputs Not Specify",
                  config: config ? JSON.stringify(config) : "config Not Specify"
                }
              });
              _context18.prev = 1;
              _context18.next = 2;
              return this._socketRequest("startLivestream", {
                outputs: outputs,
                config: config
              });
            case 2:
              _context18.next = 4;
              break;
            case 3:
              _context18.prev = 3;
              _t12 = _context18["catch"](1);
              (_this$_openTelemetry79 = this._openTelemetry) === null || _this$_openTelemetry79 === void 0 || _this$_openTelemetry79.completeSpan({
                span: startLivestreamSpan,
                status: 1,
                message: "startLivestream() End"
              });
              (_this$_videosdkLogs21 = this._videosdkLogs) === null || _this$_videosdkLogs21 === void 0 || _this$_videosdkLogs21.pushLogs({
                logText: "Error startLivestream() failed",
                logType: "ERROR",
                attributes: {
                  error: _t12.message
                }
              });
              this._emitError({
                code: 4013,
                message: _t12.message
              });
            case 4:
              (_this$_openTelemetry80 = this._openTelemetry) === null || _this$_openTelemetry80 === void 0 || _this$_openTelemetry80.completeSpan({
                span: startLivestreamSpan,
                status: 1,
                message: "startLivestream() End"
              });
            case 5:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this, [[1, 3]]);
      }));
      function startLivestream(_x27, _x28) {
        return _startLivestream.apply(this, arguments);
      }
      return startLivestream;
    }()
  }, {
    key: "stopLivestream",
    value: function () {
      var _stopLivestream = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee19() {
        var _this$_openTelemetry81, _this$_openTelemetry83;
        var stopLivestreamSpan, _this$_videosdkLogs22, _this$_openTelemetry82, _t13;
        return regenerator_default().wrap(function (_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              logger.debug("stopLivestream()");
              stopLivestreamSpan = (_this$_openTelemetry81 = this._openTelemetry) === null || _this$_openTelemetry81 === void 0 ? void 0 : _this$_openTelemetry81.trace({
                spanName: "stopLivestream() Start"
              });
              _context19.prev = 1;
              _context19.next = 2;
              return this._socketRequest("stopLivestream", {});
            case 2:
              _context19.next = 4;
              break;
            case 3:
              _context19.prev = 3;
              _t13 = _context19["catch"](1);
              (_this$_videosdkLogs22 = this._videosdkLogs) === null || _this$_videosdkLogs22 === void 0 || _this$_videosdkLogs22.pushLogs({
                logText: "Error stopLivestream() failed",
                logType: "ERROR",
                attributes: {
                  error: _t13.message
                }
              });
              (_this$_openTelemetry82 = this._openTelemetry) === null || _this$_openTelemetry82 === void 0 || _this$_openTelemetry82.completeSpan({
                span: stopLivestreamSpan,
                status: 2,
                message: "Error stopLivestream() failed"
              });
              this._emitError({
                code: 4014,
                message: _t13.message
              });
            case 4:
              (_this$_openTelemetry83 = this._openTelemetry) === null || _this$_openTelemetry83 === void 0 || _this$_openTelemetry83.completeSpan({
                span: stopLivestreamSpan,
                status: 1,
                message: "stopLivestream() End"
              });
            case 5:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this, [[1, 3]]);
      }));
      function stopLivestream() {
        return _stopLivestream.apply(this, arguments);
      }
      return stopLivestream;
    }()
  }, {
    key: "startHls",
    value: function () {
      var _startHls = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee20(config, transcription) {
        var _this$_openTelemetry84, _this$_openTelemetry86;
        var startHlsSpan, _this$_videosdkLogs23, _this$_openTelemetry85, _t14;
        return regenerator_default().wrap(function (_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              //
              config = config || {}; //if config doesn't exist, create an empty object
              transcription = transcription || {}; //if transcription doesn't exist, create an empty object
              logger.debug("startHls()");
              startHlsSpan = (_this$_openTelemetry84 = this._openTelemetry) === null || _this$_openTelemetry84 === void 0 ? void 0 : _this$_openTelemetry84.trace({
                spanName: "startHls() Start",
                attributes: {
                  config: config ? JSON.stringify(config) : "config Not Specify",
                  transcription: transcription ? JSON.stringify(transcription) : "transcription Not Specify"
                }
              });
              _context20.prev = 1;
              _context20.next = 2;
              return this._socketRequest("startHls", {
                config: config,
                transcription: transcription
              });
            case 2:
              _context20.next = 4;
              break;
            case 3:
              _context20.prev = 3;
              _t14 = _context20["catch"](1);
              (_this$_videosdkLogs23 = this._videosdkLogs) === null || _this$_videosdkLogs23 === void 0 || _this$_videosdkLogs23.pushLogs({
                logText: "Error startHls() failed",
                logType: "ERROR",
                attributes: {
                  error: _t14.message
                }
              });
              (_this$_openTelemetry85 = this._openTelemetry) === null || _this$_openTelemetry85 === void 0 || _this$_openTelemetry85.completeSpan({
                span: startHlsSpan,
                status: 2,
                message: "Error startHls() failed"
              });
              this._emitError({
                code: 4016,
                message: _t14.message
              });
              logger.error("startHls() | failed:%o", _t14);
            case 4:
              (_this$_openTelemetry86 = this._openTelemetry) === null || _this$_openTelemetry86 === void 0 || _this$_openTelemetry86.completeSpan({
                span: startHlsSpan,
                status: 1,
                message: "startHlsSpan() End"
              });
            case 5:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this, [[1, 3]]);
      }));
      function startHls(_x29, _x30) {
        return _startHls.apply(this, arguments);
      }
      return startHls;
    }()
  }, {
    key: "stopHls",
    value: function () {
      var _stopHls = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee21() {
        var _this$_openTelemetry87, _this$_openTelemetry89;
        var stopHlsSpan, _this$_videosdkLogs24, _this$_openTelemetry88, _t15;
        return regenerator_default().wrap(function (_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              logger.debug("stopHls()");
              stopHlsSpan = (_this$_openTelemetry87 = this._openTelemetry) === null || _this$_openTelemetry87 === void 0 ? void 0 : _this$_openTelemetry87.trace({
                spanName: "stopHls() Start"
              });
              _context21.prev = 1;
              _context21.next = 2;
              return this._socketRequest("stopHls", {});
            case 2:
              _context21.next = 4;
              break;
            case 3:
              _context21.prev = 3;
              _t15 = _context21["catch"](1);
              (_this$_videosdkLogs24 = this._videosdkLogs) === null || _this$_videosdkLogs24 === void 0 || _this$_videosdkLogs24.pushLogs({
                logText: "Error stopHls() failed",
                logType: "ERROR",
                attributes: {
                  error: _t15.message
                }
              });
              (_this$_openTelemetry88 = this._openTelemetry) === null || _this$_openTelemetry88 === void 0 || _this$_openTelemetry88.completeSpan({
                span: stopHlsSpan,
                status: 2,
                message: "Error stopHls() failed"
              });
              this._emitError({
                code: 4017,
                message: _t15.message
              });
            case 4:
              (_this$_openTelemetry89 = this._openTelemetry) === null || _this$_openTelemetry89 === void 0 || _this$_openTelemetry89.completeSpan({
                span: stopHlsSpan,
                status: 1,
                message: "stopHls() End"
              });
            case 5:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this, [[1, 3]]);
      }));
      function stopHls() {
        return _stopHls.apply(this, arguments);
      }
      return stopHls;
    }()
  }, {
    key: "startWhiteboard",
    value: function () {
      var _startWhiteboard = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee22() {
        var _this$_openTelemetry90, _this$_openTelemetry92;
        var startWBSpan, _this$_openTelemetry91, _t16;
        return regenerator_default().wrap(function (_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              logger.debug("startWhiteboard()");
              startWBSpan = (_this$_openTelemetry90 = this._openTelemetry) === null || _this$_openTelemetry90 === void 0 ? void 0 : _this$_openTelemetry90.trace({
                spanName: "startWhiteboard() Start"
              });
              _context22.prev = 1;
              _context22.next = 2;
              return this._socketRequest("startWhiteboard", {
                version: "v2"
              });
            case 2:
              _context22.next = 4;
              break;
            case 3:
              _context22.prev = 3;
              _t16 = _context22["catch"](1);
              logger.error("startWhiteboard() | failed:%o", _t16);
              (_this$_openTelemetry91 = this._openTelemetry) === null || _this$_openTelemetry91 === void 0 || _this$_openTelemetry91.completeSpan({
                span: startWBSpan,
                status: 2,
                message: "Error startWhiteboard() failed"
              });
              this._emitError({
                code: 3021,
                message: _t16.message
              });
            case 4:
              (_this$_openTelemetry92 = this._openTelemetry) === null || _this$_openTelemetry92 === void 0 || _this$_openTelemetry92.completeSpan({
                span: startWBSpan,
                status: 1,
                message: "startWhiteboard() End"
              });
            case 5:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this, [[1, 3]]);
      }));
      function startWhiteboard() {
        return _startWhiteboard.apply(this, arguments);
      }
      return startWhiteboard;
    }()
  }, {
    key: "stopWhiteboard",
    value: function () {
      var _stopWhiteboard = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee23() {
        var _this$_openTelemetry93, _this$_openTelemetry95;
        var stopWBSpan, _this$_openTelemetry94, _t17;
        return regenerator_default().wrap(function (_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              logger.debug("stopWhiteboard()");
              stopWBSpan = (_this$_openTelemetry93 = this._openTelemetry) === null || _this$_openTelemetry93 === void 0 ? void 0 : _this$_openTelemetry93.trace({
                spanName: "stopWhiteboard() Start"
              });
              _context23.prev = 1;
              _context23.next = 2;
              return this._socketRequest("stopWhiteboard", {});
            case 2:
              _context23.next = 4;
              break;
            case 3:
              _context23.prev = 3;
              _t17 = _context23["catch"](1);
              logger.error("stopWhiteboard() | failed:%o", _t17);
              (_this$_openTelemetry94 = this._openTelemetry) === null || _this$_openTelemetry94 === void 0 || _this$_openTelemetry94.completeSpan({
                span: stopWBSpan,
                status: 2,
                message: "Error stopWhiteboard() failed"
              });
              this._emitError({
                code: 3022,
                message: _t17.message
              });
            case 4:
              (_this$_openTelemetry95 = this._openTelemetry) === null || _this$_openTelemetry95 === void 0 || _this$_openTelemetry95.completeSpan({
                span: stopWBSpan,
                status: 1,
                message: "stopWhiteboard() End"
              });
            case 5:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this, [[1, 3]]);
      }));
      function stopWhiteboard() {
        return _stopWhiteboard.apply(this, arguments);
      }
      return stopWhiteboard;
    }()
  }, {
    key: "joinCharacter",
    value: function () {
      var _joinCharacter = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee24(config) {
        var _this$_openTelemetry96, _this$_openTelemetry98;
        var joinCharacterSpan, _this$_openTelemetry97, _this$_videosdkLogs25, _t18;
        return regenerator_default().wrap(function (_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              logger.debug("joinCharacter()");
              joinCharacterSpan = (_this$_openTelemetry96 = this._openTelemetry) === null || _this$_openTelemetry96 === void 0 ? void 0 : _this$_openTelemetry96.trace({
                spanName: "joinCharacter() Start",
                attributes: {
                  config: config ? JSON.stringify(config) : "config Not Specify"
                }
              });
              _context24.prev = 1;
              _context24.next = 2;
              return this._socketRequest("joinCharacter", {
                config: config
              });
            case 2:
              return _context24.abrupt("return", _context24.sent);
            case 3:
              _context24.prev = 3;
              _t18 = _context24["catch"](1);
              logger.error("joinCharacter() | failed:%o", _t18);
              (_this$_openTelemetry97 = this._openTelemetry) === null || _this$_openTelemetry97 === void 0 || _this$_openTelemetry97.completeSpan({
                span: joinCharacterSpan,
                status: 2,
                message: "joinCharacter() failed"
              });
              (_this$_videosdkLogs25 = this._videosdkLogs) === null || _this$_videosdkLogs25 === void 0 || _this$_videosdkLogs25.pushLogs({
                logText: "Error joinCharacter() failed",
                logType: "ERROR",
                attributes: {
                  error: _t18.message
                }
              });
              this._emitError({
                code: 4033,
                message: _t18.message
              });
              (_this$_openTelemetry98 = this._openTelemetry) === null || _this$_openTelemetry98 === void 0 || _this$_openTelemetry98.completeSpan({
                span: joinCharacterSpan,
                status: 1,
                message: "joinCharacter() End"
              });
              return _context24.abrupt("return", false);
            case 4:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this, [[1, 3]]);
      }));
      function joinCharacter(_x31) {
        return _joinCharacter.apply(this, arguments);
      }
      return joinCharacter;
    }()
  }, {
    key: "switchTo",
    value: function () {
      var _switchTo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee25(_ref11) {
        var _this$_openTelemetry99;
        var meetingId, participantId, token, switchToSpan, _this$_openTelemetry100, _this$_openTelemetry101, _this$_videosdkLogs26, _t19;
        return regenerator_default().wrap(function (_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              meetingId = _ref11.meetingId, participantId = _ref11.participantId, token = _ref11.token;
              switchToSpan = (_this$_openTelemetry99 = this._openTelemetry) === null || _this$_openTelemetry99 === void 0 ? void 0 : _this$_openTelemetry99.trace({
                spanName: "switchTo() Start",
                attributes: {
                  "peer.id": participantId,
                  meetingId: meetingId
                }
              });
              _context25.prev = 1;
              _context25.next = 2;
              return this._socketRequest("switchToMeeting", {
                meetingId: meetingId,
                participantId: participantId,
                secret: token || this._secret
              });
            case 2:
              (_this$_openTelemetry100 = this._openTelemetry) === null || _this$_openTelemetry100 === void 0 || _this$_openTelemetry100.completeSpan({
                span: switchToSpan,
                status: 1,
                message: "switchTo() Success"
              });
              _context25.next = 4;
              break;
            case 3:
              _context25.prev = 3;
              _t19 = _context25["catch"](1);
              (_this$_openTelemetry101 = this._openTelemetry) === null || _this$_openTelemetry101 === void 0 || _this$_openTelemetry101.completeSpan({
                span: switchToSpan,
                status: 2,
                message: "switchTo() failed"
              });
              (_this$_videosdkLogs26 = this._videosdkLogs) === null || _this$_videosdkLogs26 === void 0 || _this$_videosdkLogs26.pushLogs({
                logText: "Error switchTo() failed",
                logType: "ERROR",
                attributes: {
                  error: _t19.message
                }
              });
            case 4:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this, [[1, 3]]);
      }));
      function switchTo(_x32) {
        return _switchTo.apply(this, arguments);
      }
      return switchTo;
    }()
  }, {
    key: "removeCharacter",
    value: function () {
      var _removeCharacter = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee26(config) {
        var _this$_openTelemetry102, _this$_openTelemetry104;
        var removeCharacterSpan, _this$_openTelemetry103, _this$_videosdkLogs27, _t20;
        return regenerator_default().wrap(function (_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              logger.debug("removeCharacter()");
              removeCharacterSpan = (_this$_openTelemetry102 = this._openTelemetry) === null || _this$_openTelemetry102 === void 0 ? void 0 : _this$_openTelemetry102.trace({
                spanName: "removeCharacter() Start"
              });
              _context26.prev = 1;
              _context26.next = 2;
              return this._socketRequest("leaveCharacter", {
                config: config
              });
            case 2:
              _context26.next = 4;
              break;
            case 3:
              _context26.prev = 3;
              _t20 = _context26["catch"](1);
              logger.error("removeCharacter() | failed:%o", _t20);
              (_this$_openTelemetry103 = this._openTelemetry) === null || _this$_openTelemetry103 === void 0 || _this$_openTelemetry103.completeSpan({
                span: removeCharacterSpan,
                status: 2,
                message: "removeCharacter() failed"
              });
              (_this$_videosdkLogs27 = this._videosdkLogs) === null || _this$_videosdkLogs27 === void 0 || _this$_videosdkLogs27.pushLogs({
                logText: "Error removeCharacter() failed",
                logType: "ERROR",
                attributes: {
                  error: _t20.message
                }
              });
              this._emitError({
                code: 4034,
                message: _t20.message
              });
              return _context26.abrupt("return", false);
            case 4:
              (_this$_openTelemetry104 = this._openTelemetry) === null || _this$_openTelemetry104 === void 0 || _this$_openTelemetry104.completeSpan({
                span: removeCharacterSpan,
                status: 1,
                message: "removeCharacter() End"
              });
              return _context26.abrupt("return", true);
            case 5:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this, [[1, 3]]);
      }));
      function removeCharacter(_x33) {
        return _removeCharacter.apply(this, arguments);
      }
      return removeCharacter;
    }()
  }, {
    key: "sendCharacterMessage",
    value: function () {
      var _sendCharacterMessage = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee27(_ref12) {
        var interactionId, text, _t21;
        return regenerator_default().wrap(function (_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              interactionId = _ref12.interactionId, text = _ref12.text;
              logger.debug("sendCharacterMessage()");
              _context27.prev = 1;
              _context27.next = 2;
              return this._socketRequest("sendCharacterMessage", {
                interactionId: interactionId,
                text: text
              });
            case 2:
              _context27.next = 4;
              break;
            case 3:
              _context27.prev = 3;
              _t21 = _context27["catch"](1);
              logger.error("sendCharacterMessage() | failed:%o", _t21);
              this._emitError({
                code: 4035,
                message: _t21.message
              });
            case 4:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this, [[1, 3]]);
      }));
      function sendCharacterMessage(_x34) {
        return _sendCharacterMessage.apply(this, arguments);
      }
      return sendCharacterMessage;
    }()
  }, {
    key: "interruptCharacter",
    value: function () {
      var _interruptCharacter = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee28(_ref13) {
        var interactionId, _t22;
        return regenerator_default().wrap(function (_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              interactionId = _ref13.interactionId;
              logger.debug("interruptCharacter()");
              _context28.prev = 1;
              _context28.next = 2;
              return this._socketRequest("interruptCharacter", {
                interactionId: interactionId
              });
            case 2:
              _context28.next = 4;
              break;
            case 3:
              _context28.prev = 3;
              _t22 = _context28["catch"](1);
              logger.error("interruptCharacter() | failed:%o", _t22);
              this._emitError({
                code: 4036,
                message: _t22.message
              });
            case 4:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this, [[1, 3]]);
      }));
      function interruptCharacter(_x35) {
        return _interruptCharacter.apply(this, arguments);
      }
      return interruptCharacter;
    }()
  }, {
    key: "pinStateChange",
    value: function () {
      var _pinStateChange = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee29(_ref14) {
        var _this$_openTelemetry105;
        var peerId, state, _this$_videosdkLogs28, _t23;
        return regenerator_default().wrap(function (_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              peerId = _ref14.peerId, state = _ref14.state;
              (_this$_openTelemetry105 = this._openTelemetry) === null || _this$_openTelemetry105 === void 0 || _this$_openTelemetry105.traceAutoComplete({
                spanName: "Pin state Change for ".concat(peerId),
                attributes: {
                  state: state ? JSON.stringify(state) : null
                },
                status: 1
              });
              _context29.prev = 1;
              _context29.next = 2;
              return this._socketRequest("pinStateChanged", {
                peerId: peerId,
                state: state
              });
            case 2:
              _context29.next = 4;
              break;
            case 3:
              _context29.prev = 3;
              _t23 = _context29["catch"](1);
              (_this$_videosdkLogs28 = this._videosdkLogs) === null || _this$_videosdkLogs28 === void 0 || _this$_videosdkLogs28.pushLogs({
                logText: "Error pinStateChange() failed",
                logType: "ERROR",
                attributes: {
                  error: _t23.message
                }
              });
              logger.error("pinStateChange() | failed");
            case 4:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this, [[1, 3]]);
      }));
      function pinStateChange(_x36) {
        return _pinStateChange.apply(this, arguments);
      }
      return pinStateChange;
    }()
  }, {
    key: "startVideo",
    value: function () {
      var _startVideo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee30(_ref15) {
        var _this$_videosdkLogs29;
        var link, _this$_videosdkLogs30, _t24;
        return regenerator_default().wrap(function (_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              link = _ref15.link;
              logger.debug("startVideo()");
              (_this$_videosdkLogs29 = this._videosdkLogs) === null || _this$_videosdkLogs29 === void 0 || _this$_videosdkLogs29.pushLogs({
                logText: "startVideo() Calling",
                logType: "INFO"
              });
              _context30.prev = 1;
              _context30.next = 2;
              return this._socketRequest("startVideo", {
                link: link
              });
            case 2:
              _context30.next = 4;
              break;
            case 3:
              _context30.prev = 3;
              _t24 = _context30["catch"](1);
              (_this$_videosdkLogs30 = this._videosdkLogs) === null || _this$_videosdkLogs30 === void 0 || _this$_videosdkLogs30.pushLogs({
                logText: "Error startVideo() failed",
                logType: "ERROR",
                attributes: {
                  error: _t24.message
                }
              });
              logger.error("startVideo() | failed:%o", _t24);
              this._emitError({
                code: 3023,
                message: _t24.message
              });
            case 4:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this, [[1, 3]]);
      }));
      function startVideo(_x37) {
        return _startVideo.apply(this, arguments);
      }
      return startVideo;
    }()
  }, {
    key: "stopVideo",
    value: function () {
      var _stopVideo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee31() {
        var _this$_videosdkLogs31;
        var _this$_videosdkLogs32, _t25;
        return regenerator_default().wrap(function (_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              logger.debug("stopVideo()");
              (_this$_videosdkLogs31 = this._videosdkLogs) === null || _this$_videosdkLogs31 === void 0 || _this$_videosdkLogs31.pushLogs({
                logText: "stopVideo() Calling",
                logType: "INFO"
              });
              _context31.prev = 1;
              _context31.next = 2;
              return this._socketRequest("stopVideo", {});
            case 2:
              _context31.next = 4;
              break;
            case 3:
              _context31.prev = 3;
              _t25 = _context31["catch"](1);
              (_this$_videosdkLogs32 = this._videosdkLogs) === null || _this$_videosdkLogs32 === void 0 || _this$_videosdkLogs32.pushLogs({
                logText: "Error stopVideo() failed",
                logType: "ERROR",
                attributes: {
                  error: _t25.message
                }
              });
              logger.error("stopVideo() | failed:%o", _t25);
              this._emitError({
                code: 3024,
                message: _t25.message
              });
            case 4:
            case "end":
              return _context31.stop();
          }
        }, _callee31, this, [[1, 3]]);
      }));
      function stopVideo() {
        return _stopVideo.apply(this, arguments);
      }
      return stopVideo;
    }()
  }, {
    key: "pauseVideo",
    value: function () {
      var _pauseVideo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee32(currentTime) {
        var _t26;
        return regenerator_default().wrap(function (_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              logger.debug("pauseVideo()");
              _context32.prev = 1;
              _context32.next = 2;
              return this._socketRequest("pauseVideo", {
                currentTime: currentTime
              });
            case 2:
              _context32.next = 4;
              break;
            case 3:
              _context32.prev = 3;
              _t26 = _context32["catch"](1);
              logger.error("pauseVideo() | failed:%o", _t26);
              this._emitError({
                code: 3025,
                message: _t26.message
              });
            case 4:
            case "end":
              return _context32.stop();
          }
        }, _callee32, this, [[1, 3]]);
      }));
      function pauseVideo(_x38) {
        return _pauseVideo.apply(this, arguments);
      }
      return pauseVideo;
    }()
  }, {
    key: "resumeVideo",
    value: function () {
      var _resumeVideo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee33() {
        var _t27;
        return regenerator_default().wrap(function (_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              logger.debug("resumeVideo()");
              _context33.prev = 1;
              _context33.next = 2;
              return this._socketRequest("resumeVideo", {});
            case 2:
              _context33.next = 4;
              break;
            case 3:
              _context33.prev = 3;
              _t27 = _context33["catch"](1);
              logger.error("resumeVideo() | failed:%o", _t27);
              this._emitError({
                code: 3026,
                message: _t27.message
              });
            case 4:
            case "end":
              return _context33.stop();
          }
        }, _callee33, this, [[1, 3]]);
      }));
      function resumeVideo() {
        return _resumeVideo.apply(this, arguments);
      }
      return resumeVideo;
    }()
  }, {
    key: "seekVideo",
    value: function () {
      var _seekVideo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee34(currentTime) {
        var _t28;
        return regenerator_default().wrap(function (_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              logger.debug("seekVideo()");
              _context34.prev = 1;
              _context34.next = 2;
              return this._socketRequest("seekVideo", {
                currentTime: currentTime
              });
            case 2:
              _context34.next = 4;
              break;
            case 3:
              _context34.prev = 3;
              _t28 = _context34["catch"](1);
              logger.error("seekVideo() | failed:%o", _t28);
              this._emitError({
                code: 3031,
                message: _t28.message
              });
            case 4:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this, [[1, 3]]);
      }));
      function seekVideo(_x39) {
        return _seekVideo.apply(this, arguments);
      }
      return seekVideo;
    }()
  }, {
    key: "enablePeerMic",
    value: function () {
      var _enablePeerMic = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee35(peerId) {
        var _this$_openTelemetry106;
        var _this$_videosdkLogs33, _t29;
        return regenerator_default().wrap(function (_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              (_this$_openTelemetry106 = this._openTelemetry) === null || _this$_openTelemetry106 === void 0 || _this$_openTelemetry106.traceAutoComplete({
                spanName: "Enabling peer ".concat(peerId, " Mic"),
                status: 1
              });
              logger.debug("enablePeerMic()");
              _context35.prev = 1;
              _context35.next = 2;
              return this._socketRequest("enablePeerMic", {
                peerId: peerId
              });
            case 2:
              _context35.next = 4;
              break;
            case 3:
              _context35.prev = 3;
              _t29 = _context35["catch"](1);
              (_this$_videosdkLogs33 = this._videosdkLogs) === null || _this$_videosdkLogs33 === void 0 || _this$_videosdkLogs33.pushLogs({
                logText: "Error enablePeerMic() failed",
                logType: "ERROR",
                attributes: {
                  error: _t29.message
                }
              });
              logger.error("enablePeerMic() | failed:%o", _t29);
            case 4:
            case "end":
              return _context35.stop();
          }
        }, _callee35, this, [[1, 3]]);
      }));
      function enablePeerMic(_x40) {
        return _enablePeerMic.apply(this, arguments);
      }
      return enablePeerMic;
    }()
  }, {
    key: "requestMediaRelay",
    value: function () {
      var _requestMediaRelay = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee36(meetingId, token, kinds) {
        var _this$_videosdkLogs34, _t30;
        return regenerator_default().wrap(function (_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              _context36.prev = 0;
              _context36.next = 1;
              return this._socketRequest("mediaRelayRequestSent", {
                meetingId: meetingId,
                secret: token !== null && token !== void 0 ? token : this._secret,
                kinds: kinds !== null && kinds !== void 0 ? kinds : ["audio", "video", "share", "share_audio"]
              });
            case 1:
              _context36.next = 3;
              break;
            case 2:
              _context36.prev = 2;
              _t30 = _context36["catch"](0);
              (_this$_videosdkLogs34 = this._videosdkLogs) === null || _this$_videosdkLogs34 === void 0 || _this$_videosdkLogs34.pushLogs({
                logText: "Error relayRequest() failed",
                logType: "ERROR",
                attributes: {
                  error: _t30.message
                }
              });
            case 3:
            case "end":
              return _context36.stop();
          }
        }, _callee36, this, [[0, 2]]);
      }));
      function requestMediaRelay(_x41, _x42, _x43) {
        return _requestMediaRelay.apply(this, arguments);
      }
      return requestMediaRelay;
    }()
  }, {
    key: "handleRelayRequestResponse",
    value: function () {
      var _handleRelayRequestResponse = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee37(_ref16) {
        var decision, peerId, meetingId, _this$_videosdkLogs35, _t31;
        return regenerator_default().wrap(function (_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              decision = _ref16.decision, peerId = _ref16.peerId, meetingId = _ref16.meetingId;
              _context37.prev = 1;
              _context37.next = 2;
              return this._socketRequest("respondToMediaRelayRequest", {
                decision: decision,
                decidedBy: this._peerId,
                peerId: peerId,
                meetingId: meetingId
              });
            case 2:
              _context37.next = 4;
              break;
            case 3:
              _context37.prev = 3;
              _t31 = _context37["catch"](1);
              (_this$_videosdkLogs35 = this._videosdkLogs) === null || _this$_videosdkLogs35 === void 0 || _this$_videosdkLogs35.pushLogs({
                logText: "Error respondToMediaRelayRequest() failed",
                logType: "ERROR",
                attributes: {
                  error: _t31.message
                }
              });
            case 4:
            case "end":
              return _context37.stop();
          }
        }, _callee37, this, [[1, 3]]);
      }));
      function handleRelayRequestResponse(_x44) {
        return _handleRelayRequestResponse.apply(this, arguments);
      }
      return handleRelayRequestResponse;
    }()
  }, {
    key: "stopMediaRelay",
    value: function () {
      var _stopMediaRelay = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee38(meetingId) {
        var _this$_videosdkLogs36, _t32;
        return regenerator_default().wrap(function (_context38) {
          while (1) switch (_context38.prev = _context38.next) {
            case 0:
              _context38.prev = 0;
              _context38.next = 1;
              return this._socketRequest("mediaRelayRequestStop", {
                meetingId: meetingId
              });
            case 1:
              _context38.next = 3;
              break;
            case 2:
              _context38.prev = 2;
              _t32 = _context38["catch"](0);
              (_this$_videosdkLogs36 = this._videosdkLogs) === null || _this$_videosdkLogs36 === void 0 || _this$_videosdkLogs36.pushLogs({
                logText: "Error stopMediaRelay() failed",
                logType: "ERROR",
                attributes: {
                  error: _t32.message
                }
              });
            case 3:
            case "end":
              return _context38.stop();
          }
        }, _callee38, this, [[0, 2]]);
      }));
      function stopMediaRelay(_x45) {
        return _stopMediaRelay.apply(this, arguments);
      }
      return stopMediaRelay;
    }()
  }, {
    key: "enableRelayMedia",
    value: function () {
      var _enableRelayMedia = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee39(meetingId, kind) {
        var _this$_videosdkLogs37, _t33;
        return regenerator_default().wrap(function (_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              _context39.prev = 0;
              _context39.next = 1;
              return this._socketRequest("enableRelayMedia", {
                meetingId: meetingId,
                kind: kind
              });
            case 1:
              _context39.next = 3;
              break;
            case 2:
              _context39.prev = 2;
              _t33 = _context39["catch"](0);
              (_this$_videosdkLogs37 = this._videosdkLogs) === null || _this$_videosdkLogs37 === void 0 || _this$_videosdkLogs37.pushLogs({
                logText: "Error enableRelayMedia() failed",
                logType: "ERROR",
                attributes: {
                  error: _t33.message
                }
              });
            case 3:
            case "end":
              return _context39.stop();
          }
        }, _callee39, this, [[0, 2]]);
      }));
      function enableRelayMedia(_x46, _x47) {
        return _enableRelayMedia.apply(this, arguments);
      }
      return enableRelayMedia;
    }()
  }, {
    key: "disableRelayMedia",
    value: function () {
      var _disableRelayMedia = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee40(meetingId, kind) {
        var _this$_videosdkLogs38, _t34;
        return regenerator_default().wrap(function (_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              _context40.prev = 0;
              _context40.next = 1;
              return this._socketRequest("disableRelayMedia", {
                meetingId: meetingId,
                kind: kind
              });
            case 1:
              _context40.next = 3;
              break;
            case 2:
              _context40.prev = 2;
              _t34 = _context40["catch"](0);
              (_this$_videosdkLogs38 = this._videosdkLogs) === null || _this$_videosdkLogs38 === void 0 || _this$_videosdkLogs38.pushLogs({
                logText: "Error disableRelayMedia() failed",
                logType: "ERROR",
                attributes: {
                  error: _t34.message
                }
              });
            case 3:
            case "end":
              return _context40.stop();
          }
        }, _callee40, this, [[0, 2]]);
      }));
      function disableRelayMedia(_x48, _x49) {
        return _disableRelayMedia.apply(this, arguments);
      }
      return disableRelayMedia;
    }()
  }, {
    key: "enableAdaptiveSubscription",
    value: function () {
      var _enableAdaptiveSubscription = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee41() {
        var _this$_videosdkLogs39, _t35;
        return regenerator_default().wrap(function (_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              _context41.prev = 0;
              _context41.next = 1;
              return this._socketRequest("enableAdaptiveSubscription");
            case 1:
              _context41.next = 3;
              break;
            case 2:
              _context41.prev = 2;
              _t35 = _context41["catch"](0);
              (_this$_videosdkLogs39 = this._videosdkLogs) === null || _this$_videosdkLogs39 === void 0 || _this$_videosdkLogs39.pushLogs({
                logText: "Error enableAdaptiveSubscription() failed",
                logType: "ERROR",
                attributes: {
                  error: _t35.message
                }
              });
            case 3:
            case "end":
              return _context41.stop();
          }
        }, _callee41, this, [[0, 2]]);
      }));
      function enableAdaptiveSubscription() {
        return _enableAdaptiveSubscription.apply(this, arguments);
      }
      return enableAdaptiveSubscription;
    }()
  }, {
    key: "disableAdaptiveSubscription",
    value: function () {
      var _disableAdaptiveSubscription = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee42() {
        var _this$_videosdkLogs40, _t36;
        return regenerator_default().wrap(function (_context42) {
          while (1) switch (_context42.prev = _context42.next) {
            case 0:
              _context42.prev = 0;
              _context42.next = 1;
              return this._socketRequest("disableAdaptiveSubscription");
            case 1:
              _context42.next = 3;
              break;
            case 2:
              _context42.prev = 2;
              _t36 = _context42["catch"](0);
              (_this$_videosdkLogs40 = this._videosdkLogs) === null || _this$_videosdkLogs40 === void 0 || _this$_videosdkLogs40.pushLogs({
                logText: "Error disableAdaptiveSubscription() failed",
                logType: "ERROR",
                attributes: {
                  error: _t36.message
                }
              });
            case 3:
            case "end":
              return _context42.stop();
          }
        }, _callee42, this, [[0, 2]]);
      }));
      function disableAdaptiveSubscription() {
        return _disableAdaptiveSubscription.apply(this, arguments);
      }
      return disableAdaptiveSubscription;
    }()
  }, {
    key: "disablePeerMic",
    value: function () {
      var _disablePeerMic = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee43(peerId) {
        var _this$_openTelemetry107;
        var _this$_videosdkLogs41, _t37;
        return regenerator_default().wrap(function (_context43) {
          while (1) switch (_context43.prev = _context43.next) {
            case 0:
              (_this$_openTelemetry107 = this._openTelemetry) === null || _this$_openTelemetry107 === void 0 || _this$_openTelemetry107.traceAutoComplete({
                spanName: "Disabling peer ".concat(peerId, " Mic"),
                status: 1
              });
              logger.debug("disablePeerMic()");
              _context43.prev = 1;
              _context43.next = 2;
              return this._socketRequest("disablePeerMic", {
                peerId: peerId
              });
            case 2:
              _context43.next = 4;
              break;
            case 3:
              _context43.prev = 3;
              _t37 = _context43["catch"](1);
              (_this$_videosdkLogs41 = this._videosdkLogs) === null || _this$_videosdkLogs41 === void 0 || _this$_videosdkLogs41.pushLogs({
                logText: "Error disablePeerMic() failed",
                logType: "ERROR",
                attributes: {
                  error: _t37.message
                }
              });
              logger.error("disablePeerMic() | failed:%o", _t37);
            case 4:
            case "end":
              return _context43.stop();
          }
        }, _callee43, this, [[1, 3]]);
      }));
      function disablePeerMic(_x50) {
        return _disablePeerMic.apply(this, arguments);
      }
      return disablePeerMic;
    }()
  }, {
    key: "consumeWebcamStreams",
    value: function () {
      var _consumeWebcamStreams = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee44(peerId) {
        var _this$_videosdkLogs42;
        var _this$_videosdkLogs43, _t38;
        return regenerator_default().wrap(function (_context44) {
          while (1) switch (_context44.prev = _context44.next) {
            case 0:
              if (!this._closed) {
                _context44.next = 1;
                break;
              }
              return _context44.abrupt("return");
            case 1:
              logger.debug("consumeWebcamStreams()");
              (_this$_videosdkLogs42 = this._videosdkLogs) === null || _this$_videosdkLogs42 === void 0 || _this$_videosdkLogs42.pushLogs({
                logText: "consumeWebcamStreams() Calling",
                logType: "INFO",
                attributes: {
                  peerId: peerId
                }
              });
              _context44.prev = 2;
              _context44.next = 3;
              return this._socketRequest("consumeVideoStreams", {
                peerId: peerId
              });
            case 3:
              _context44.next = 5;
              break;
            case 4:
              _context44.prev = 4;
              _t38 = _context44["catch"](2);
              (_this$_videosdkLogs43 = this._videosdkLogs) === null || _this$_videosdkLogs43 === void 0 || _this$_videosdkLogs43.pushLogs({
                logText: "Error consumeWebcamStreams() failed",
                logType: "ERROR",
                attributes: {
                  error: _t38.message
                }
              });
              logger.error("consumeWebcamStreams() | failed:%o", _t38);
            case 5:
            case "end":
              return _context44.stop();
          }
        }, _callee44, this, [[2, 4]]);
      }));
      function consumeWebcamStreams(_x51) {
        return _consumeWebcamStreams.apply(this, arguments);
      }
      return consumeWebcamStreams;
    }()
  }, {
    key: "consumeMicStreams",
    value: function () {
      var _consumeMicStreams = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee45(peerId) {
        var _this$_videosdkLogs44;
        var _this$_videosdkLogs45, _t39;
        return regenerator_default().wrap(function (_context45) {
          while (1) switch (_context45.prev = _context45.next) {
            case 0:
              logger.debug("consumeMicStreams()");
              (_this$_videosdkLogs44 = this._videosdkLogs) === null || _this$_videosdkLogs44 === void 0 || _this$_videosdkLogs44.pushLogs({
                logText: "consumeMicStreams() Calling",
                logType: "INFO",
                attributes: {
                  peerId: peerId
                }
              });
              _context45.prev = 1;
              _context45.next = 2;
              return this._socketRequest("consumeAudioStreams", {
                peerId: peerId
              });
            case 2:
              _context45.next = 4;
              break;
            case 3:
              _context45.prev = 3;
              _t39 = _context45["catch"](1);
              (_this$_videosdkLogs45 = this._videosdkLogs) === null || _this$_videosdkLogs45 === void 0 || _this$_videosdkLogs45.pushLogs({
                logText: "Error consumeMicStreams() failed",
                logType: "ERROR",
                attributes: {
                  error: _t39.message
                }
              });
              logger.error("consumeMicStreams() | failed:%o", _t39);
            case 4:
            case "end":
              return _context45.stop();
          }
        }, _callee45, this, [[1, 3]]);
      }));
      function consumeMicStreams(_x52) {
        return _consumeMicStreams.apply(this, arguments);
      }
      return consumeMicStreams;
    }()
  }, {
    key: "stopConsumingMicStreams",
    value: function () {
      var _stopConsumingMicStreams = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee46(peerId) {
        var _this$_videosdkLogs46, _this$_videosdkLogs47, _t40;
        return regenerator_default().wrap(function (_context46) {
          while (1) switch (_context46.prev = _context46.next) {
            case 0:
              if (!this._closed) {
                _context46.next = 1;
                break;
              }
              return _context46.abrupt("return");
            case 1:
              logger.debug("stopConsumingAudioStreams()");
              _context46.prev = 2;
              _context46.next = 3;
              return this._socketRequest("stopConsumingAudioStreams", {
                peerId: peerId
              });
            case 3:
              (_this$_videosdkLogs46 = this._videosdkLogs) === null || _this$_videosdkLogs46 === void 0 || _this$_videosdkLogs46.pushLogs({
                logText: "stopConsumingAudioStreams() Calling",
                logType: "INFO",
                attributes: {
                  peerId: peerId
                }
              });
              _context46.next = 5;
              break;
            case 4:
              _context46.prev = 4;
              _t40 = _context46["catch"](2);
              (_this$_videosdkLogs47 = this._videosdkLogs) === null || _this$_videosdkLogs47 === void 0 || _this$_videosdkLogs47.pushLogs({
                logText: "Error stopConsumingMicStreams() failed",
                logType: "ERROR",
                attributes: {
                  error: _t40.message
                }
              });
              logger.error("stopConsumingMicStreams() | failed:%o", _t40);
            case 5:
            case "end":
              return _context46.stop();
          }
        }, _callee46, this, [[2, 4]]);
      }));
      function stopConsumingMicStreams(_x53) {
        return _stopConsumingMicStreams.apply(this, arguments);
      }
      return stopConsumingMicStreams;
    }()
  }, {
    key: "stopConsumingWebcamStreams",
    value: function () {
      var _stopConsumingWebcamStreams = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee47(peerId) {
        var _this$_videosdkLogs48;
        var _this$_videosdkLogs49, _t41;
        return regenerator_default().wrap(function (_context47) {
          while (1) switch (_context47.prev = _context47.next) {
            case 0:
              logger.debug("stopConsumingWebcamStreams()");
              (_this$_videosdkLogs48 = this._videosdkLogs) === null || _this$_videosdkLogs48 === void 0 || _this$_videosdkLogs48.pushLogs({
                logText: "stopConsumingWebcamStreams() Calling",
                logType: "INFO",
                attributes: {
                  peerId: peerId
                }
              });
              _context47.prev = 1;
              _context47.next = 2;
              return this._socketRequest("stopConsumingVideoStreams", {
                peerId: peerId
              });
            case 2:
              _context47.next = 4;
              break;
            case 3:
              _context47.prev = 3;
              _t41 = _context47["catch"](1);
              (_this$_videosdkLogs49 = this._videosdkLogs) === null || _this$_videosdkLogs49 === void 0 || _this$_videosdkLogs49.pushLogs({
                logText: "Error stopConsumingWebcamStreams() failed",
                logType: "ERROR",
                attributes: {
                  error: _t41.message
                }
              });
              logger.error("stopConsumingWebcamStreams() | failed:%o", _t41);
            case 4:
            case "end":
              return _context47.stop();
          }
        }, _callee47, this, [[1, 3]]);
      }));
      function stopConsumingWebcamStreams(_x54) {
        return _stopConsumingWebcamStreams.apply(this, arguments);
      }
      return stopConsumingWebcamStreams;
    }()
  }, {
    key: "changeMode",
    value: function () {
      var _changeMode = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee49(requestedMode) {
        var _this$_openTelemetry108,
          _this2 = this;
        var changeModeSpan, currentMode, _this$_openTelemetry109, _this$_videosdkLogs50, createTransport, _this$_openTelemetry110, routerRtpCapabilities, _routerRtpCapabilitie, transportInfo, _transportInfo, _store$getState2, me, _store$getState3, _me, _this$_videosdkLogs51, _this$_openTelemetry111, _t42;
        return regenerator_default().wrap(function (_context49) {
          while (1) switch (_context49.prev = _context49.next) {
            case 0:
              changeModeSpan = (_this$_openTelemetry108 = this._openTelemetry) === null || _this$_openTelemetry108 === void 0 ? void 0 : _this$_openTelemetry108.trace({
                spanName: "changeMode() Calling with mode: ".concat(requestedMode)
              });
              currentMode = this._mode;
              _context49.prev = 1;
              if (!(currentMode === requestedMode)) {
                _context49.next = 2;
                break;
              }
              (_this$_openTelemetry109 = this._openTelemetry) === null || _this$_openTelemetry109 === void 0 || _this$_openTelemetry109.completeSpan({
                span: changeModeSpan,
                status: 2,
                message: "changeMode() Ending"
              });
              (_this$_videosdkLogs50 = this._videosdkLogs) === null || _this$_videosdkLogs50 === void 0 || _this$_videosdkLogs50.pushLogs({
                logText: "You are already in ".concat(requestedMode, " mode"),
                logType: "INFO"
              });
              throw new Error("You are already in ".concat(requestedMode, " mode"));
            case 2:
              // Helper function to handle transport creation
              createTransport = /*#__PURE__*/function () {
                var _ref17 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee48(producing, consuming) {
                  return regenerator_default().wrap(function (_context48) {
                    while (1) switch (_context48.prev = _context48.next) {
                      case 0:
                        _context48.next = 1;
                        return _this2._socketRequest("createWebRtcTransport", {
                          preferredProtocol: _this2._preferredProtocol,
                          producing: producing,
                          consuming: consuming,
                          sctpCapabilities: _this2._mediasoupDevice.sctpCapabilities
                        });
                      case 1:
                        return _context48.abrupt("return", _context48.sent);
                      case 2:
                      case "end":
                        return _context48.stop();
                    }
                  }, _callee48);
                }));
                return function createTransport(_x56, _x57) {
                  return _ref17.apply(this, arguments);
                };
              }();
              if (!(0,modes/* isSendRecvMode */.kR)(requestedMode)) {
                _context49.next = 10;
                break;
              }
              this._consume = true;
              this._produce = true;
              this._mode = requestedMode;
              this._mediasoupDevice = new lib/* Device */.pF({
                handlerName: this._handlerName
              });
              _context49.next = 3;
              return this._socketRequest("getRouterRtpCapabilities");
            case 3:
              routerRtpCapabilities = _context49.sent;
              // Filter out video-orientation for Firefox
              if (this._deviceInfo.sdkType !== "react-native" && navigator.userAgent.includes("Firefox")) {
                routerRtpCapabilities.headerExtensions = (_routerRtpCapabilitie = routerRtpCapabilities.headerExtensions) === null || _routerRtpCapabilitie === void 0 ? void 0 : _routerRtpCapabilitie.filter(function (c) {
                  return c.uri != "urn:3gpp:video-orientation";
                });
              }
              _context49.next = 4;
              return this._mediasoupDevice.load({
                routerRtpCapabilities: routerRtpCapabilities
              });
            case 4:
              if (!this._produce) {
                _context49.next = 6;
                break;
              }
              _context49.next = 5;
              return createTransport(true, false);
            case 5:
              transportInfo = _context49.sent;
              this.createProducerTransport(transportInfo, changeModeSpan);
            case 6:
              if (!(currentMode !== modes/* modes */.nI.RECV_ONLY && this._consume)) {
                _context49.next = 8;
                break;
              }
              _context49.next = 7;
              return createTransport(false, true);
            case 7:
              _transportInfo = _context49.sent;
              this.createConsumerTransport(_transportInfo, changeModeSpan);
            case 8:
              (_this$_openTelemetry110 = this._openTelemetry) === null || _this$_openTelemetry110 === void 0 || _this$_openTelemetry110.traceAutoComplete({
                spanName: "Sending changeMode request to server",
                span: changeModeSpan,
                status: 1
              });
              _context49.next = 9;
              return this._socketRequest("changeMode", {
                mode: requestedMode
              });
            case 9:
              if (this._produce) {
                store.dispatch(setMediaCapabilities({
                  canSendMic: this._mediasoupDevice.canProduce("audio"),
                  canSendWebcam: this._mediasoupDevice.canProduce("video")
                }));
                if (this._micEnabled) {
                  this.enableMic(this.customMicrophoneAudioTrack);
                }
                if (this._webcamEnabled) {
                  this.enableWebcam(this.customCameraVideoTrack, changeModeSpan);
                }
                this.enableChatDataProducer();
              }
              if (window.SHOW_INFO) {
                _store$getState2 = store.getState(), me = _store$getState2.me;
                store.dispatch(setRoomStatsPeerId(me.id));
              }
              _context49.next = 17;
              break;
            case 10:
              if (!((0,modes/* isSendRecvMode */.kR)(currentMode) && requestedMode === modes/* modes */.nI.RECV_ONLY)) {
                _context49.next = 12;
                break;
              }
              this._produce = false;
              this._mode = requestedMode;
              this._closeProducersAndTransport();
              _context49.next = 11;
              return this._socketRequest("changeMode", {
                mode: requestedMode
              });
            case 11:
              _context49.next = 17;
              break;
            case 12:
              if (!((0,modes/* isViewerMode */.wZ)(currentMode) && requestedMode === modes/* modes */.nI.RECV_ONLY)) {
                _context49.next = 15;
                break;
              }
              this._consume = true;
              this._mode = requestedMode;
              _context49.next = 13;
              return this._setupWebrtcTransport(changeModeSpan);
            case 13:
              _context49.next = 14;
              return this._socketRequest("changeMode", {
                mode: requestedMode
              });
            case 14:
              if (window.SHOW_INFO) {
                _store$getState3 = store.getState(), _me = _store$getState3.me;
                store.dispatch(setRoomStatsPeerId(_me.id));
              }
              _context49.next = 17;
              break;
            case 15:
              if (!(0,modes/* isViewerMode */.wZ)(requestedMode)) {
                _context49.next = 17;
                break;
              }
              _context49.next = 16;
              return this._socketRequest("changeMode", {
                mode: requestedMode
              });
            case 16:
              this._consume = false;
              this._produce = false;
              this._mode = requestedMode;
              this._dataConsumers.clear();
              this._closeTransports();
            case 17:
              _context49.next = 19;
              break;
            case 18:
              _context49.prev = 18;
              _t42 = _context49["catch"](1);
              (_this$_videosdkLogs51 = this._videosdkLogs) === null || _this$_videosdkLogs51 === void 0 || _this$_videosdkLogs51.pushLogs({
                logText: "Error changeMode(".concat(requestedMode, ") | failed"),
                logType: "ERROR",
                attributes: {
                  error: _t42.message
                }
              });
              (_this$_openTelemetry111 = this._openTelemetry) === null || _this$_openTelemetry111 === void 0 || _this$_openTelemetry111.completeSpan({
                span: changeModeSpan,
                status: 2,
                message: "changeMode(".concat(requestedMode, ") | failed")
              });
            case 19:
            case "end":
              return _context49.stop();
          }
        }, _callee49, this, [[1, 18]]);
      }));
      function changeMode(_x55) {
        return _changeMode.apply(this, arguments);
      }
      return changeMode;
    }() // Helper function to close producers and transport
  }, {
    key: "_closeProducersAndTransport",
    value: function _closeProducersAndTransport() {
      var _this$_sendTransport3;
      if (this._webcamProducer) {
        this._webcamProducer.close();
        this._webcamProducer = null;
      }
      if (this._micProducer) {
        this._micProducer.close();
        this._micProducer = null;
      }
      if (this._shareProducer) {
        this._shareProducer.close();
        this._shareProducer = null;
      }
      if (this._shareAudioProducer) {
        this._shareAudioProducer.close();
        this._shareAudioProducer = null;
      }
      (_this$_sendTransport3 = this._sendTransport) === null || _this$_sendTransport3 === void 0 || _this$_sendTransport3.close();
      this._sendTransport = null;
    }

    // Helper function to close transports
  }, {
    key: "_closeTransports",
    value: function _closeTransports() {
      if (this._sendTransport) {
        var _this$_sendTransport4;
        (_this$_sendTransport4 = this._sendTransport) === null || _this$_sendTransport4 === void 0 || _this$_sendTransport4.close();
        this._sendTransport = null;
      }
      if (this._recvTransport) {
        var _this$_recvTransport3;
        (_this$_recvTransport3 = this._recvTransport) === null || _this$_recvTransport3 === void 0 || _this$_recvTransport3.close();
        this._recvTransport = null;
      }
    }

    // Helper function to setup WebRTC transport
  }, {
    key: "_setupWebrtcTransport",
    value: function () {
      var _setupWebrtcTransport2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee50(changeModeSpan) {
        var routerRtpCapabilities, _routerRtpCapabilitie2, transportInfo;
        return regenerator_default().wrap(function (_context50) {
          while (1) switch (_context50.prev = _context50.next) {
            case 0:
              this._mediasoupDevice = new lib/* Device */.pF({
                handlerName: this._handlerName
              });
              _context50.next = 1;
              return this._socketRequest("getRouterRtpCapabilities");
            case 1:
              routerRtpCapabilities = _context50.sent;
              if (this._deviceInfo.sdkType !== "react-native" && navigator.userAgent.includes("Firefox")) {
                routerRtpCapabilities.headerExtensions = (_routerRtpCapabilitie2 = routerRtpCapabilities.headerExtensions) === null || _routerRtpCapabilitie2 === void 0 ? void 0 : _routerRtpCapabilitie2.filter(function (c) {
                  return c.uri != "urn:3gpp:video-orientation";
                });
              }
              _context50.next = 2;
              return this._mediasoupDevice.load({
                routerRtpCapabilities: routerRtpCapabilities
              });
            case 2:
              _context50.next = 3;
              return this._socketRequest("createWebRtcTransport", {
                preferredProtocol: this._preferredProtocol,
                producing: false,
                consuming: true,
                sctpCapabilities: this._mediasoupDevice.sctpCapabilities
              });
            case 3:
              transportInfo = _context50.sent;
              this.createConsumerTransport(transportInfo, changeModeSpan);
            case 4:
            case "end":
              return _context50.stop();
          }
        }, _callee50, this);
      }));
      function _setupWebrtcTransport(_x58) {
        return _setupWebrtcTransport2.apply(this, arguments);
      }
      return _setupWebrtcTransport;
    }()
  }, {
    key: "enablePeerWebcam",
    value: function () {
      var _enablePeerWebcam = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee51(peerId) {
        var _this$_openTelemetry112;
        var _this$_videosdkLogs52, _t43;
        return regenerator_default().wrap(function (_context51) {
          while (1) switch (_context51.prev = _context51.next) {
            case 0:
              (_this$_openTelemetry112 = this._openTelemetry) === null || _this$_openTelemetry112 === void 0 || _this$_openTelemetry112.traceAutoComplete({
                spanName: "Enabling peer ".concat(peerId, " Webcam"),
                status: 1
              });
              logger.debug("enablePeerWebcam()");
              _context51.prev = 1;
              _context51.next = 2;
              return this._socketRequest("enablePeerWebcam", {
                peerId: peerId
              });
            case 2:
              _context51.next = 4;
              break;
            case 3:
              _context51.prev = 3;
              _t43 = _context51["catch"](1);
              (_this$_videosdkLogs52 = this._videosdkLogs) === null || _this$_videosdkLogs52 === void 0 || _this$_videosdkLogs52.pushLogs({
                logText: "Error enablePeerWebcam | failed",
                logType: "ERROR",
                attributes: {
                  error: _t43.message
                }
              });
              logger.error("enablePeerWebcam() | failed:%o", _t43);
            case 4:
            case "end":
              return _context51.stop();
          }
        }, _callee51, this, [[1, 3]]);
      }));
      function enablePeerWebcam(_x59) {
        return _enablePeerWebcam.apply(this, arguments);
      }
      return enablePeerWebcam;
    }()
  }, {
    key: "disablePeerWebcam",
    value: function () {
      var _disablePeerWebcam = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee52(peerId) {
        var _this$_openTelemetry113;
        var _this$_videosdkLogs53, _t44;
        return regenerator_default().wrap(function (_context52) {
          while (1) switch (_context52.prev = _context52.next) {
            case 0:
              (_this$_openTelemetry113 = this._openTelemetry) === null || _this$_openTelemetry113 === void 0 || _this$_openTelemetry113.traceAutoComplete({
                spanName: "Disabling peer ".concat(peerId, " Webcam"),
                status: 1
              });
              logger.debug("disablePeerWebcam()");
              _context52.prev = 1;
              _context52.next = 2;
              return this._socketRequest("disablePeerWebcam", {
                peerId: peerId
              });
            case 2:
              _context52.next = 4;
              break;
            case 3:
              _context52.prev = 3;
              _t44 = _context52["catch"](1);
              (_this$_videosdkLogs53 = this._videosdkLogs) === null || _this$_videosdkLogs53 === void 0 || _this$_videosdkLogs53.pushLogs({
                logText: "Error disablePeerWebcam | failed",
                logType: "ERROR",
                attributes: {
                  error: _t44.message
                }
              });
            case 4:
            case "end":
              return _context52.stop();
          }
        }, _callee52, this, [[1, 3]]);
      }));
      function disablePeerWebcam(_x60) {
        return _disablePeerWebcam.apply(this, arguments);
      }
      return disablePeerWebcam;
    }() // Stats are moved to the send transport,
    // since they are not available in React Native.
    // getMicStats(probe) {
    //   if (this._micProducer) {
    //     let reportCounter = 0;
    //     probe.onStatsCollected = (report) => {
    //       if (!this._stats.producerStats) {
    //         this._stats.producerStats = {};
    //       }
    //       if (!this._stats.producerStats["audio"]) {
    //         this._stats.producerStats["audio"] = [];
    //       }
    //       if (this._micProducer) {
    //         this._latestStats[this._micProducer?.id] = [];
    //       }
    //       report["audio"].forEach((stat) => {
    //         if (this._micProducer) {
    //           this._latestStats[this._micProducer?.id].push(stat);
    //         }
    //       });
    //       if (reportCounter % 5 == 0 && this._micProducer != null) {
    //         this._stats["producerStats"]["audio"].push({
    //           timestamp: new Date(),
    //           ...(this._latestStats[this._micProducer.id]
    //             ? this._latestStats[this._micProducer.id][0]
    //             : {}),
    //         });
    //       }
    //       reportCounter++;
    //     };
    //   }
    // }
  }, {
    key: "enableMic",
    value: function () {
      var _enableMic = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee53() {
        var _this$_openTelemetry114,
          _this3 = this,
          _this$_videosdkLogs61,
          _this$_openTelemetry126,
          _this$_videosdkLogs62,
          _this$_openTelemetry127;
        var customAudioTrack,
          parentSpan,
          enableMicSpan,
          _this$_openTelemetry115,
          _this$_openTelemetry117,
          micProducerSpan,
          _this$_openTelemetry116,
          oldProducer,
          _this$_openTelemetry118,
          action,
          _this$_openTelemetry119,
          _this$_videosdkLogs54,
          _this$_videosdkLogs55,
          _this$_openTelemetry120,
          message,
          _this$_videosdkLogs56,
          _this$_openTelemetry121,
          track,
          internalSpan,
          _this$_openTelemetry130,
          _this$_openTelemetry131,
          _this$_openTelemetry132,
          _this$_openTelemetry133,
          _track,
          _message,
          _this$_videosdkLogs57,
          sdkError,
          _this$_videosdkLogs58,
          _sdkError,
          _this$_openTelemetry122,
          _this$_openTelemetry129,
          trackSpan,
          stream,
          _this$_openTelemetry123,
          _this$_videosdkLogs59,
          _this$_openTelemetry124,
          errorMessage,
          _message2,
          _this$_videosdkLogs60,
          _this$_openTelemetry125,
          _errorMessage,
          _message3,
          notAllowedErrorData,
          notReadableErrorData,
          _errorMessage2,
          _message4,
          err,
          _this$_videosdkLogs63,
          _this$_openTelemetry128,
          _err,
          _stream,
          codecOptions,
          audioProfile,
          networkPriority,
          encodings,
          appData,
          _this$_videosdkLogs64,
          _this$_openTelemetry134,
          _this$_openTelemetry135,
          _action6,
          _this$_videosdkLogs65,
          _this$_openTelemetry136,
          _this$_openTelemetry137,
          _this$_openTelemetry138,
          _this$_openTelemetry139,
          _this$_videosdkLogs66,
          _args53 = arguments,
          _t45,
          _t46,
          _t47;
        return regenerator_default().wrap(function (_context53) {
          while (1) switch (_context53.prev = _context53.next) {
            case 0:
              customAudioTrack = _args53.length > 0 && _args53[0] !== undefined ? _args53[0] : undefined;
              parentSpan = _args53.length > 1 && _args53[1] !== undefined ? _args53[1] : undefined;
              enableMicSpan = (_this$_openTelemetry114 = this._openTelemetry) === null || _this$_openTelemetry114 === void 0 ? void 0 : _this$_openTelemetry114.trace({
                spanName: "enableMic() Calling ".concat(!!customAudioTrack ? "With Custom Audio Track" : "Without Custom Audio Track "),
                attributes: {
                  customAudioConfig: customAudioTrack ? JSON.stringify(customAudioTrack) : "Not Specify Custom Track"
                },
                span: parentSpan ? parentSpan : null
              });
              logger.debug("enableMic()");
              this._micEnabled = true;
              if (!this._micProducer) {
                _context53.next = 4;
                break;
              }
              micProducerSpan = (_this$_openTelemetry115 = this._openTelemetry) === null || _this$_openTelemetry115 === void 0 ? void 0 : _this$_openTelemetry115.trace({
                spanName: "Mic Producer found",
                span: enableMicSpan
              });
              if (customAudioTrack) {
                (_this$_openTelemetry116 = this._openTelemetry) === null || _this$_openTelemetry116 === void 0 || _this$_openTelemetry116.traceAutoComplete({
                  spanName: "Stopping customAudioTrack",
                  span: enableMicSpan,
                  status: 1
                });
                customAudioTrack.getTracks().forEach(function (track) {
                  track.stop();
                });
              }
              (_this$_openTelemetry117 = this._openTelemetry) === null || _this$_openTelemetry117 === void 0 || _this$_openTelemetry117.completeSpan({
                span: micProducerSpan,
                status: 1,
                message: "Resuming Mic Producer"
              });
              this._micProducer.resume();
              oldProducer = this._micProducer;
              if (!this._sendTransport) {
                _context53.next = 2;
                break;
              }
              _context53.next = 1;
              return this._sendTransport.produce({
                track: this._micProducer.track,
                encodings: this._micProducer._appData.encodings,
                codecOptions: this._micProducer._appData.codecOptions,
                appData: {
                  isEncrypted: this.isE2EEEnabled
                },
                onRtpSender: function onRtpSender(rtpSender) {
                  if (_this3.e2eeManager) {
                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                  }
                }
              });
            case 1:
              this._micProducer = _context53.sent;
              if (this.e2eeManager) {
                this.e2eeManager.emit("NEW_PRODUCER", this._micProducer);
              }
              if (this._micProducer) {
                action = addProducer({
                  id: this._micProducer.id,
                  paused: this._micProducer.paused,
                  track: this._micProducer.track,
                  rtpParameters: this._micProducer.rtpParameters,
                  codec: this._micProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                  encodings: oldProducer._appData.encodings,
                  codecOptions: oldProducer._appData.codecOptions,
                  instance: this._micProducer,
                  rtpSender: this._micProducer.rtpSender
                });
                if (this._micProducer.track.getConstraints().deviceId) {
                  this._mic.device = this._mics.get(this._micProducer.track.getConstraints().deviceId);
                }
                store.dispatch(action);
                this._eventEmitter.emit(action.type, action.payload);
                (_this$_openTelemetry118 = this._openTelemetry) === null || _this$_openTelemetry118 === void 0 || _this$_openTelemetry118.completeSpan({
                  span: enableMicSpan,
                  status: 1,
                  message: "Enable Mic Successful"
                });
              } else {
                (_this$_openTelemetry119 = this._openTelemetry) === null || _this$_openTelemetry119 === void 0 || _this$_openTelemetry119.completeSpan({
                  span: enableMicSpan,
                  status: 2,
                  message: "Error in enableMic() :: micProducer null"
                });
              }
              _context53.next = 3;
              break;
            case 2:
              (_this$_videosdkLogs54 = this._videosdkLogs) === null || _this$_videosdkLogs54 === void 0 || _this$_videosdkLogs54.pushLogs({
                logText: errors/* sdkErrors */.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED.message,
                attributes: {
                  error: "Error in enableMic() :: Transport is not setup"
                },
                logType: "ERROR",
                dashboardLog: true
              });
              this._emitError(errors/* sdkErrors */.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED);
              return _context53.abrupt("return");
            case 3:
              return _context53.abrupt("return");
            case 4:
              if (!this._mediasoupDevice) {
                _context53.next = 6;
                break;
              }
              if (this._mediasoupDevice.canProduce("audio")) {
                _context53.next = 5;
                break;
              }
              message = this._deviceInfo.sdkType == "react-native" ? errors/* sdkErrors */.q.ERROR_RN_MIC_ACCESS_UNAVAILABLE.message : errors/* sdkErrors */.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE.message;
              (_this$_videosdkLogs55 = this._videosdkLogs) === null || _this$_videosdkLogs55 === void 0 || _this$_videosdkLogs55.pushLogs({
                logText: message,
                attributes: {
                  error: "Error in enableMic() :: Microphone access unavailable"
                },
                logType: "ERROR",
                dashboardLog: true
              });
              logger.error("enableMic() | cannot produce audio");
              (_this$_openTelemetry120 = this._openTelemetry) === null || _this$_openTelemetry120 === void 0 || _this$_openTelemetry120.completeSpan({
                span: enableMicSpan,
                status: 2,
                message: "Error in enableMic() :: ".concat(message)
              });
              return _context53.abrupt("return");
            case 5:
              _context53.next = 7;
              break;
            case 6:
              (_this$_videosdkLogs56 = this._videosdkLogs) === null || _this$_videosdkLogs56 === void 0 || _this$_videosdkLogs56.pushLogs({
                logText: "Oops! Something went wrong, and we're unable to enable the mic. Please try again.",
                logType: "ERROR",
                attributes: {
                  error: "Error in enableMic(): Something went wrong."
                },
                dashboardLog: true
              });
              (_this$_openTelemetry121 = this._openTelemetry) === null || _this$_openTelemetry121 === void 0 || _this$_openTelemetry121.completeSpan({
                span: enableMicSpan,
                status: 2,
                message: "Error in enableMic() :: mediasoupDevice is undefined"
              });
              return _context53.abrupt("return");
            case 7:
              _context53.prev = 7;
              if (this._externalVideo) {
                _context53.next = 24;
                break;
              }
              logger.debug("enableMic() | calling getUserMedia()");
              _context53.next = 8;
              return this._updateMics(enableMicSpan);
            case 8:
              if (this._mic.device) {
                _context53.next = 9;
                break;
              }
              _message = "Whoops! No Microphone Found: We couldn't find your microphone. Is it plugged in and turned on? If so, try restarting your computer or checking your device settings. Also, ensure you're on a secure website (https://).";
              throw new Error(_message);
            case 9:
              try {
                if (customAudioTrack) {
                  track = customAudioTrack.getAudioTracks()[0];
                  if (track.readyState == "ended") {
                    track = null;
                    sdkError = errors/* sdkErrors */.q.ERROR_CUSTOM_AUDIO_TRACK_ENDED;
                    (_this$_videosdkLogs57 = this._videosdkLogs) === null || _this$_videosdkLogs57 === void 0 || _this$_videosdkLogs57.pushLogs({
                      logText: sdkError.message,
                      logType: "INFO",
                      attributes: {
                        error: "In enableMic() :: Invalid Custom Track Passed"
                      },
                      dashboardLog: true
                    });
                    this._emitError(sdkError);
                  }
                }
              } catch (error) {
                _sdkError = errors/* sdkErrors */.q.ERROR_INVALID_CUSTOM_AUDIO_TRACK;
                (_this$_videosdkLogs58 = this._videosdkLogs) === null || _this$_videosdkLogs58 === void 0 || _this$_videosdkLogs58.pushLogs({
                  logText: _sdkError.message,
                  logType: "INFO",
                  attributes: {
                    error: "In enableMic() :: Invalid Custom Track Passed"
                  }
                });
                this._emitError(_sdkError);
                console.log("Invalid Custom Audio Track Passed. Reverting to default Error: ".concat(error));
              }
              if (track) {
                _context53.next = 23;
                break;
              }
              trackSpan = (_this$_openTelemetry122 = this._openTelemetry) === null || _this$_openTelemetry122 === void 0 ? void 0 : _this$_openTelemetry122.trace({
                spanName: "Creating Track",
                span: enableMicSpan
              });
              _context53.prev = 10;
              _context53.next = 11;
              return navigator.mediaDevices.getUserMedia({
                audio: {
                  // deviceId: { exact: this._mic.device.deviceId },
                  deviceId: this._mic.device.deviceId ? {
                    exact: this._mic.device.deviceId
                  } : undefined,
                  channelCount: 1,
                  noiseSuppression: true,
                  echoCancellation: true,
                  googEchoCancellation: true,
                  googEchoCancellation2: true,
                  googAutoGainControl: true,
                  googAutoGainControl2: true,
                  googNoiseSuppression: true,
                  googNoiseSuppression2: true,
                  googHighpassFilter: true
                }
              });
            case 11:
              stream = _context53.sent;
              _context53.next = 22;
              break;
            case 12:
              _context53.prev = 12;
              _t45 = _context53["catch"](10);
              (_this$_openTelemetry123 = this._openTelemetry) === null || _this$_openTelemetry123 === void 0 || _this$_openTelemetry123.completeSpan({
                message: "Error in enableMic() :: ".concat(_t45.message),
                span: trackSpan,
                status: 2
              });
              if (!(_t45.name === "SecurityError")) {
                _context53.next = 13;
                break;
              }
              errorMessage = errors/* sdkErrors */.q.ERROR_RN_MIC_ACCESS_DENIED_OR_DISMISSED;
              _message2 = errorMessage.message;
              this._emitError(errorMessage);
              (_this$_videosdkLogs59 = this._videosdkLogs) === null || _this$_videosdkLogs59 === void 0 || _this$_videosdkLogs59.pushLogs({
                logText: _message2,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableMic() :: Microphone Permission Denied or Dismissed"
                },
                dashboardLog: true
              });
              (_this$_openTelemetry124 = this._openTelemetry) === null || _this$_openTelemetry124 === void 0 || _this$_openTelemetry124.completeSpan({
                message: "Error in enableMic() :: occurred in creating audio track, ".concat(_message2),
                span: enableMicSpan,
                status: 2
              });
              _context53.next = 21;
              break;
            case 13:
              if (!(_t45.name === "DOMException")) {
                _context53.next = 14;
                break;
              }
              _errorMessage = errors/* sdkErrors */.q.ERROR_RN_MIC_NOT_FOUND;
              _message3 = _errorMessage.message;
              this._emitError(_errorMessage);
              (_this$_videosdkLogs60 = this._videosdkLogs) === null || _this$_videosdkLogs60 === void 0 || _this$_videosdkLogs60.pushLogs({
                logText: _message3,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableMic() :: No Microphone Device Found"
                },
                dashboardLog: true
              });
              (_this$_openTelemetry125 = this._openTelemetry) === null || _this$_openTelemetry125 === void 0 || _this$_openTelemetry125.completeSpan({
                message: "Error in enableMic() :: occurred in creating audio track, ".concat(_message3),
                span: enableMicSpan,
                status: 2
              });
              _context53.next = 21;
              break;
            case 14:
              if (!(_t45 instanceof DOMException)) {
                _context53.next = 20;
                break;
              }
              _t46 = _t45.name;
              _context53.next = _t46 === "NotAllowedError" ? 15 : _t46 === "NotReadableError" ? 16 : _t46 === "NotFoundError" ? 17 : 18;
              break;
            case 15:
              notAllowedErrorData = this.handleNotAllowedError(_t45, this._openTelemetry, this._videosdkLogs, enableMicSpan, "audio");
              this._emitError(notAllowedErrorData);
              return _context53.abrupt("continue", 19);
            case 16:
              notReadableErrorData = this.handleNotReadableError(_t45, this._openTelemetry, this._videosdkLogs, enableMicSpan, "audio");
              this._emitError(notReadableErrorData);
              return _context53.abrupt("continue", 19);
            case 17:
              _errorMessage2 = errors/* sdkErrors */.q.ERROR_MICROPHONE_NOT_FOUND;
              if (navigator && navigator.userAgent) {
                if (navigator.userAgent.indexOf("Firefox") != -1) {
                  // Occurs when microphone is not accessed by the firefox browser, and user allows microphone permission
                  _errorMessage2 = errors/* sdkErrors */.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS;
                }
              }
              _message4 = _errorMessage2.message;
              this._emitError(_errorMessage2);
              (_this$_videosdkLogs61 = this._videosdkLogs) === null || _this$_videosdkLogs61 === void 0 || _this$_videosdkLogs61.pushLogs({
                logText: _message4,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableMic() :: No Microphone Device Found"
                },
                dashboardLog: true
              });
              (_this$_openTelemetry126 = this._openTelemetry) === null || _this$_openTelemetry126 === void 0 || _this$_openTelemetry126.completeSpan({
                message: "Error in enableMic() :: occurred in creating audio track, ".concat(_message4),
                span: enableMicSpan,
                status: 2
              });
              return _context53.abrupt("continue", 19);
            case 18:
              err = "An error occurred in creating audio track, ".concat(_t45.message);
              (_this$_videosdkLogs62 = this._videosdkLogs) === null || _this$_videosdkLogs62 === void 0 || _this$_videosdkLogs62.pushLogs({
                logText: _t45.message,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableMic() :: ".concat(err)
                },
                dashboardLog: true
              });
              (_this$_openTelemetry127 = this._openTelemetry) === null || _this$_openTelemetry127 === void 0 || _this$_openTelemetry127.completeSpan({
                message: "Error in enableMic() :: ".concat(err),
                span: enableMicSpan,
                status: 2
              });
              return _context53.abrupt("continue", 19);
            case 19:
              _context53.next = 21;
              break;
            case 20:
              _err = "An error occurred in creating audio track, ".concat(_t45.message);
              (_this$_videosdkLogs63 = this._videosdkLogs) === null || _this$_videosdkLogs63 === void 0 || _this$_videosdkLogs63.pushLogs({
                logText: _t45.message,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableMic() :: ".concat(_err)
                },
                dashboardLog: true
              });
              (_this$_openTelemetry128 = this._openTelemetry) === null || _this$_openTelemetry128 === void 0 || _this$_openTelemetry128.completeSpan({
                message: "Error in enableMic() :: ".concat(_err),
                span: enableMicSpan,
                status: 2
              });
            case 21:
              return _context53.abrupt("return");
            case 22:
              track = stream.getAudioTracks()[0];
              (_this$_openTelemetry129 = this._openTelemetry) === null || _this$_openTelemetry129 === void 0 || _this$_openTelemetry129.completeSpan({
                message: "Audio Track Generated",
                span: trackSpan,
                status: 1
              });
            case 23:
              _context53.next = 26;
              break;
            case 24:
              _context53.next = 25;
              return this._getExternalVideoStream();
            case 25:
              _stream = _context53.sent;
              track = _stream.getAudioTracks()[0].clone();
            case 26:
              internalSpan = (_this$_openTelemetry130 = this._openTelemetry) === null || _this$_openTelemetry130 === void 0 ? void 0 : _this$_openTelemetry130.trace({
                spanName: "Generating Producer Configuration",
                span: enableMicSpan
              });
              codecOptions = {
                opusStereo: 1,
                opusDtx: 1
              };
              if (customAudioTrack) {
                audioProfile = customAudioTrack.encoderConfig ? config/* config */.$.audioProfiles[customAudioTrack.encoderConfig] : config/* config */.$.audioProfiles.speech_standard;
                codecOptions = {
                  opusStereo: audioProfile.stereo ? 1 : 0,
                  opusFec: audioProfile.fec ? 1 : 0,
                  opusDtx: audioProfile.dtx ? 1 : 0,
                  opusMaxPlaybackRate: audioProfile.maxPlaybackRate,
                  opusPtime: audioProfile.packetTime
                };
                // encodings = [
                //   {
                //     maxBitrate: audioProfile.bitRate
                //   }
                // ]
              }

              // Audio packet priority high
              networkPriority = "high";
              encodings = [{
                networkPriority: networkPriority
              }];
              appData = {
                encodings: encodings,
                codecOptions: codecOptions
              };
              (_this$_openTelemetry131 = this._openTelemetry) === null || _this$_openTelemetry131 === void 0 || _this$_openTelemetry131.traceAutoComplete({
                spanName: "Generated AppData",
                span: internalSpan,
                attributes: {
                  appData: JSON.stringify(appData)
                },
                status: 1
              });
              (_this$_openTelemetry132 = this._openTelemetry) === null || _this$_openTelemetry132 === void 0 || _this$_openTelemetry132.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Producer Configuration Generated"
              });
              internalSpan = (_this$_openTelemetry133 = this._openTelemetry) === null || _this$_openTelemetry133 === void 0 ? void 0 : _this$_openTelemetry133.trace({
                spanName: "Creating Mic Producer",
                span: enableMicSpan
              });
              (_track = track) === null || _track === void 0 || _track.addEventListener("ended", function () {
                console.log("Track Ended Error");
                try {
                  var _this3$_videosdkLogs, _this3$_openTelemetry;
                  var error = _this3._deviceInfo.sdkType == "react-native" ? errors/* sdkErrors */.q.ERROR_RN_MIC_TRACK_ENDED : errors/* sdkErrors */.q.ERROR_MICROPHONE_TRACK_ENDED;
                  (_this3$_videosdkLogs = _this3._videosdkLogs) === null || _this3$_videosdkLogs === void 0 || _this3$_videosdkLogs.pushLogs({
                    logText: error.message,
                    logType: "ERROR",
                    attributes: {
                      error: "Error Track Ended :: ".concat(error.message)
                    },
                    dashboardLog: true
                  });
                  (_this3$_openTelemetry = _this3._openTelemetry) === null || _this3$_openTelemetry === void 0 || _this3$_openTelemetry.traceAutoComplete({
                    spanName: "this._micProducer trackended or Microphone disconnected!",
                    span: enableMicSpan,
                    message: error.message,
                    status: 2
                  });
                  store.dispatch(notify({
                    type: "error",
                    text: "Microphone disconnected!"
                  }));
                  // INFO: Some of customer repeatedly getting events whenever they disconnect audio device
                  // this._emitError(error);
                  _this3.disableMic(true, enableMicSpan)["catch"](function () {});
                } catch (err) {
                  console.error(err);
                }
              });
              if (!this._sendTransport) {
                _context53.next = 28;
                break;
              }
              _context53.next = 27;
              return this._sendTransport.produce({
                track: track,
                encodings: encodings,
                codecOptions: codecOptions,
                appData: RoomClient_objectSpread(RoomClient_objectSpread({}, appData), {}, {
                  isEncrypted: this.isE2EEEnabled
                }),
                onRtpSender: function onRtpSender(rtpSender) {
                  if (_this3.e2eeManager) {
                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                  }
                }
                // NOTE: for testing codec selection.
                // codec : this._mediasoupDevice.rtpCapabilities.codecs
                // 	.find((codec) => codec.mimeType.toLowerCase() === 'audio/pcma')
              });
            case 27:
              this._micProducer = _context53.sent;
              if (this.e2eeManager) {
                this.e2eeManager.emit("NEW_PRODUCER", this._micProducer);
              }
              _context53.next = 29;
              break;
            case 28:
              (_this$_videosdkLogs64 = this._videosdkLogs) === null || _this$_videosdkLogs64 === void 0 || _this$_videosdkLogs64.pushLogs({
                logText: errors/* sdkErrors */.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED.message,
                attributes: {
                  error: "Error in enableMic() :: Transport is not setup"
                },
                logType: "ERROR",
                dashboardLog: true
              });
              this._emitError(errors/* sdkErrors */.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED);
              return _context53.abrupt("return");
            case 29:
              if (this._micProducer) {
                if (track.getConstraints().deviceId) {
                  this._mic.device = this._mics.get(track.getConstraints().deviceId);
                }
                _action6 = addProducer({
                  id: this._micProducer.id,
                  paused: this._micProducer.paused,
                  track: this._micProducer.track,
                  rtpParameters: this._micProducer.rtpParameters,
                  codec: this._micProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                  encodings: encodings,
                  codecOptions: codecOptions,
                  instance: this._micProducer,
                  rtpSender: this._micProducer.rtpSender
                });
                store.dispatch(_action6);
                this._eventEmitter.emit(_action6.type, _action6.payload);
                // Stats are moved to the send transport,
                // since they are not available in React Native.

                // let probe = this._metrics.addNewProbe(this._micProducer, {
                //   name: "mic_producer",
                // });

                // probe.start();
                // this.getMicStats(probe);

                this._micProducer.on("transportclose", function () {
                  var _this3$_micProducer;
                  var action = removeProducer(_this3._micProducer.id);
                  store.dispatch(action);
                  _this3._eventEmitter.emit(action.type, action.payload);

                  // this._micEnabled = false;
                  (_this3$_micProducer = _this3._micProducer) === null || _this3$_micProducer === void 0 || _this3$_micProducer.close();
                  _this3._micProducer = null;
                });
                // Stats are moved to the send transport,
                // since they are not available in React Native.

                // this._micProducer.observer.on("pause", () => {
                //   // const probe = this._metrics.getProbe("mic_producer");
                //   probe?.stop();
                //   this._latestStats[this._micProducer.id] = [];
                //   this._metrics.removeExistingProbe(probe);
                // });

                // this._micProducer.observer.on("close", () => {
                //   // const probe = this._metrics.getProbe("mic_producer");
                //   probe?.stop();
                //   this._latestStats[this._micProducer.id] = [];
                //   this._metrics.removeExistingProbe(probe);
                // });

                this._micProducer.on("trackended", function () {
                  var _this3$_videosdkLogs2, _this3$_openTelemetry2;
                  var error = _this3._deviceInfo.sdkType == "react-native" ? errors/* sdkErrors */.q.ERROR_RN_MIC_TRACK_ENDED : errors/* sdkErrors */.q.ERROR_MICROPHONE_TRACK_ENDED;
                  (_this3$_videosdkLogs2 = _this3._videosdkLogs) === null || _this3$_videosdkLogs2 === void 0 || _this3$_videosdkLogs2.pushLogs({
                    logText: error.message,
                    logType: "ERROR",
                    attributes: {
                      error: "Error in enableMic() :: ".concat(error.message)
                    },
                    dashboardLog: true
                  });
                  (_this3$_openTelemetry2 = _this3._openTelemetry) === null || _this3$_openTelemetry2 === void 0 || _this3$_openTelemetry2.traceAutoComplete({
                    spanName: "this._micProducer trackended or Microphone disconnected!",
                    span: enableMicSpan,
                    message: error.message,
                    status: 2
                  });
                  store.dispatch(notify({
                    type: "error",
                    text: "Microphone disconnected!"
                  }));

                  // INFO: Some of our customer repeatedly getting events whenever they disconnect audio device
                  // this._emitError(error);

                  _this3.disableMic(true, enableMicSpan)["catch"](function () {});
                });
                (_this$_openTelemetry134 = this._openTelemetry) === null || _this$_openTelemetry134 === void 0 || _this$_openTelemetry134.completeSpan({
                  span: internalSpan,
                  status: 1,
                  message: "Mic Producer Created"
                });
                (_this$_openTelemetry135 = this._openTelemetry) === null || _this$_openTelemetry135 === void 0 || _this$_openTelemetry135.completeSpan({
                  span: enableMicSpan,
                  status: 1,
                  message: "Enable Mic Successful"
                });
              } else {
                (_this$_videosdkLogs65 = this._videosdkLogs) === null || _this$_videosdkLogs65 === void 0 || _this$_videosdkLogs65.pushLogs({
                  logText: "Oops! Something went wrong, and we're unable to enable the mic. Please try again.",
                  logType: "ERROR",
                  attributes: {
                    error: "Error in enableMic(): Something went wrong."
                  },
                  dashboardLog: true
                });
                (_this$_openTelemetry136 = this._openTelemetry) === null || _this$_openTelemetry136 === void 0 || _this$_openTelemetry136.completeSpan({
                  span: internalSpan,
                  status: 2,
                  message: "Error in enableMic() :: micProducer null"
                });
                (_this$_openTelemetry137 = this._openTelemetry) === null || _this$_openTelemetry137 === void 0 || _this$_openTelemetry137.completeSpan({
                  span: enableMicSpan,
                  status: 2,
                  message: "Error in enableMic() :: micProducer null"
                });
              }
              _context53.next = 32;
              break;
            case 30:
              _context53.prev = 30;
              _t47 = _context53["catch"](7);
              (_this$_openTelemetry138 = this._openTelemetry) === null || _this$_openTelemetry138 === void 0 || _this$_openTelemetry138.completeSpan({
                span: internalSpan,
                status: 2,
                message: "Error in enableMic() :: occurred in creating mic producer, ".concat(_t47.message)
              });
              (_this$_openTelemetry139 = this._openTelemetry) === null || _this$_openTelemetry139 === void 0 || _this$_openTelemetry139.completeSpan({
                span: enableMicSpan,
                status: 2,
                message: "Error in enableMic :: ".concat(_t47.message)
              });
              (_this$_videosdkLogs66 = this._videosdkLogs) === null || _this$_videosdkLogs66 === void 0 || _this$_videosdkLogs66.pushLogs({
                logText: _t47.message,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableMic() :: ".concat(_t47.message)
                },
                dashboardLog: true
              });
              logger.error("enableMic() | failed:%o", _t47);
              store.dispatch(notify({
                type: "error",
                text: "Error enabling microphone: ".concat(_t47)
              }));
              _context53.next = 31;
              return this._socketRequest("produceError", {
                mediaType: "audio",
                message: _t47.message
              });
            case 31:
              if (track) track.stop();
            case 32:
            case "end":
              return _context53.stop();
          }
        }, _callee53, this, [[7, 30], [10, 12]]);
      }));
      function enableMic() {
        return _enableMic.apply(this, arguments);
      }
      return enableMic;
    }()
  }, {
    key: "disableMic",
    value: function () {
      var _disableMic = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee54() {
        var _this$_openTelemetry140, _this$_openTelemetry142;
        var closeProducer,
          parentSpan,
          disableMicSpan,
          _this$_openTelemetry141,
          _this$_videosdkLogs67,
          internalSpan,
          _this$_openTelemetry143,
          _this$_openTelemetry144,
          _this$_openTelemetry148,
          pauseMicSpan,
          _action7,
          _this$_openTelemetry145,
          _this$_openTelemetry146,
          _this$_openTelemetry147,
          _this$_videosdkLogs68,
          message,
          action,
          _this$_openTelemetry149,
          _this$_openTelemetry150,
          _this$_openTelemetry151,
          _this$_openTelemetry152,
          _this$_videosdkLogs69,
          _message5,
          _args54 = arguments,
          _t48,
          _t49;
        return regenerator_default().wrap(function (_context54) {
          while (1) switch (_context54.prev = _context54.next) {
            case 0:
              closeProducer = _args54.length > 0 && _args54[0] !== undefined ? _args54[0] : false;
              parentSpan = _args54.length > 1 && _args54[1] !== undefined ? _args54[1] : undefined;
              logger.debug("disableMic()");
              disableMicSpan = (_this$_openTelemetry140 = this._openTelemetry) === null || _this$_openTelemetry140 === void 0 ? void 0 : _this$_openTelemetry140.trace({
                spanName: "disableMic() Calling",
                status: 1,
                span: parentSpan ? parentSpan : null
              });
              if (this._micProducer) {
                _context54.next = 1;
                break;
              }
              (_this$_openTelemetry141 = this._openTelemetry) === null || _this$_openTelemetry141 === void 0 || _this$_openTelemetry141.completeSpan({
                span: disableMicSpan,
                status: 2,
                message: "Error in disableMic() :: Mic Producer Not found"
              });
              (_this$_videosdkLogs67 = this._videosdkLogs) === null || _this$_videosdkLogs67 === void 0 || _this$_videosdkLogs67.pushLogs({
                logText: "Attempted to call disableMic() multiple times",
                attributes: {
                  error: "Error in disableMic() :: Microphone is already disabled"
                },
                logType: "ERROR",
                dashboardLog: true
              });
              return _context54.abrupt("return");
            case 1:
              internalSpan = (_this$_openTelemetry142 = this._openTelemetry) === null || _this$_openTelemetry142 === void 0 ? void 0 : _this$_openTelemetry142.trace({
                spanName: "Closing Mic Producer",
                span: disableMicSpan,
                status: 1
              });
              this._micEnabled = false;
              if (!(this._micProducer && !closeProducer)) {
                _context54.next = 6;
                break;
              }
              pauseMicSpan = (_this$_openTelemetry143 = this._openTelemetry) === null || _this$_openTelemetry143 === void 0 ? void 0 : _this$_openTelemetry143.trace({
                spanName: "Pausing Mic Producer",
                span: internalSpan,
                status: 1
              });
              this._micProducer.pause();
              _action7 = removeProducer(this._micProducer.id);
              (_this$_openTelemetry144 = this._openTelemetry) === null || _this$_openTelemetry144 === void 0 || _this$_openTelemetry144.completeSpan({
                span: pauseMicSpan,
                status: 1,
                message: "Pause Mic Successfully"
              });
              store.dispatch(_action7);
              this._eventEmitter.emit(_action7.type, _action7.payload);
              _context54.prev = 2;
              _context54.next = 3;
              return this._socketRequest("closeProducer", {
                producerId: this._micProducer.id
              });
            case 3:
              (_this$_openTelemetry145 = this._openTelemetry) === null || _this$_openTelemetry145 === void 0 || _this$_openTelemetry145.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Requested Server to Close Producer"
              });
              _context54.next = 5;
              break;
            case 4:
              _context54.prev = 4;
              _t48 = _context54["catch"](2);
              store.dispatch(notify({
                type: "error",
                text: "Error closing server-side mic Producer: ".concat(_t48)
              }));
              message = "Error in disableMic() :: Failed to close server-side microphone producer. closeProducer status: ".concat(closeProducer);
              (_this$_openTelemetry146 = this._openTelemetry) === null || _this$_openTelemetry146 === void 0 || _this$_openTelemetry146.completeSpan({
                span: internalSpan,
                status: 2,
                message: "Error in disableMic() :: ".concat(_t48.message)
              });
              (_this$_openTelemetry147 = this._openTelemetry) === null || _this$_openTelemetry147 === void 0 || _this$_openTelemetry147.completeSpan({
                span: disableMicSpan,
                status: 2,
                message: message
              });
              (_this$_videosdkLogs68 = this._videosdkLogs) === null || _this$_videosdkLogs68 === void 0 || _this$_videosdkLogs68.pushLogs({
                logText: message,
                logType: "ERROR",
                attributes: {
                  error: _t48.message
                },
                dashboardLog: true
              });
            case 5:
              (_this$_openTelemetry148 = this._openTelemetry) === null || _this$_openTelemetry148 === void 0 || _this$_openTelemetry148.completeSpan({
                span: disableMicSpan,
                status: 1,
                message: "Mic Disabled Successfully"
              });
              return _context54.abrupt("return");
            case 6:
              this._micProducer.close();
              action = removeProducer(this._micProducer.id);
              store.dispatch(action);
              this._eventEmitter.emit(action.type, action.payload);
              _context54.prev = 7;
              _context54.next = 8;
              return this._socketRequest("closeProducer", {
                producerId: this._micProducer.id
              });
            case 8:
              (_this$_openTelemetry149 = this._openTelemetry) === null || _this$_openTelemetry149 === void 0 || _this$_openTelemetry149.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Requested Server to Close Producer"
              });
              (_this$_openTelemetry150 = this._openTelemetry) === null || _this$_openTelemetry150 === void 0 || _this$_openTelemetry150.completeSpan({
                span: disableMicSpan,
                status: 1,
                message: "Mic Disabled Successfully"
              });
              _context54.next = 10;
              break;
            case 9:
              _context54.prev = 9;
              _t49 = _context54["catch"](7);
              store.dispatch(notify({
                type: "error",
                text: "Error closing server-side mic Producer: ".concat(_t49)
              }));
              _message5 = "Error in disableMic() :: Failed to close server-side microphone producer. closeProducer status: ".concat(closeProducer);
              (_this$_openTelemetry151 = this._openTelemetry) === null || _this$_openTelemetry151 === void 0 || _this$_openTelemetry151.completeSpan({
                span: internalSpan,
                status: 2,
                message: "Error in disableMic() :: ".concat(_t49.message)
              });
              (_this$_openTelemetry152 = this._openTelemetry) === null || _this$_openTelemetry152 === void 0 || _this$_openTelemetry152.completeSpan({
                span: disableMicSpan,
                status: 2,
                message: _message5
              });
              (_this$_videosdkLogs69 = this._videosdkLogs) === null || _this$_videosdkLogs69 === void 0 || _this$_videosdkLogs69.pushLogs({
                logText: _message5,
                logType: "ERROR",
                attributes: {
                  error: _t49.message
                },
                dashboardLog: true
              });
            case 10:
              this._micProducer = null;
            case 11:
            case "end":
              return _context54.stop();
          }
        }, _callee54, this, [[2, 4], [7, 9]]);
      }));
      function disableMic() {
        return _disableMic.apply(this, arguments);
      }
      return disableMic;
    }()
  }, {
    key: "muteMic",
    value: function () {
      var _muteMic = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee55() {
        var _this$_videosdkLogs70, _t50;
        return regenerator_default().wrap(function (_context55) {
          while (1) switch (_context55.prev = _context55.next) {
            case 0:
              logger.debug("muteMic()");
              this._micEnabled = false;
              this._micProducer.pause();
              _context55.prev = 1;
              _context55.next = 2;
              return this._socketRequest("pauseProducer", {
                producerId: this._micProducer.id
              });
            case 2:
              store.dispatch(setProducerPaused(this._micProducer.id));
              _context55.next = 4;
              break;
            case 3:
              _context55.prev = 3;
              _t50 = _context55["catch"](1);
              logger.error("muteMic() | failed: %o", _t50);
              (_this$_videosdkLogs70 = this._videosdkLogs) === null || _this$_videosdkLogs70 === void 0 || _this$_videosdkLogs70.pushLogs({
                logText: "Error pausing server-side mic Producer",
                logType: "ERROR",
                attributes: {
                  error: _t50.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Error pausing server-side mic Producer: ".concat(_t50)
              }));
            case 4:
            case "end":
              return _context55.stop();
          }
        }, _callee55, this, [[1, 3]]);
      }));
      function muteMic() {
        return _muteMic.apply(this, arguments);
      }
      return muteMic;
    }()
  }, {
    key: "unmuteMic",
    value: function () {
      var _unmuteMic = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee56() {
        var _this$_videosdkLogs71, _t51;
        return regenerator_default().wrap(function (_context56) {
          while (1) switch (_context56.prev = _context56.next) {
            case 0:
              logger.debug("unmuteMic()");
              this._micEnabled = true;
              this._micProducer.resume();
              _context56.prev = 1;
              _context56.next = 2;
              return this._socketRequest("resumeProducer", {
                producerId: this._micProducer.id
              });
            case 2:
              store.dispatch(setProducerResumed(this._micProducer.id));
              _context56.next = 4;
              break;
            case 3:
              _context56.prev = 3;
              _t51 = _context56["catch"](1);
              logger.error("unmuteMic() | failed: %o", _t51);
              (_this$_videosdkLogs71 = this._videosdkLogs) === null || _this$_videosdkLogs71 === void 0 || _this$_videosdkLogs71.pushLogs({
                logText: "Error resuming server-side mic Producer",
                logType: "ERROR",
                attributes: {
                  error: _t51.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Error resuming server-side mic Producer: ".concat(_t51)
              }));
            case 4:
            case "end":
              return _context56.stop();
          }
        }, _callee56, this, [[1, 3]]);
      }));
      function unmuteMic() {
        return _unmuteMic.apply(this, arguments);
      }
      return unmuteMic;
    }()
  }, {
    key: "enableWebcam",
    value: function () {
      var _enableWebcam = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee57() {
        var _this$_openTelemetry153,
          _this$_videosdkLogs79,
          _this$_openTelemetry162,
          _this$_videosdkLogs80,
          _this$_openTelemetry163,
          _this4 = this;
        var customVideoTrack,
          parentSpan,
          enableWebcamSpan,
          _this$_openTelemetry154,
          _this$_videosdkLogs72,
          _this$_openTelemetry155,
          _this$_videosdkLogs73,
          message,
          _this$_videosdkLogs74,
          _this$_openTelemetry156,
          track,
          device,
          resolution,
          _this$_openTelemetry165,
          _this$_openTelemetry166,
          _this$_openTelemetry167,
          _this$_openTelemetry168,
          _message6,
          _this$_videosdkLogs75,
          sdkError,
          _this$_videosdkLogs76,
          _sdkError2,
          _this$_openTelemetry157,
          trackSpan,
          customVideoTrackConfig,
          _this$_openTelemetry158,
          _this$_openTelemetry159,
          _this$_videosdkLogs77,
          _this$_openTelemetry160,
          errorMessage,
          _message7,
          _this$_videosdkLogs78,
          _this$_openTelemetry161,
          _errorMessage3,
          _message8,
          notAllowedErrorData,
          notReadableErrorData,
          _sdkError3,
          _errorMessage4,
          err,
          _this$_videosdkLogs81,
          _this$_openTelemetry164,
          _err2,
          stream,
          internalSpan,
          encodings,
          codec,
          codecOptions,
          _errorMessage5,
          _errorMessage6,
          constraints,
          isRNiOS,
          firstVideoCodec,
          appData,
          _track2,
          _track3,
          _this$_videosdkLogs82,
          _this$_videosdkLogs83,
          _this$_openTelemetry169,
          _this$_openTelemetry170,
          action,
          _this$_videosdkLogs84,
          _this$_openTelemetry171,
          _this$_openTelemetry172,
          _this$_videosdkLogs85,
          _this$_openTelemetry173,
          _args57 = arguments,
          _t52,
          _t53,
          _t54;
        return regenerator_default().wrap(function (_context57) {
          while (1) switch (_context57.prev = _context57.next) {
            case 0:
              customVideoTrack = _args57.length > 0 && _args57[0] !== undefined ? _args57[0] : undefined;
              parentSpan = _args57.length > 1 && _args57[1] !== undefined ? _args57[1] : undefined;
              enableWebcamSpan = (_this$_openTelemetry153 = this._openTelemetry) === null || _this$_openTelemetry153 === void 0 ? void 0 : _this$_openTelemetry153.trace({
                spanName: "enableWebcam() Calling ".concat(!!customVideoTrack ? "With Custom Video Track" : "Without Custom Video Track "),
                attributes: {
                  customVideoConfig: customVideoTrack ? JSON.stringify(customVideoTrack) : "Not Specify Custom Track"
                },
                span: parentSpan ? parentSpan : null
              });
              logger.debug("enableWebcam()");
              this._webcamEnabled = true;
              if (!this._webcamProducer) {
                _context57.next = 1;
                break;
              }
              (_this$_openTelemetry154 = this._openTelemetry) === null || _this$_openTelemetry154 === void 0 || _this$_openTelemetry154.completeSpan({
                span: enableWebcamSpan,
                status: 2,
                message: "Error in enableWebcam() :: Webcam Producer found"
              });
              (_this$_videosdkLogs72 = this._videosdkLogs) === null || _this$_videosdkLogs72 === void 0 || _this$_videosdkLogs72.pushLogs({
                logText: "Attempted to call enableWebcam() multiple times",
                attributes: {
                  error: "Error in enableWebcam() :: Webcam is already enabled"
                },
                logType: "ERROR",
                dashboardLog: true
              });
              return _context57.abrupt("return");
            case 1:
              if (!this._mediasoupDevice) {
                _context57.next = 3;
                break;
              }
              if (this._mediasoupDevice.canProduce("video")) {
                _context57.next = 2;
                break;
              }
              message = this._deviceInfo.sdkType == "react-native" ? errors/* sdkErrors */.q.ERROR_RN_CAMERA_ACCESS_UNAVAILABLE.message : errors/* sdkErrors */.q.ERROR_CAMERA_ACCESS_UNAVAILABLE.message;
              (_this$_openTelemetry155 = this._openTelemetry) === null || _this$_openTelemetry155 === void 0 || _this$_openTelemetry155.completeSpan({
                span: enableWebcamSpan,
                status: 2,
                message: "Error in enableWebcam() :: ".concat(message)
              });
              (_this$_videosdkLogs73 = this._videosdkLogs) === null || _this$_videosdkLogs73 === void 0 || _this$_videosdkLogs73.pushLogs({
                logText: message,
                attributes: {
                  error: "Error in enableWebcam() :: Camera access unavailable"
                },
                logType: "ERROR",
                dashboardLog: true
              });
              logger.error("enableWebcam() | cannot produce video");
              return _context57.abrupt("return");
            case 2:
              _context57.next = 4;
              break;
            case 3:
              (_this$_videosdkLogs74 = this._videosdkLogs) === null || _this$_videosdkLogs74 === void 0 || _this$_videosdkLogs74.pushLogs({
                logText: "Oops! Something went wrong, and we're unable to enable the webcam. Please try again.",
                logType: "ERROR",
                attributes: {
                  error: "Error in enableWebcam(): Something went wrong."
                }
              });
              (_this$_openTelemetry156 = this._openTelemetry) === null || _this$_openTelemetry156 === void 0 || _this$_openTelemetry156.completeSpan({
                span: enableWebcamSpan,
                status: 2,
                message: "Error in enableWebcam() :: mediasoupDevice is undefined"
              });
              return _context57.abrupt("return");
            case 4:
              store.dispatch(setWebcamInProgress(true));
              resolution = this._webcam.resolution;
              _context57.prev = 5;
              if (this._externalVideo) {
                _context57.next = 24;
                break;
              }
              _context57.next = 6;
              return this._updateWebcams(enableWebcamSpan);
            case 6:
              device = this._webcam.device;
              if (device) {
                _context57.next = 7;
                break;
              }
              _message6 = "Whoops! No Webcam Found: We couldn't find your camera. Is it plugged in and turned on? If so, try restarting your computer or checking your device settings. If you need help, check out troubleshooter at https://test.8x8.vc/. Also, ensure you're on a secure website (https://).";
              throw new Error(_message6);
            case 7:
              logger.debug("enableWebcam() | calling getUserMedia()");
              try {
                if (customVideoTrack) {
                  track = customVideoTrack.getVideoTracks()[0];
                  if (track.readyState == "ended") {
                    track = null;
                    sdkError = errors/* sdkErrors */.q.ERROR_CUSTOM_VIDEO_TRACK_ENDED;
                    (_this$_videosdkLogs75 = this._videosdkLogs) === null || _this$_videosdkLogs75 === void 0 || _this$_videosdkLogs75.pushLogs({
                      logText: sdkError.message,
                      logType: "INFO",
                      attributes: {
                        error: "In enableWebcam() :: Invalid Custom Track Passed"
                      },
                      dashboardLog: true
                    });
                    this._emitError(sdkError);
                  }
                }
              } catch (error) {
                _sdkError2 = errors/* sdkErrors */.q.ERROR_INVALID_CUSTOM_VIDEO_TRACK;
                (_this$_videosdkLogs76 = this._videosdkLogs) === null || _this$_videosdkLogs76 === void 0 || _this$_videosdkLogs76.pushLogs({
                  logText: _sdkError2.message,
                  logType: "INFO",
                  attributes: {
                    error: "In enableWebcam() :: Invalid Custom Track Passed"
                  }
                });
                this._emitError(_sdkError2);
                console.log("Invalid Custom Video Track Passed. Reverting to default Error: ".concat(error));
              }
              if (track) {
                _context57.next = 23;
                break;
              }
              trackSpan = (_this$_openTelemetry157 = this._openTelemetry) === null || _this$_openTelemetry157 === void 0 ? void 0 : _this$_openTelemetry157.trace({
                spanName: "Creating Track",
                span: enableWebcamSpan
              });
              customVideoTrackConfig = null;
              _context57.prev = 8;
              if (!(this._webcam.resolution == "hd")) {
                _context57.next = 10;
                break;
              }
              _context57.next = 9;
              return src.VideoSDK.createCameraVideoTrack({
                cameraId: device.deviceId,
                encoderConfig: "h720p_w1280p",
                multiStream: this._useSimulcast,
                facingMode: device.facing
              });
            case 9:
              customVideoTrack = _context57.sent;
              customVideoTrackConfig = JSON.stringify({
                encoderConfig: "h720p_w1280p",
                multiStream: this._useSimulcast
              });
              _context57.next = 12;
              break;
            case 10:
              _context57.next = 11;
              return src.VideoSDK.createCameraVideoTrack({
                cameraId: device.deviceId,
                encoderConfig: "h540p_w960p",
                multiStream: this._useSimulcast,
                facingMode: device.facing
              });
            case 11:
              customVideoTrack = _context57.sent;
              customVideoTrackConfig = JSON.stringify({
                encoderConfig: "h540p_w960p",
                multiStream: this._useSimulcast
              });
            case 12:
              track = customVideoTrack.getVideoTracks()[0];
              (_this$_openTelemetry158 = this._openTelemetry) === null || _this$_openTelemetry158 === void 0 || _this$_openTelemetry158.completeSpan({
                message: "Video Track Generated",
                span: trackSpan,
                attributes: {
                  customVideoTrackConfig: customVideoTrackConfig
                },
                status: 1
              });
              _context57.next = 23;
              break;
            case 13:
              _context57.prev = 13;
              _t52 = _context57["catch"](8);
              (_this$_openTelemetry159 = this._openTelemetry) === null || _this$_openTelemetry159 === void 0 || _this$_openTelemetry159.completeSpan({
                message: "Error in enableWebcam() :: ".concat(_t52.message),
                span: trackSpan,
                status: 2
              });
              if (!(_t52.name === "SecurityError")) {
                _context57.next = 14;
                break;
              }
              errorMessage = errors/* sdkErrors */.q.ERROR_RN_CAMERA_ACCESS_DENIED_OR_DISMISSED;
              _message7 = errorMessage.message;
              this._emitError(errorMessage);
              (_this$_videosdkLogs77 = this._videosdkLogs) === null || _this$_videosdkLogs77 === void 0 || _this$_videosdkLogs77.pushLogs({
                logText: _message7,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableWebcam() :: Camera Permission Denied or Dismissed"
                },
                dashboardLog: true
              });
              (_this$_openTelemetry160 = this._openTelemetry) === null || _this$_openTelemetry160 === void 0 || _this$_openTelemetry160.completeSpan({
                message: "Error in enableWebcam() :: occurred in creating video track, ".concat(_message7),
                span: enableMicSpan,
                status: 2
              });
              _context57.next = 22;
              break;
            case 14:
              if (!(_t52.name === "DOMException")) {
                _context57.next = 15;
                break;
              }
              _errorMessage3 = errors/* sdkErrors */.q.ERROR_RN_CAMERA_NOT_FOUND;
              _message8 = _errorMessage3.message;
              this._emitError(_errorMessage3);
              (_this$_videosdkLogs78 = this._videosdkLogs) === null || _this$_videosdkLogs78 === void 0 || _this$_videosdkLogs78.pushLogs({
                logText: _message8,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableWebcam() :: No Camra Device Found"
                },
                dashboardLog: true
              });
              (_this$_openTelemetry161 = this._openTelemetry) === null || _this$_openTelemetry161 === void 0 || _this$_openTelemetry161.completeSpan({
                message: "Error in enableWebcam() :: occurred in creating video track, ".concat(_message8),
                span: enableMicSpan,
                status: 2
              });
              _context57.next = 22;
              break;
            case 15:
              if (!(_t52 instanceof DOMException)) {
                _context57.next = 21;
                break;
              }
              _t53 = _t52.name;
              _context57.next = _t53 === "NotAllowedError" ? 16 : _t53 === "NotReadableError" ? 17 : _t53 === "NotFoundError" ? 18 : 19;
              break;
            case 16:
              notAllowedErrorData = this.handleNotAllowedError(_t52, this._openTelemetry, this._videosdkLogs, enableWebcamSpan, "video");
              this._emitError(notAllowedErrorData);
              return _context57.abrupt("continue", 20);
            case 17:
              notReadableErrorData = this.handleNotReadableError(_t52, this._openTelemetry, this._videosdkLogs, enableWebcamSpan, "video");
              this._emitError(notReadableErrorData);
              return _context57.abrupt("continue", 20);
            case 18:
              _sdkError3 = errors/* sdkErrors */.q.ERROR_CAMERA_NOT_FOUND;
              if (navigator && navigator.userAgent) {
                if (navigator.userAgent.indexOf("Firefox") != -1) {
                  // Occurs when camera is not accessed by the firefox browser, and user allows camera permission
                  _sdkError3 = errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS;
                }
              }
              _errorMessage4 = _sdkError3.message;
              this._emitError(_sdkError3);
              (_this$_videosdkLogs79 = this._videosdkLogs) === null || _this$_videosdkLogs79 === void 0 || _this$_videosdkLogs79.pushLogs({
                logText: _errorMessage4,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableWebcam() :: No Webcam Device Found"
                },
                dashboardLog: true
              });
              (_this$_openTelemetry162 = this._openTelemetry) === null || _this$_openTelemetry162 === void 0 || _this$_openTelemetry162.completeSpan({
                message: "Error in enableWebcam() :: occurred in creating video track, ".concat(_errorMessage4),
                span: enableWebcamSpan,
                status: 2
              });
              return _context57.abrupt("continue", 20);
            case 19:
              err = "An error occurred in creating video track, ".concat(_t52.message);
              (_this$_videosdkLogs80 = this._videosdkLogs) === null || _this$_videosdkLogs80 === void 0 || _this$_videosdkLogs80.pushLogs({
                logText: _t52.message,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableWebcam() :: ".concat(err)
                },
                dashboardLog: true
              });
              (_this$_openTelemetry163 = this._openTelemetry) === null || _this$_openTelemetry163 === void 0 || _this$_openTelemetry163.completeSpan({
                message: "Error in enableWebcam() :: ".concat(err),
                span: enableWebcamSpan,
                status: 2
              });
              return _context57.abrupt("continue", 20);
            case 20:
              _context57.next = 22;
              break;
            case 21:
              _err2 = "An error occurred in creating video track, ".concat(_t52.message);
              (_this$_videosdkLogs81 = this._videosdkLogs) === null || _this$_videosdkLogs81 === void 0 || _this$_videosdkLogs81.pushLogs({
                logText: _t52.message,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableWebcam() :: ".concat(_err2)
                },
                dashboardLog: true
              });
              (_this$_openTelemetry164 = this._openTelemetry) === null || _this$_openTelemetry164 === void 0 || _this$_openTelemetry164.completeSpan({
                message: "Error in enableWebcam() :: ".concat(_err2),
                span: enableWebcamSpan,
                status: 2
              });
            case 22:
              return _context57.abrupt("return");
            case 23:
              _context57.next = 26;
              break;
            case 24:
              device = {
                label: "external video"
              };
              _context57.next = 25;
              return this._getExternalVideoStream();
            case 25:
              stream = _context57.sent;
              track = stream.getVideoTracks()[0].clone();
            case 26:
              internalSpan = (_this$_openTelemetry165 = this._openTelemetry) === null || _this$_openTelemetry165 === void 0 ? void 0 : _this$_openTelemetry165.trace({
                spanName: "Generating Producer Configuration",
                span: enableWebcamSpan
              });
              codecOptions = {
                videoGoogleStartBitrate: 1000
              };
              if (!this._forceH264) {
                _context57.next = 28;
                break;
              }
              codec = this._mediasoupDevice.rtpCapabilities.codecs.find(function (c) {
                return c.mimeType.toLowerCase() === "video/h264";
              });
              if (codec) {
                _context57.next = 27;
                break;
              }
              _errorMessage5 = "The desired H.264 codec and configuration are not supported";
              throw new Error(_errorMessage5);
            case 27:
              _context57.next = 29;
              break;
            case 28:
              if (!this._forceVP9) {
                _context57.next = 29;
                break;
              }
              codec = this._mediasoupDevice.rtpCapabilities.codecs.find(function (c) {
                return c.mimeType.toLowerCase() === "video/vp9";
              });
              if (codec) {
                _context57.next = 29;
                break;
              }
              _errorMessage6 = "The desired VP9 codec and configuration are not supported";
              throw new Error(_errorMessage6);
            case 29:
              if (track) {
                constraints = track.getConstraints();
                isRNiOS = this._deviceInfo.sdkType == "react-native" && this._deviceInfo.platform == "ios";
                encodings = (0,sdkCapabilities/* computeVideoEncodings */.v7)(false, constraints.width, constraints.height, customVideoTrack.encoderConfig, {
                  simulcast: customVideoTrack.multiStream
                }, isRNiOS);
              } else {
                if (this._useSimulcast) {
                  // If VP9 is the only available video codec then use SVC.
                  firstVideoCodec = this._mediasoupDevice.rtpCapabilities.codecs.find(function (c) {
                    return c.kind === "video";
                  });
                  if (this._forceVP9 && codec || firstVideoCodec.mimeType.toLowerCase() === "video/vp9") {
                    encodings = WEBCAM_KSVC_ENCODINGS;
                  } else {
                    encodings = WEBCAM_SIMULCAST_ENCODINGS[this._webcam.resolution];
                  }
                }
              }
              appData = {};
              try {
                appData = {
                  encodings: encodings,
                  width: customVideoTrack ? (_track2 = track) === null || _track2 === void 0 ? void 0 : _track2.getConstraints().width : VIDEO_CONSTRAINS[resolution].width.ideal,
                  height: customVideoTrack ? (_track3 = track) === null || _track3 === void 0 ? void 0 : _track3.getConstraints().height : VIDEO_CONSTRAINS[resolution].height.ideal
                };
              } catch (error) {
                (_this$_videosdkLogs82 = this._videosdkLogs) === null || _this$_videosdkLogs82 === void 0 || _this$_videosdkLogs82.pushLogs({
                  logText: error.message,
                  logType: "INFO",
                  attributes: {
                    error: "In enableWebcam() :: ".concat(error.message)
                  },
                  dashboardLog: true
                });
                console.log(error);
              }
              (_this$_openTelemetry166 = this._openTelemetry) === null || _this$_openTelemetry166 === void 0 || _this$_openTelemetry166.traceAutoComplete({
                spanName: "Track Generated with height ".concat(appData.height, " and width ").concat(appData.width, " with multiStream ").concat(this._useSimulcast),
                attributes: {
                  appData: JSON.stringify(appData)
                },
                span: enableWebcamSpan,
                status: 1
              });
              (_this$_openTelemetry167 = this._openTelemetry) === null || _this$_openTelemetry167 === void 0 || _this$_openTelemetry167.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Producer Configuration Generated"
              });
              internalSpan = (_this$_openTelemetry168 = this._openTelemetry) === null || _this$_openTelemetry168 === void 0 ? void 0 : _this$_openTelemetry168.trace({
                spanName: "Creating Webcam Producer",
                span: enableWebcamSpan
              });
              if (!this._sendTransport) {
                _context57.next = 31;
                break;
              }
              _context57.next = 30;
              return this._sendTransport.produce({
                track: track,
                encodings: encodings,
                codecOptions: codecOptions,
                codec: codec,
                appData: RoomClient_objectSpread(RoomClient_objectSpread({}, appData), {}, {
                  isEncrypted: this.isE2EEEnabled
                }),
                onRtpSender: function onRtpSender(rtpSender) {
                  if (_this4.e2eeManager) {
                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                  }
                }
              });
            case 30:
              this._webcamProducer = _context57.sent;
              if (this.e2eeManager) {
                this.e2eeManager.emit("NEW_PRODUCER", this._webcamProducer);
              }
              _context57.next = 32;
              break;
            case 31:
              (_this$_videosdkLogs83 = this._videosdkLogs) === null || _this$_videosdkLogs83 === void 0 || _this$_videosdkLogs83.pushLogs({
                logText: errors/* sdkErrors */.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED.message,
                attributes: {
                  error: "Error in enableWebcam() :: Transport is not setup"
                },
                logType: "ERROR",
                dashboardLog: true
              });
              this._emitError(errors/* sdkErrors */.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED);
              return _context57.abrupt("return");
            case 32:
              if (track.getConstraints().deviceId) {
                this._webcam.device = this._webcams.get(track.getConstraints().deviceId);
              }
              if (this._webcamProducer) {
                action = addProducer({
                  id: this._webcamProducer.id,
                  deviceLabel: device.label,
                  type: this._getWebcamType(device),
                  paused: this._webcamProducer.paused,
                  track: this._webcamProducer.track,
                  rtpParameters: this._webcamProducer.rtpParameters,
                  codec: this._webcamProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                  instance: this._webcamProducer,
                  rtpSender: this._webcamProducer.rtpSender
                });
                store.dispatch(action);
                this._eventEmitter.emit(action.type, action.payload);
                // Stats are moved to the send transport,
                // since they are not available in React Native.

                // let reportCounter = 0;
                // let probe = this._metrics.addNewProbe(this._webcamProducer, "producer");
                // probe.onStatsCollected = (report) => {
                //   try {
                //     if (!this._stats.producerStats) {
                //       this._stats.producerStats = {};
                //     }

                //     if (!this._stats.producerStats["video"]) {
                //       this._stats.producerStats["video"] = [];
                //     }

                //     if (this._webcamProducer) {
                //       this._latestStats[this._webcamProducer?.id] = [];
                //     }

                //     report["video"].forEach((stat) => {
                //       this._latestStats[this._webcamProducer?.id].push(stat);
                //     });

                //     if (reportCounter % 5 == 0 && this._webcamProducer != null) {
                //       this._stats["producerStats"]["video"].push({
                //         timestamp: new Date(),
                //         stats: this._latestStats[this._webcamProducer.id],
                //       });
                //     }

                //     reportCounter++;
                //   } catch (error) {
                //     this._videosdkLogs?.pushLogs({
                //       logText: `Error PRODUCER Stats ERROR`,
                //       logType: "ERROR",
                //       attributes: {
                //         error: error.message,
                //       },
                //     });
                //     // console.log("PRODUCER ERROR", error);
                //   }
                // };
                // probe.start();

                // this._webcamProducer.observer.on("close", () => {
                //   probe.stop();
                //   this._metrics.removeExistingProbe(probe);
                // });

                this._webcamProducer.on("transportclose", function () {
                  var _this4$_webcamProduce;
                  var action = removeProducer(_this4._webcamProducer.id);
                  store.dispatch(action);
                  _this4._eventEmitter.emit(action.type, action.payload);

                  // this._webcamEnabled = false;
                  (_this4$_webcamProduce = _this4._webcamProducer) === null || _this4$_webcamProduce === void 0 || _this4$_webcamProduce.close();
                  _this4._webcamProducer = null;
                });
                this._webcamProducer.on("trackended", function () {
                  var _this4$_videosdkLogs, _this4$_openTelemetry;
                  var error = _this4._deviceInfo.sdkType == "react-native" ? errors/* sdkErrors */.q.ERROR_RN_CAMERA_TRACK_ENDED : errors/* sdkErrors */.q.ERROR_WEBCAM_TRACK_ENDED;
                  (_this4$_videosdkLogs = _this4._videosdkLogs) === null || _this4$_videosdkLogs === void 0 || _this4$_videosdkLogs.pushLogs({
                    logText: error.message,
                    logType: "ERROR",
                    attributes: {
                      error: "Error in enableWebcam() :: ".concat(error.message)
                    },
                    dashboardLog: true
                  });
                  (_this4$_openTelemetry = _this4._openTelemetry) === null || _this4$_openTelemetry === void 0 || _this4$_openTelemetry.traceAutoComplete({
                    spanName: "this._webcamProducer trackended or Webcam disconnected!",
                    span: enableWebcamSpan,
                    message: error.message,
                    status: 2
                  });
                  store.dispatch(notify({
                    type: "error",
                    text: "Webcam disconnected!"
                  }));
                  // INFO: Some of customer repeatedly getting events whenever they disconnect webcam device
                  // this._emitError(error);

                  _this4.disableWebcam(enableWebcamSpan)["catch"](function () {});
                });
                (_this$_openTelemetry169 = this._openTelemetry) === null || _this$_openTelemetry169 === void 0 || _this$_openTelemetry169.completeSpan({
                  span: internalSpan,
                  status: 1,
                  message: "Webcam Producer Created"
                });
                (_this$_openTelemetry170 = this._openTelemetry) === null || _this$_openTelemetry170 === void 0 || _this$_openTelemetry170.completeSpan({
                  span: enableWebcamSpan,
                  status: 1,
                  message: "Enable Webcam Successful"
                });
              } else {
                (_this$_videosdkLogs84 = this._videosdkLogs) === null || _this$_videosdkLogs84 === void 0 || _this$_videosdkLogs84.pushLogs({
                  logText: "Oops! Something went wrong, and we're unable to enable the webcam. Please try again.",
                  logType: "ERROR",
                  attributes: {
                    error: "Error in enableWebcam(): Something went wrong."
                  },
                  dashboardLog: true
                });
                (_this$_openTelemetry171 = this._openTelemetry) === null || _this$_openTelemetry171 === void 0 || _this$_openTelemetry171.completeSpan({
                  span: internalSpan,
                  status: 2,
                  message: "Error in enableWebcam() :: webcamProducer null"
                });
                (_this$_openTelemetry172 = this._openTelemetry) === null || _this$_openTelemetry172 === void 0 || _this$_openTelemetry172.completeSpan({
                  span: enableWebcamSpan,
                  status: 2,
                  message: "Error in enableWebcam() :: webcamProducer null"
                });
              }
              _context57.next = 35;
              break;
            case 33:
              _context57.prev = 33;
              _t54 = _context57["catch"](5);
              (_this$_videosdkLogs85 = this._videosdkLogs) === null || _this$_videosdkLogs85 === void 0 || _this$_videosdkLogs85.pushLogs({
                logText: _t54.message,
                logType: "ERROR",
                attributes: {
                  error: "Error in enableWebcam() :: ".concat(_t54.message)
                },
                dashboardLog: true
              });
              (_this$_openTelemetry173 = this._openTelemetry) === null || _this$_openTelemetry173 === void 0 || _this$_openTelemetry173.completeSpan({
                span: enableWebcamSpan,
                status: 2,
                message: "Error in enableWebcam() :: ".concat(_t54.message)
              });
              store.dispatch(notify({
                type: "error",
                text: "Error enabling webcam: ".concat(_t54)
              }));
              _context57.next = 34;
              return this._socketRequest("produceError", {
                mediaType: "video",
                message: _t54.message
              });
            case 34:
              if (track) track.stop();
            case 35:
              store.dispatch(setWebcamInProgress(false));
            case 36:
            case "end":
              return _context57.stop();
          }
        }, _callee57, this, [[5, 33], [8, 13]]);
      }));
      function enableWebcam() {
        return _enableWebcam.apply(this, arguments);
      }
      return enableWebcam;
    }()
  }, {
    key: "handleNotAllowedError",
    value: function handleNotAllowedError(error, openTelemetry, videosdkLogs, parentSpan, mediaType) {
      var err = {};
      if (error.message === "Permission denied" || error.message === "Permission dismissed") {
        err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_CAMERA_ACCESS_DENIED_OR_DISMISSED : errors/* sdkErrors */.q.ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED;
      } else if (error.message.includes("The request is not allowed by the user agent")) {
        // This occurs when the user denies permission in the Firefox browser
        err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_OR_AUTOPLAY_ISSUE : errors/* sdkErrors */.q.ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED;
      } else if (error.message === "Permission denied by system") {
        err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS : errors/* sdkErrors */.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS;
      } else {
        err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED : errors/* sdkErrors */.q.ERROR_GET_AUDIO_MEDIA_PERMISSION_DENIED;
      }
      videosdkLogs.pushLogs({
        logText: err.message,
        logType: "ERROR",
        attributes: {
          error: "Error in ".concat(mediaType === "video" ? "enableWebcam()" : "enableMic()", " :: ").concat(error.message)
        },
        dashboardLog: true
      });
      openTelemetry.completeSpan({
        message: mediaType === "video" ? "Error in enableWebcam() :: occurred in creating video track, ".concat(err.message) : "Error in enableMic() :: occurred in creating audio track, ".concat(err.message),
        span: parentSpan,
        status: 2
      });
      return err;
    }
  }, {
    key: "handleNotReadableError",
    value: function handleNotReadableError(error, openTelemetry, videosdkLogs, parentSpan, mediaType) {
      var err = {};
      if (error.message === "Device in use") {
        err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_CAMERA_IN_USE : errors/* sdkErrors */.q.ERROR_MICROPHONE_IN_USE;
      } else {
        err = mediaType === "video" ? errors/* sdkErrors */.q.ERROR_VIDEO_SOURCE_INITIATION_FAILED : errors/* sdkErrors */.q.ERROR_MICROPHONE_IN_USE;
      }
      videosdkLogs.pushLogs({
        logText: err.message,
        logType: "ERROR",
        attributes: {
          error: "Error in ".concat(mediaType === "video" ? "enableWebcam()" : "enableMic()", " :: ").concat(error.message)
        },
        dashboardLog: true
      });
      openTelemetry.completeSpan({
        message: mediaType === "video" ? "Error in enableWebcam() :: occurred in creating video track, ".concat(err.message) : "Error in enableMic() :: occurred in creating audio track, ".concat(err.message),
        span: parentSpan,
        status: 2
      });
      return err;
    }
  }, {
    key: "disableWebcam",
    value: function () {
      var _disableWebcam = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee58() {
        var _this$_openTelemetry174, _this$_openTelemetry176;
        var parentSpan,
          disableWebcamSpan,
          _this$_openTelemetry175,
          _this$_videosdkLogs86,
          internalSpan,
          action,
          _this$_openTelemetry177,
          _this$_openTelemetry178,
          _this$_videosdkLogs87,
          _this$_openTelemetry179,
          _this$_openTelemetry180,
          _args58 = arguments,
          _t55;
        return regenerator_default().wrap(function (_context58) {
          while (1) switch (_context58.prev = _context58.next) {
            case 0:
              parentSpan = _args58.length > 0 && _args58[0] !== undefined ? _args58[0] : undefined;
              disableWebcamSpan = (_this$_openTelemetry174 = this._openTelemetry) === null || _this$_openTelemetry174 === void 0 ? void 0 : _this$_openTelemetry174.trace({
                spanName: "disableWebcam() Calling",
                status: 1,
                span: parentSpan ? parentSpan : null
              });
              logger.debug("disableWebcam()");
              this._webcamEnabled = false;
              if (this._webcamProducer) {
                _context58.next = 1;
                break;
              }
              (_this$_openTelemetry175 = this._openTelemetry) === null || _this$_openTelemetry175 === void 0 || _this$_openTelemetry175.completeSpan({
                span: disableWebcamSpan,
                status: 2,
                message: "Error in disableWebcam() :: Webcam Producer Not found"
              });
              (_this$_videosdkLogs86 = this._videosdkLogs) === null || _this$_videosdkLogs86 === void 0 || _this$_videosdkLogs86.pushLogs({
                logText: "Attempted to call disableWebcam() multiple times",
                attributes: {
                  error: "Error in disableWebcam() :: Webcam is already disabled"
                },
                logType: "ERROR",
                dashboardLog: true
              });
              return _context58.abrupt("return");
            case 1:
              internalSpan = (_this$_openTelemetry176 = this._openTelemetry) === null || _this$_openTelemetry176 === void 0 ? void 0 : _this$_openTelemetry176.trace({
                spanName: "Closing Webcam Producer",
                span: disableWebcamSpan,
                status: 1
              });
              this._webcamProducer.close();
              action = removeProducer(this._webcamProducer.id);
              store.dispatch(action);
              this._eventEmitter.emit(action.type, action.payload);
              _context58.prev = 2;
              _context58.next = 3;
              return this._socketRequest("closeProducer", {
                producerId: this._webcamProducer.id
              });
            case 3:
              (_this$_openTelemetry177 = this._openTelemetry) === null || _this$_openTelemetry177 === void 0 || _this$_openTelemetry177.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Requested Server to Close Producer"
              });
              this._webcamProducer = null;
              (_this$_openTelemetry178 = this._openTelemetry) === null || _this$_openTelemetry178 === void 0 || _this$_openTelemetry178.completeSpan({
                span: disableWebcamSpan,
                status: 1,
                message: "Webcam Disabled Successfully"
              });
              _context58.next = 5;
              break;
            case 4:
              _context58.prev = 4;
              _t55 = _context58["catch"](2);
              (_this$_videosdkLogs87 = this._videosdkLogs) === null || _this$_videosdkLogs87 === void 0 || _this$_videosdkLogs87.pushLogs({
                logText: "Error in disableWebcam() :: Failed to close server-side webcam producer",
                logType: "ERROR",
                attributes: {
                  error: _t55.message
                },
                dashboardLog: true
              });
              (_this$_openTelemetry179 = this._openTelemetry) === null || _this$_openTelemetry179 === void 0 || _this$_openTelemetry179.completeSpan({
                span: internalSpan,
                status: 2,
                message: "Error in disableWebcam() :: closing server-side webcam Producer: ".concat(_t55)
              });
              (_this$_openTelemetry180 = this._openTelemetry) === null || _this$_openTelemetry180 === void 0 || _this$_openTelemetry180.completeSpan({
                span: disableWebcamSpan,
                status: 2,
                message: "Error in disableWebcam() :: closing server-side webcam Producer: ".concat(_t55)
              });
              store.dispatch(notify({
                type: "error",
                text: "Error closing server-side webcam Producer: ".concat(_t55)
              }));
            case 5:
            case "end":
              return _context58.stop();
          }
        }, _callee58, this, [[2, 4]]);
      }));
      function disableWebcam() {
        return _disableWebcam.apply(this, arguments);
      }
      return disableWebcam;
    }()
    /**
     *
     * @returns {Array<{deviceId: string, label: string}>}
     */
  }, {
    key: "getMics",
    value: (function () {
      var _getMics = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee59() {
        var micArr, _this$_videosdkLogs88, _t56;
        return regenerator_default().wrap(function (_context59) {
          while (1) switch (_context59.prev = _context59.next) {
            case 0:
              micArr = [];
              _context59.prev = 1;
              _context59.next = 2;
              return this._updateMics();
            case 2:
              this._mics.forEach(function (value, key) {
                micArr.push({
                  deviceId: key,
                  label: value.label
                });
              });
              _context59.next = 4;
              break;
            case 3:
              _context59.prev = 3;
              _t56 = _context59["catch"](1);
              logger.error("getMics() | Error", _t56);
              (_this$_videosdkLogs88 = this._videosdkLogs) === null || _this$_videosdkLogs88 === void 0 || _this$_videosdkLogs88.pushLogs({
                logText: _t56.message,
                logType: "ERROR",
                attributes: {
                  error: "Error in getMics() :: Not able to get Mic List"
                },
                dashboardLog: true
              });
            case 4:
              return _context59.abrupt("return", micArr);
            case 5:
            case "end":
              return _context59.stop();
          }
        }, _callee59, this, [[1, 3]]);
      }));
      function getMics() {
        return _getMics.apply(this, arguments);
      }
      return getMics;
    }() // @type of object = string means micId is passed
    // @type of object = object means customTrack is passed
    )
  }, {
    key: "changeMic",
    value: function () {
      var _changeMic = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee60(object) {
        var _this$_openTelemetry181;
        var changeMicSpan, _this$_openTelemetry182, _this$_openTelemetry183, _this$_openTelemetry184, micId, array, len, deviceId, idx, internalSpan, _this$_videosdkLogs89, _this$_openTelemetry185, _this$_videosdkLogs90, _t57;
        return regenerator_default().wrap(function (_context60) {
          while (1) switch (_context60.prev = _context60.next) {
            case 0:
              changeMicSpan = (_this$_openTelemetry181 = this._openTelemetry) === null || _this$_openTelemetry181 === void 0 ? void 0 : _this$_openTelemetry181.trace({
                spanName: "changeMic() Calling"
              });
              _context60.prev = 1;
              if (!((0,esm_typeof/* default */.A)(object) == "object")) {
                _context60.next = 4;
                break;
              }
              _context60.next = 2;
              return this.disableMic(true, changeMicSpan);
            case 2:
              _context60.next = 3;
              return this.enableMic(object, changeMicSpan);
            case 3:
              _context60.next = 9;
              break;
            case 4:
              micId = object;
              _context60.next = 5;
              return this._updateMics();
            case 5:
              //generate Array
              array = Array.from(this._mics.keys());
              len = array.length;
              deviceId = this._mic.device ? this._mic.device.deviceId : undefined;
              if (micId != undefined && micId != null) {
                idx = array.indexOf(micId);
              } else {
                idx = array.indexOf(deviceId);
                if (idx < len - 1) idx++;else idx = 0;
              }
              this._mic.device = this._mics.get(array[idx]);
              internalSpan = (_this$_openTelemetry182 = this._openTelemetry) === null || _this$_openTelemetry182 === void 0 ? void 0 : _this$_openTelemetry182.trace({
                spanName: "Getting Selected Mic",
                span: changeMicSpan,
                attributes: {
                  selectedWebcam: this._mic.device ? JSON.stringify(this._mic.device) : "No Mic devices"
                }
              });
              if (this._mic.device) {
                _context60.next = 6;
                break;
              }
              (_this$_videosdkLogs89 = this._videosdkLogs) === null || _this$_videosdkLogs89 === void 0 || _this$_videosdkLogs89.pushLogs({
                logText: "Error changeMic : No mic Found",
                logType: "ERROR"
              });
              throw new Error("No mic Found");
            case 6:
              _context60.next = 7;
              return this.disableMic(true, changeMicSpan);
            case 7:
              _context60.next = 8;
              return this.enableMic(undefined, changeMicSpan);
            case 8:
              (_this$_openTelemetry183 = this._openTelemetry) === null || _this$_openTelemetry183 === void 0 || _this$_openTelemetry183.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Done"
              });
              (_this$_openTelemetry184 = this._openTelemetry) === null || _this$_openTelemetry184 === void 0 || _this$_openTelemetry184.completeSpan({
                span: changeMicSpan,
                status: 1,
                message: "changeMic() Ending"
              });
            case 9:
              _context60.next = 11;
              break;
            case 10:
              _context60.prev = 10;
              _t57 = _context60["catch"](1);
              (_this$_openTelemetry185 = this._openTelemetry) === null || _this$_openTelemetry185 === void 0 || _this$_openTelemetry185.completeSpan({
                span: changeMicSpan,
                status: 2,
                message: "changeMic() | Error ".concat(_t57)
              });
              (_this$_videosdkLogs90 = this._videosdkLogs) === null || _this$_videosdkLogs90 === void 0 || _this$_videosdkLogs90.pushLogs({
                logText: "Error changeMic() | Error",
                logType: "ERROR",
                attributes: {
                  error: _t57.message
                }
              });
            case 11:
            case "end":
              return _context60.stop();
          }
        }, _callee60, this, [[1, 10]]);
      }));
      function changeMic(_x61) {
        return _changeMic.apply(this, arguments);
      }
      return changeMic;
    }()
    /**
     *
     * @returns {Array<{deviceId: string, label: string, facingMode: "environment" | "front"}>}
     */
  }, {
    key: "getWebcams",
    value: (function () {
      var _getWebcams = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee61() {
        var webcamArr, _this$_videosdkLogs91, _t58;
        return regenerator_default().wrap(function (_context61) {
          while (1) switch (_context61.prev = _context61.next) {
            case 0:
              webcamArr = [];
              _context61.prev = 1;
              _context61.next = 2;
              return this._updateWebcams();
            case 2:
              this._webcams.forEach(function (value, key) {
                webcamArr.push({
                  deviceId: key,
                  label: value.label,
                  facingMode: value.facing || "environment"
                });
              });
              _context61.next = 4;
              break;
            case 3:
              _context61.prev = 3;
              _t58 = _context61["catch"](1);
              logger.error("getWebcams() | failed %o", _t58);
              (_this$_videosdkLogs91 = this._videosdkLogs) === null || _this$_videosdkLogs91 === void 0 || _this$_videosdkLogs91.pushLogs({
                logText: _t58.message,
                logType: "ERROR",
                attributes: {
                  error: "Error in getWebcams() :: Not able to get Webcam List"
                },
                dashboardLog: true
              });
            case 4:
              return _context61.abrupt("return", webcamArr);
            case 5:
            case "end":
              return _context61.stop();
          }
        }, _callee61, this, [[1, 3]]);
      }));
      function getWebcams() {
        return _getWebcams.apply(this, arguments);
      }
      return getWebcams;
    }())
  }, {
    key: "replaceWebcamStream",
    value: function () {
      var _replaceWebcamStream = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee62(stream) {
        var track;
        return regenerator_default().wrap(function (_context62) {
          while (1) switch (_context62.prev = _context62.next) {
            case 0:
              if (!this._webcamProducer) {
                _context62.next = 2;
                break;
              }
              track = stream.getVideoTracks()[0];
              _context62.next = 1;
              return this._webcamProducer.replaceTrack({
                track: track
              });
            case 1:
              this._eventEmitter.emit("UPDATE_PRODUCER", {
                producer: this._webcamProducer
              });
              _context62.next = 4;
              break;
            case 2:
              _context62.next = 3;
              return this.disableWebcam();
            case 3:
              _context62.next = 4;
              return this.enableWebcam(stream);
            case 4:
            case "end":
              return _context62.stop();
          }
        }, _callee62, this);
      }));
      function replaceWebcamStream(_x62) {
        return _replaceWebcamStream.apply(this, arguments);
      }
      return replaceWebcamStream;
    }() // @type of object = string means webcamId is passed
    // @type of object = object means customTrack is passed
  }, {
    key: "changeWebcam",
    value: function () {
      var _changeWebcam = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee63(object) {
        var _this$_openTelemetry186;
        var changeWebcamSpan, _this$_videosdkLogs92, _this$_openTelemetry187, _this$_openTelemetry188, _this$_openTelemetry189, array, len, deviceId, idx, internalSpan, _this$_videosdkLogs93, _this$_videosdkLogs94, _this$_openTelemetry190, _t59, _t60;
        return regenerator_default().wrap(function (_context63) {
          while (1) switch (_context63.prev = _context63.next) {
            case 0:
              changeWebcamSpan = (_this$_openTelemetry186 = this._openTelemetry) === null || _this$_openTelemetry186 === void 0 ? void 0 : _this$_openTelemetry186.trace({
                spanName: "changeWebcam() Calling"
              });
              store.dispatch(setWebcamInProgress(true));
              if (!((0,esm_typeof/* default */.A)(object) === "object")) {
                _context63.next = 6;
                break;
              }
              _context63.prev = 1;
              _context63.next = 2;
              return this.disableWebcam(changeWebcamSpan);
            case 2:
              _context63.next = 3;
              return this.enableWebcam(object, changeWebcamSpan);
            case 3:
              _context63.next = 5;
              break;
            case 4:
              _context63.prev = 4;
              _t59 = _context63["catch"](1);
              logger.error("changeWebcam() | failed: %o", _t59);
              (_this$_videosdkLogs92 = this._videosdkLogs) === null || _this$_videosdkLogs92 === void 0 || _this$_videosdkLogs92.pushLogs({
                logText: "Error Could not change webcam",
                logType: "ERROR",
                attributes: {
                  object: JSON.stringify(object),
                  error: _t59.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Could not change webcam: ".concat(_t59)
              }));
            case 5:
              _context63.next = 12;
              break;
            case 6:
              _context63.prev = 6;
              _context63.next = 7;
              return this._updateWebcams(changeWebcamSpan);
            case 7:
              array = Array.from(this._webcams.keys());
              len = array.length;
              deviceId = this._webcam.device ? this._webcam.device.deviceId : undefined;
              if (object != null && object != undefined) {
                idx = array.indexOf(object);
              } else {
                idx = array.indexOf(deviceId);
                if (idx < len - 1) idx++;else idx = 0;
              }
              this._webcam.device = this._webcams.get(array[idx]);
              logger.debug("changeWebcam() | new selected webcam [device:%o]", this._webcam.device);

              // Reset video resolution to HD.
              this._webcam.resolution = this._webcam.resolution || "hd";
              internalSpan = (_this$_openTelemetry187 = this._openTelemetry) === null || _this$_openTelemetry187 === void 0 ? void 0 : _this$_openTelemetry187.trace({
                spanName: "Getting Selected Webcam",
                span: changeWebcamSpan,
                attributes: {
                  selectedWebcam: this._webcam.device ? JSON.stringify(this._webcam.device) : "No webcam devices"
                }
              });
              if (this._webcam.device) {
                _context63.next = 8;
                break;
              }
              (_this$_videosdkLogs93 = this._videosdkLogs) === null || _this$_videosdkLogs93 === void 0 || _this$_videosdkLogs93.pushLogs({
                logText: "Error changeWebcam : No webcam Found",
                logType: "ERROR"
              });
              throw new Error("no webcam devices");
            case 8:
              _context63.next = 9;
              return this.disableWebcam(changeWebcamSpan);
            case 9:
              _context63.next = 10;
              return this.enableWebcam(undefined, changeWebcamSpan);
            case 10:
              (_this$_openTelemetry188 = this._openTelemetry) === null || _this$_openTelemetry188 === void 0 || _this$_openTelemetry188.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Done"
              });
              (_this$_openTelemetry189 = this._openTelemetry) === null || _this$_openTelemetry189 === void 0 || _this$_openTelemetry189.completeSpan({
                span: changeWebcamSpan,
                status: 1,
                message: "changeWebcam() Ending"
              });
              return _context63.abrupt("return");
            case 11:
              _context63.prev = 11;
              _t60 = _context63["catch"](6);
              logger.error("changeWebcam() | failed: %o", _t60);
              (_this$_videosdkLogs94 = this._videosdkLogs) === null || _this$_videosdkLogs94 === void 0 || _this$_videosdkLogs94.pushLogs({
                logText: "Error Could not change webcam",
                logType: "ERROR",
                attributes: {
                  object: JSON.stringify(object),
                  error: _t60.message
                }
              });
              (_this$_openTelemetry190 = this._openTelemetry) === null || _this$_openTelemetry190 === void 0 || _this$_openTelemetry190.completeSpan({
                span: changeWebcamSpan,
                status: 2,
                message: "Could not change webcam ".concat(_t60)
              });
              store.dispatch(notify({
                type: "error",
                text: "Could not change webcam: ".concat(_t60)
              }));
            case 12:
              store.dispatch(setWebcamInProgress(false));
            case 13:
            case "end":
              return _context63.stop();
          }
        }, _callee63, this, [[1, 4], [6, 11]]);
      }));
      function changeWebcam(_x63) {
        return _changeWebcam.apply(this, arguments);
      }
      return changeWebcam;
    }()
  }, {
    key: "changeWebcamResolution",
    value: function () {
      var _changeWebcamResolution = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee64() {
        var stream, _this$_videosdkLogs95, track, _this$_videosdkLogs96, _t61, _t62, _t63;
        return regenerator_default().wrap(function (_context64) {
          while (1) switch (_context64.prev = _context64.next) {
            case 0:
              logger.debug("changeWebcamResolution()");
              store.dispatch(setWebcamInProgress(true));
              _context64.prev = 1;
              _t61 = this._webcam.resolution;
              _context64.next = _t61 === "qvga" ? 2 : _t61 === "vga" ? 3 : _t61 === "hd" ? 4 : 5;
              break;
            case 2:
              this._webcam.resolution = "vga";
              return _context64.abrupt("continue", 6);
            case 3:
              this._webcam.resolution = "hd";
              return _context64.abrupt("continue", 6);
            case 4:
              this._webcam.resolution = "qvga";
              return _context64.abrupt("continue", 6);
            case 5:
              this._webcam.resolution = "hd";
            case 6:
              logger.debug("changeWebcamResolution() | calling getUserMedia()");
              _context64.prev = 7;
              _context64.next = 8;
              return navigator.mediaDevices.getUserMedia({
                video: RoomClient_objectSpread({
                  deviceId: {
                    exact: this._webcam.device.deviceId
                  }
                }, VIDEO_CONSTRAINS[this._webcam.resolution])
              });
            case 8:
              stream = _context64.sent;
              _context64.next = 10;
              break;
            case 9:
              _context64.prev = 9;
              _t62 = _context64["catch"](7);
              (_this$_videosdkLogs95 = this._videosdkLogs) === null || _this$_videosdkLogs95 === void 0 || _this$_videosdkLogs95.pushLogs({
                logText: "Error in getUserMedia for changeWebcamResolution",
                logType: "ERROR",
                attributes: {
                  error: JSON.stringify(_t62)
                }
              });
              if (_t62.message === "Permission denied" || _t62.name === "NotAllowedError") {
                this._emitError(errors/* sdkErrors */.q.ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED);
              } else {
                this._emitError(errors/* sdkErrors */.q.ERROR_GET_VIDEO_MEDIA);
              }
              return _context64.abrupt("return");
            case 10:
              track = stream.getVideoTracks()[0];
              _context64.next = 11;
              return this._webcamProducer.replaceTrack({
                track: track
              });
            case 11:
              store.dispatch(setProducerTrack(this._webcamProducer.id, track));
              _context64.next = 13;
              break;
            case 12:
              _context64.prev = 12;
              _t63 = _context64["catch"](1);
              logger.error("changeWebcamResolution() | failed: %o", _t63);
              (_this$_videosdkLogs96 = this._videosdkLogs) === null || _this$_videosdkLogs96 === void 0 || _this$_videosdkLogs96.pushLogs({
                logText: "Error Could not change webcam resolution",
                logType: "ERROR",
                attributes: {
                  error: _t63.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Could not change webcam resolution: ".concat(_t63)
              }));
            case 13:
              store.dispatch(setWebcamInProgress(false));
            case 14:
            case "end":
              return _context64.stop();
          }
        }, _callee64, this, [[1, 12], [7, 9]]);
      }));
      function changeWebcamResolution() {
        return _changeWebcamResolution.apply(this, arguments);
      }
      return changeWebcamResolution;
    }()
  }, {
    key: "enableShare",
    value: function () {
      var _enableShare = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee65() {
        var _this$_openTelemetry191,
          _this5 = this;
        var customScreenSharingTrack,
          enableShareSpan,
          _this$_openTelemetry192,
          _this$_openTelemetry193,
          videoTrack,
          audioTrack,
          encodings,
          _this$_openTelemetry194,
          _this$_openTelemetry198,
          _this$_openTelemetry199,
          _this$_openTelemetry200,
          _this$_openTelemetry201,
          _this$_openTelemetry204,
          trackSpan,
          _videoTrack$getConstr,
          height,
          frameRate,
          screenShareProfilesData,
          simulcastEncodings,
          _this$_openTelemetry197,
          stream,
          _this$_videosdkLogs97,
          _this$_openTelemetry195,
          _this$_openTelemetry196,
          internalSpan,
          codec,
          codecOptions,
          _this$_videosdkLogs98,
          _this$_videosdkLogs99,
          action,
          _this$_openTelemetry202,
          _this$_openTelemetry203,
          audioCodecOptions,
          _action8,
          _this$_videosdkLogs100,
          _this$_openTelemetry205,
          _this$_videosdkLogs101,
          _args65 = arguments,
          _t64,
          _t65,
          _t66;
        return regenerator_default().wrap(function (_context65) {
          while (1) switch (_context65.prev = _context65.next) {
            case 0:
              customScreenSharingTrack = _args65.length > 0 && _args65[0] !== undefined ? _args65[0] : undefined;
              enableShareSpan = (_this$_openTelemetry191 = this._openTelemetry) === null || _this$_openTelemetry191 === void 0 ? void 0 : _this$_openTelemetry191.trace({
                spanName: "enableShare() Calling ".concat(!!customScreenSharingTrack ? "With Custom Video Track" : "Without Custom Video Track "),
                attributes: {
                  customShareConfig: customScreenSharingTrack ? JSON.stringify(customScreenSharingTrack) : "Not Specify Custom Track"
                }
              });
              logger.debug("enableShare()");
              if (!this._shareProducer) {
                _context65.next = 1;
                break;
              }
              (_this$_openTelemetry192 = this._openTelemetry) === null || _this$_openTelemetry192 === void 0 || _this$_openTelemetry192.completeSpan({
                span: enableShareSpan,
                status: 2,
                message: "Screen Share Producer found"
              });
              return _context65.abrupt("return");
            case 1:
              if (this._mediasoupDevice.canProduce("video")) {
                _context65.next = 2;
                break;
              }
              (_this$_openTelemetry193 = this._openTelemetry) === null || _this$_openTelemetry193 === void 0 || _this$_openTelemetry193.completeSpan({
                span: enableShareSpan,
                status: 2,
                message: "enableShare() | cannot produce video"
              });
              logger.error("enableShare() | cannot produce video");
              return _context65.abrupt("return");
            case 2:
              encodings = [];
              store.dispatch(setShareInProgress(true));
              _context65.prev = 3;
              logger.debug("enableShare() | calling getUserMedia()");
              trackSpan = (_this$_openTelemetry194 = this._openTelemetry) === null || _this$_openTelemetry194 === void 0 ? void 0 : _this$_openTelemetry194.trace({
                spanName: "Creating Track",
                span: enableShareSpan
              });
              if (!(customScreenSharingTrack && customScreenSharingTrack.active)) {
                _context65.next = 4;
                break;
              }
              videoTrack = customScreenSharingTrack.getVideoTracks()[0];
              audioTrack = customScreenSharingTrack.getAudioTracks()[0];
              if (customScreenSharingTrack.multiStream) {
                _videoTrack$getConstr = videoTrack.getConstraints(), height = _videoTrack$getConstr.height, frameRate = _videoTrack$getConstr.frameRate;
                screenShareProfilesData = config/* config */.$.screenShareProfiles["h".concat(height, "p_").concat(frameRate, "fps")]; // Dynamic simulcast encodings based on profile
                simulcastEncodings = [{
                  maxBitrate: screenShareProfilesData.bitrates.high,
                  maxFramerate: frameRate,
                  scalabilityMode: "S3T3",
                  dtx: true
                }, {
                  maxBitrate: screenShareProfilesData.bitrates.medium,
                  maxFramerate: frameRate,
                  scalabilityMode: "S2T3",
                  dtx: true
                }, {
                  maxBitrate: screenShareProfilesData.bitrates.low,
                  maxFramerate: frameRate,
                  scalabilityMode: "S1T3",
                  dtx: true
                }];
                encodings = simulcastEncodings;
              } else {
                encodings = SCREEN_SHARING_SIMULCAST_ENCODINGS;
              }
              _context65.next = 9;
              break;
            case 4:
              _context65.prev = 4;
              _context65.next = 5;
              return navigator.mediaDevices.getDisplayMedia({
                audio: true,
                video: {
                  width: {
                    max: 1920
                  },
                  height: {
                    max: 1080
                  },
                  frameRate: {
                    max: 10
                  }
                }
              });
            case 5:
              stream = _context65.sent;
              _context65.next = 7;
              break;
            case 6:
              _context65.prev = 6;
              _t64 = _context65["catch"](4);
              (_this$_videosdkLogs97 = this._videosdkLogs) === null || _this$_videosdkLogs97 === void 0 || _this$_videosdkLogs97.pushLogs({
                logText: "Error in getDisplayMedia for screen share",
                logType: "ERROR",
                attributes: {
                  error: JSON.stringify(_t64)
                }
              });
              (_this$_openTelemetry195 = this._openTelemetry) === null || _this$_openTelemetry195 === void 0 || _this$_openTelemetry195.completeSpan({
                span: enableShareSpan,
                status: 2,
                message: "Error in getDisplayMedia for screen share ".concat(_t64)
              });
              if (_t64.message === "Permission denied" || _t64.name === "NotAllowedError") {
                this._emitError(errors/* sdkErrors */.q.ERROR_GET_DISPLAY_MEDIA_PERMISSION_DENIED);
              } else {
                this._emitError(errors/* sdkErrors */.q.ERROR_GET_DISPLAY_MEDIA);
              }
              return _context65.abrupt("return");
            case 7:
              if (stream) {
                _context65.next = 8;
                break;
              }
              store.dispatch(setShareInProgress(true));
              (_this$_openTelemetry196 = this._openTelemetry) === null || _this$_openTelemetry196 === void 0 || _this$_openTelemetry196.completeSpan({
                span: enableShareSpan,
                status: 2,
                message: "Stream not found"
              });
              return _context65.abrupt("return");
            case 8:
              videoTrack = stream.getVideoTracks()[0];
              audioTrack = stream.getAudioTracks()[0];
              encodings = SCREEN_SHARING_SIMULCAST_ENCODINGS;
              (_this$_openTelemetry197 = this._openTelemetry) === null || _this$_openTelemetry197 === void 0 || _this$_openTelemetry197.completeSpan({
                message: "Track Generated with height ".concat(videoTrack.getSettings().height, " and width ").concat(videoTrack.getSettings().width),
                span: trackSpan,
                status: 1
              });
            case 9:
              internalSpan = (_this$_openTelemetry198 = this._openTelemetry) === null || _this$_openTelemetry198 === void 0 ? void 0 : _this$_openTelemetry198.trace({
                spanName: "Generating Producer Configuration",
                span: enableShareSpan
              });
              codecOptions = {
                videoGoogleStartBitrate: 1000
              };
              if (!this._forceH264) {
                _context65.next = 11;
                break;
              }
              codec = this._mediasoupDevice.rtpCapabilities.codecs.find(function (c) {
                return c.mimeType.toLowerCase() === "video/h264";
              });
              if (codec) {
                _context65.next = 10;
                break;
              }
              (_this$_videosdkLogs98 = this._videosdkLogs) === null || _this$_videosdkLogs98 === void 0 || _this$_videosdkLogs98.pushLogs({
                logText: "Error EnableShare : desired H264 codec+configuration is not supported",
                logType: "ERROR"
              });
              throw new Error("desired H264 codec+configuration is not supported");
            case 10:
              _context65.next = 12;
              break;
            case 11:
              if (!this._forceVP9) {
                _context65.next = 12;
                break;
              }
              codec = this._mediasoupDevice.rtpCapabilities.codecs.find(function (c) {
                return c.mimeType.toLowerCase() === "video/vp9";
              });
              if (codec) {
                _context65.next = 12;
                break;
              }
              (_this$_videosdkLogs99 = this._videosdkLogs) === null || _this$_videosdkLogs99 === void 0 || _this$_videosdkLogs99.pushLogs({
                logText: "Error EnableShare :desired VP9 codec+configuration is not supported",
                logType: "ERROR"
              });
              throw new Error("desired VP9 codec+configuration is not supported");
            case 12:
              (_this$_openTelemetry199 = this._openTelemetry) === null || _this$_openTelemetry199 === void 0 || _this$_openTelemetry199.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Producer Configuration Generated"
              });
              internalSpan = (_this$_openTelemetry200 = this._openTelemetry) === null || _this$_openTelemetry200 === void 0 ? void 0 : _this$_openTelemetry200.trace({
                spanName: "Creating Share Producer",
                span: enableShareSpan
              });
              _context65.next = 13;
              return this._sendTransport.produce({
                track: videoTrack,
                encodings: encodings.length > 0 ? encodings : SCREEN_SHARING_SIMULCAST_ENCODINGS,
                codecOptions: codecOptions,
                codec: codec,
                appData: {
                  share: true,
                  isEncrypted: this.isE2EEEnabled
                },
                onRtpSender: function onRtpSender(rtpSender) {
                  if (_this5.e2eeManager) {
                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                  }
                }
              });
            case 13:
              this._shareProducer = _context65.sent;
              if (this.e2eeManager) {
                this.e2eeManager.emit("NEW_PRODUCER", this._shareProducer);
              }
              action = addProducer({
                id: this._shareProducer.id,
                type: "share",
                paused: this._shareProducer.paused,
                track: this._shareProducer.track,
                rtpParameters: this._shareProducer.rtpParameters,
                codec: this._shareProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                appData: {
                  share: true,
                  isEncrypted: this.isE2EEEnabled
                },
                instance: this._shareProducer,
                rtpSender: this._shareProducer.rtpSender
              });
              store.dispatch(action);
              this._eventEmitter.emit(action.type, action.payload);
              this._shareProducer.on("transportclose", function () {
                var _this5$_shareProducer;
                var action = removeProducer(_this5._shareProducer.id);
                store.dispatch(action);
                _this5._eventEmitter.emit(action.type, action.payload);
                (_this5$_shareProducer = _this5._shareProducer) === null || _this5$_shareProducer === void 0 || _this5$_shareProducer.close();
                _this5._shareProducer = null;
              });
              this._shareProducer.on("trackended", function () {
                var _this5$_openTelemetry;
                (_this5$_openTelemetry = _this5._openTelemetry) === null || _this5$_openTelemetry === void 0 || _this5$_openTelemetry.traceAutoComplete({
                  spanName: "this._shareProducer trackended or Share disconnected!",
                  span: enableShareSpan,
                  status: 2
                });
                store.dispatch(notify({
                  type: "error",
                  text: "Share disconnected!"
                }));
                _this5.disableShare()["catch"](function () {});
              });
              (_this$_openTelemetry201 = this._openTelemetry) === null || _this$_openTelemetry201 === void 0 || _this$_openTelemetry201.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Share Producer Created"
              });
              if (!audioTrack) {
                _context65.next = 18;
                break;
              }
              _context65.prev = 14;
              audioCodecOptions = {
                opusStereo: 1,
                opusDtx: 1
              };
              internalSpan = (_this$_openTelemetry202 = this._openTelemetry) === null || _this$_openTelemetry202 === void 0 ? void 0 : _this$_openTelemetry202.trace({
                spanName: "Creating Share Audio Producer",
                span: enableShareSpan
              });
              _context65.next = 15;
              return this._sendTransport.produce({
                track: audioTrack,
                codecOptions: audioCodecOptions,
                appData: {
                  share: true,
                  isEncrypted: this.isE2EEEnabled
                },
                onRtpSender: function onRtpSender(rtpSender) {
                  if (_this5.e2eeManager) {
                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                  }
                }
              });
            case 15:
              this._shareAudioProducer = _context65.sent;
              _action8 = addProducer({
                id: this._shareAudioProducer.id,
                type: "share",
                paused: this._shareAudioProducer.paused,
                track: this._shareAudioProducer.track,
                rtpParameters: this._shareAudioProducer.rtpParameters,
                codec: this._shareAudioProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                appData: {
                  share: true,
                  isEncrypted: this.isE2EEEnabled
                },
                instance: this._shareAudioProducer,
                rtpSender: this._shareAudioProducer.rtpSender
              });
              store.dispatch(_action8);
              if (this.e2eeManager) {
                this.e2eeManager.emit("NEW_PRODUCER", this._shareAudioProducer);
              }
              this._eventEmitter.emit(_action8.type, _action8.payload);
              this._shareAudioProducer.on("transportclose", function () {
                var _this5$_shareAudioPro;
                var action = removeProducer(_this5._shareAudioProducer.id);
                store.dispatch(action);
                _this5._eventEmitter.emit(action.type, action.payload);
                (_this5$_shareAudioPro = _this5._shareAudioProducer) === null || _this5$_shareAudioPro === void 0 || _this5$_shareAudioPro.close();
                _this5._shareAudioProducer = null;
              });
              this._shareAudioProducer.on("trackended", function () {
                var _this5$_openTelemetry2;
                (_this5$_openTelemetry2 = _this5._openTelemetry) === null || _this5$_openTelemetry2 === void 0 || _this5$_openTelemetry2.traceAutoComplete({
                  spanName: "this._shareAudioProducer trackended",
                  span: enableShareSpan,
                  status: 2
                });
                store.dispatch(notify({
                  type: "error",
                  text: "Share disconnected!"
                }));
              });
              (_this$_openTelemetry203 = this._openTelemetry) === null || _this$_openTelemetry203 === void 0 || _this$_openTelemetry203.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Share Audio Producer Created"
              });
              _context65.next = 18;
              break;
            case 16:
              _context65.prev = 16;
              _t65 = _context65["catch"](14);
              _context65.next = 17;
              return this._socketRequest("produceError", {
                mediaType: "shareAudio",
                message: _t65.message
              });
            case 17:
              (_this$_videosdkLogs100 = this._videosdkLogs) === null || _this$_videosdkLogs100 === void 0 || _this$_videosdkLogs100.pushLogs({
                logText: "Error in shareAudio produceError",
                logType: "ERROR",
                attributes: {
                  error: _t65.message
                }
              });
            case 18:
              (_this$_openTelemetry204 = this._openTelemetry) === null || _this$_openTelemetry204 === void 0 || _this$_openTelemetry204.completeSpan({
                span: enableShareSpan,
                status: 1,
                message: "Enable Share Successful"
              });
              _context65.next = 21;
              break;
            case 19:
              _context65.prev = 19;
              _t66 = _context65["catch"](3);
              logger.error("enableShare() | failed:%o", _t66);
              (_this$_openTelemetry205 = this._openTelemetry) === null || _this$_openTelemetry205 === void 0 || _this$_openTelemetry205.completeSpan({
                span: enableShareSpan,
                status: 2,
                attributes: {
                  error: _t66.message
                },
                message: "Error in enableShare video produceError"
              });
              console.log("screen share catch", _t66.message);
              (_this$_videosdkLogs101 = this._videosdkLogs) === null || _this$_videosdkLogs101 === void 0 || _this$_videosdkLogs101.pushLogs({
                logText: "Error in enableShare video produceError",
                logType: "ERROR",
                attributes: {
                  error: _t66.message
                }
              });
              if (_t66.name !== "NotAllowedError") {
                store.dispatch(notify({
                  type: "error",
                  text: "Error sharing: ".concat(_t66)
                }));
              }
              _context65.next = 20;
              return this._socketRequest("produceError", {
                mediaType: "share",
                message: _t66.message
              });
            case 20:
              if (videoTrack) videoTrack.stop();
              if (audioTrack) audioTrack.stop();
            case 21:
              store.dispatch(setShareInProgress(false));
              // Stats are moved to the send transport,
              // since they are not available in React Native.

              // if (this._shareProducer) {
              //   let reportCounter = 0;

              //   let probe = this._metrics.addNewProbe(
              //     this._shareProducer,
              //     "share_producer"
              //   );

              //   probe.onStatsCollected = (report) => {
              //     try {
              //       if (!this._stats.producerStats) {
              //         this._stats.producerStats = {};
              //       }

              //       if (!this._stats.producerStats["share"]) {
              //         this._stats.producerStats["share"] = [];
              //       }

              //       if (this._shareProducer) {
              //         this._latestStats[this._shareProducer?.id] = [];
              //       }
              //       report["video"].forEach((stat) => {
              //         if (this._shareProducer) {
              //           this._latestStats[this._shareProducer?.id].push(stat);
              //         }
              //       });

              //       if (reportCounter % 5 == 0 && this._shareProducer != null) {
              //         this._stats["producerStats"]["share"].push({
              //           timestamp: new Date(),
              //           stats: this._latestStats[this._shareProducer.id],
              //         });
              //       }
              //       reportCounter++;
              //     } catch (error) {
              //       this._videosdkLogs?.pushLogs({
              //         logText: `Error PRODUCER Stats ERROR`,
              //         logType: "ERROR",
              //         attributes: {
              //           error: error.message,
              //         },
              //       });
              //       // console.log("PRODUCER ERROR", error);
              //     }
              //   };
              //   probe.start();

              //   this._shareProducer.observer.on("close", () => {
              //     probe.stop();
              //     this._metrics.removeExistingProbe(probe);
              //   });
              // }

              // if (this._shareAudioProducer) {
              //   let reportCounter = 0;

              //   let probe = this._metrics.addNewProbe(
              //     this._shareAudioProducer,
              //     "share_audio_producer"
              //   );

              //   probe.onStatsCollected = (report) => {
              //     try {
              //       if (!this._stats.producerStats) {
              //         this._stats.producerStats = {};
              //       }

              //       if (!this._stats.producerStats["shareAudio"]) {
              //         this._stats.producerStats["shareAudio"] = [];
              //       }

              //       if (this._shareAudioProducer) {
              //         this._latestStats[this._shareAudioProducer?.id] = [];
              //       }
              //       report["audio"].forEach((stat) => {
              //         if (this._shareAudioProducer) {
              //           this._latestStats[this._shareAudioProducer?.id].push(stat);
              //         }
              //       });

              //       if (reportCounter % 5 == 0 && this._shareAudioProducer != null) {
              //         this._stats["producerStats"]["shareAudio"].push({
              //           timestamp: new Date(),
              //           ...(this._latestStats[this._shareAudioProducer.id]
              //             ? this._latestStats[this._shareAudioProducer.id][0]
              //             : {}),
              //         });
              //       }
              //       reportCounter++;
              //     } catch (error) {
              //       this._videosdkLogs?.pushLogs({
              //         logText: `Error PRODUCER Stats ERROR`,
              //         logType: "ERROR",
              //         attributes: {
              //           error: error.message,
              //         },
              //       });
              //       // console.log("PRODUCER ERROR", error);
              //     }
              //   };
              //   probe.start();

              //   this._shareAudioProducer.observer.on("close", () => {
              //     probe.stop();
              //     this._metrics.removeExistingProbe(probe);
              //   });
              // }
            case 22:
            case "end":
              return _context65.stop();
          }
        }, _callee65, this, [[3, 19], [4, 6], [14, 16]]);
      }));
      function enableShare() {
        return _enableShare.apply(this, arguments);
      }
      return enableShare;
    }()
  }, {
    key: "disableShare",
    value: function () {
      var _disableShare = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee66() {
        var _this$_openTelemetry206, _this$_openTelemetry208, _this$_openTelemetry213;
        var disableShareSpan, _this$_openTelemetry207, internalSpan, action, _this$_openTelemetry209, _this$_openTelemetry210, disableAudioShareSpan, _this$_openTelemetry211, _this$_openTelemetry212, _this$_videosdkLogs102, _t67;
        return regenerator_default().wrap(function (_context66) {
          while (1) switch (_context66.prev = _context66.next) {
            case 0:
              logger.debug("disableShare()");
              disableShareSpan = (_this$_openTelemetry206 = this._openTelemetry) === null || _this$_openTelemetry206 === void 0 ? void 0 : _this$_openTelemetry206.trace({
                spanName: "disableShare() Calling",
                status: 1
              });
              if (this._shareProducer) {
                _context66.next = 1;
                break;
              }
              (_this$_openTelemetry207 = this._openTelemetry) === null || _this$_openTelemetry207 === void 0 || _this$_openTelemetry207.completeSpan({
                span: disableShareSpan,
                status: 2,
                message: "Share Producer Not found"
              });
              return _context66.abrupt("return");
            case 1:
              internalSpan = (_this$_openTelemetry208 = this._openTelemetry) === null || _this$_openTelemetry208 === void 0 ? void 0 : _this$_openTelemetry208.trace({
                spanName: "Closing Share Producer",
                span: disableShareSpan,
                status: 1
              });
              this._shareProducer.close();
              action = removeProducer(this._shareProducer.id);
              store.dispatch(action);
              this._eventEmitter.emit(action.type, action.payload);
              if (this._shareAudioProducer) {
                disableAudioShareSpan = (_this$_openTelemetry209 = this._openTelemetry) === null || _this$_openTelemetry209 === void 0 ? void 0 : _this$_openTelemetry209.trace({
                  spanName: "Closing Share Audio Producer",
                  span: disableShareSpan,
                  status: 1
                });
                this._shareAudioProducer.close();
                action = removeProducer(this._shareAudioProducer.id);
                store.dispatch(action);
                this._eventEmitter.emit(action.type, action.payload);
                (_this$_openTelemetry210 = this._openTelemetry) === null || _this$_openTelemetry210 === void 0 || _this$_openTelemetry210.completeSpan({
                  span: disableAudioShareSpan,
                  status: 1,
                  message: "Closed Share Audio Producer"
                });
              }
              _context66.prev = 2;
              _context66.next = 3;
              return this._socketRequest("closeProducer", {
                producerId: this._shareProducer.id
              });
            case 3:
              if (!(this, this._shareAudioProducer)) {
                _context66.next = 4;
                break;
              }
              _context66.next = 4;
              return this._socketRequest("closeProducer", {
                producerId: this._shareAudioProducer.id
              });
            case 4:
              (_this$_openTelemetry211 = this._openTelemetry) === null || _this$_openTelemetry211 === void 0 || _this$_openTelemetry211.completeSpan({
                span: internalSpan,
                status: 1,
                message: "Requested Server to Close Producer"
              });
              _context66.next = 6;
              break;
            case 5:
              _context66.prev = 5;
              _t67 = _context66["catch"](2);
              store.dispatch(notify({
                type: "error",
                text: "Error closing server-side share Producer: ".concat(_t67)
              }));
              (_this$_openTelemetry212 = this._openTelemetry) === null || _this$_openTelemetry212 === void 0 || _this$_openTelemetry212.completeSpan({
                span: disableShareSpan,
                status: 2,
                message: "Error closing server-side share Producer ".concat(_t67)
              });
              (_this$_videosdkLogs102 = this._videosdkLogs) === null || _this$_videosdkLogs102 === void 0 || _this$_videosdkLogs102.pushLogs({
                logText: "Error closing server-side share Producer",
                logType: "ERROR",
                attributes: {
                  error: _t67.message
                }
              });
            case 6:
              this._shareProducer = null;
              this._shareAudioProducer = null;
              (_this$_openTelemetry213 = this._openTelemetry) === null || _this$_openTelemetry213 === void 0 || _this$_openTelemetry213.completeSpan({
                span: disableShareSpan,
                status: 1,
                message: "Screen Share Disabled Successfully"
              });
            case 7:
            case "end":
              return _context66.stop();
          }
        }, _callee66, this, [[2, 5]]);
      }));
      function disableShare() {
        return _disableShare.apply(this, arguments);
      }
      return disableShare;
    }()
  }, {
    key: "enableAudioOnly",
    value: function () {
      var _enableAudioOnly = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee67() {
        var _iterator2, _step2, consumer, _t68;
        return regenerator_default().wrap(function (_context67) {
          while (1) switch (_context67.prev = _context67.next) {
            case 0:
              logger.debug("enableAudioOnly()");
              store.dispatch(setAudioOnlyInProgress(true));
              this.disableWebcam();
              _iterator2 = RoomClient_createForOfIteratorHelper(this._consumers.values());
              _context67.prev = 1;
              _iterator2.s();
            case 2:
              if ((_step2 = _iterator2.n()).done) {
                _context67.next = 5;
                break;
              }
              consumer = _step2.value;
              if (!(consumer.kind !== "video")) {
                _context67.next = 3;
                break;
              }
              return _context67.abrupt("continue", 4);
            case 3:
              this._pauseConsumer(consumer);
            case 4:
              _context67.next = 2;
              break;
            case 5:
              _context67.next = 7;
              break;
            case 6:
              _context67.prev = 6;
              _t68 = _context67["catch"](1);
              _iterator2.e(_t68);
            case 7:
              _context67.prev = 7;
              _iterator2.f();
              return _context67.finish(7);
            case 8:
              store.dispatch(setAudioOnlyState(true));
              store.dispatch(setAudioOnlyInProgress(false));
            case 9:
            case "end":
              return _context67.stop();
          }
        }, _callee67, this, [[1, 6, 7, 8]]);
      }));
      function enableAudioOnly() {
        return _enableAudioOnly.apply(this, arguments);
      }
      return enableAudioOnly;
    }()
  }, {
    key: "disableAudioOnly",
    value: function () {
      var _disableAudioOnly = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee68() {
        var _iterator3, _step3, consumer, _t69;
        return regenerator_default().wrap(function (_context68) {
          while (1) switch (_context68.prev = _context68.next) {
            case 0:
              logger.debug("disableAudioOnly()");
              store.dispatch(setAudioOnlyInProgress(true));
              if (!this._webcamProducer && this._produce && (getDevices() || {}).webcamEnabled) {
                this.enableWebcam();
              }
              _iterator3 = RoomClient_createForOfIteratorHelper(this._consumers.values());
              _context68.prev = 1;
              _iterator3.s();
            case 2:
              if ((_step3 = _iterator3.n()).done) {
                _context68.next = 5;
                break;
              }
              consumer = _step3.value;
              if (!(consumer.kind !== "video")) {
                _context68.next = 3;
                break;
              }
              return _context68.abrupt("continue", 4);
            case 3:
              this._resumeConsumer(consumer);
            case 4:
              _context68.next = 2;
              break;
            case 5:
              _context68.next = 7;
              break;
            case 6:
              _context68.prev = 6;
              _t69 = _context68["catch"](1);
              _iterator3.e(_t69);
            case 7:
              _context68.prev = 7;
              _iterator3.f();
              return _context68.finish(7);
            case 8:
              store.dispatch(setAudioOnlyState(false));
              store.dispatch(setAudioOnlyInProgress(false));
            case 9:
            case "end":
              return _context68.stop();
          }
        }, _callee68, this, [[1, 6, 7, 8]]);
      }));
      function disableAudioOnly() {
        return _disableAudioOnly.apply(this, arguments);
      }
      return disableAudioOnly;
    }()
  }, {
    key: "muteAudio",
    value: function () {
      var _muteAudio = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee69() {
        return regenerator_default().wrap(function (_context69) {
          while (1) switch (_context69.prev = _context69.next) {
            case 0:
              logger.debug("muteAudio()");
              store.dispatch(setAudioMutedState(true));
            case 1:
            case "end":
              return _context69.stop();
          }
        }, _callee69);
      }));
      function muteAudio() {
        return _muteAudio.apply(this, arguments);
      }
      return muteAudio;
    }()
  }, {
    key: "unmuteAudio",
    value: function () {
      var _unmuteAudio = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee70() {
        return regenerator_default().wrap(function (_context70) {
          while (1) switch (_context70.prev = _context70.next) {
            case 0:
              logger.debug("unmuteAudio()");
              store.dispatch(setAudioMutedState(false));
            case 1:
            case "end":
              return _context70.stop();
          }
        }, _callee70);
      }));
      function unmuteAudio() {
        return _unmuteAudio.apply(this, arguments);
      }
      return unmuteAudio;
    }()
  }, {
    key: "handleRemoteRestartIce",
    value: function () {
      var _handleRemoteRestartIce = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee71(_ref18) {
        var _this$_sendTransport5, _this$_recvTransport4;
        var iceParameters, transportId, internalSpan, _this$_openTelemetry214, _this$_openTelemetry215, _this$_videosdkLogs103, _t70;
        return regenerator_default().wrap(function (_context71) {
          while (1) switch (_context71.prev = _context71.next) {
            case 0:
              iceParameters = _ref18.iceParameters, transportId = _ref18.transportId, internalSpan = _ref18.internalSpan;
              if (transportId === ((_this$_sendTransport5 = this._sendTransport) === null || _this$_sendTransport5 === void 0 ? void 0 : _this$_sendTransport5.id)) {
                this._sendTransport.restartIce({
                  iceParameters: iceParameters
                });
              }
              if (transportId === ((_this$_recvTransport4 = this._recvTransport) === null || _this$_recvTransport4 === void 0 ? void 0 : _this$_recvTransport4.id)) {
                this._recvTransport.restartIce({
                  iceParameters: iceParameters
                });
              }
              _context71.prev = 1;
              _context71.next = 2;
              return this._socketRequest("iceRestarted", {
                transportId: transportId
              });
            case 2:
              (_this$_openTelemetry214 = this._openTelemetry) === null || _this$_openTelemetry214 === void 0 || _this$_openTelemetry214.completeSpan({
                span: internalSpan,
                status: 1,
                message: "iceRestarted"
              });
              _context71.next = 4;
              break;
            case 3:
              _context71.prev = 3;
              _t70 = _context71["catch"](1);
              (_this$_openTelemetry215 = this._openTelemetry) === null || _this$_openTelemetry215 === void 0 || _this$_openTelemetry215.completeSpan({
                span: internalSpan,
                status: 2,
                message: "handleRemoteRestartIce() ICE restart failed ".concat(_t70)
              });
              (_this$_videosdkLogs103 = this._videosdkLogs) === null || _this$_videosdkLogs103 === void 0 || _this$_videosdkLogs103.pushLogs({
                logText: "Error handleRemoteRestartIce() ICE restart failed",
                logType: "ERROR",
                attributes: {
                  error: _t70.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "ICE restart failed: ".concat(_t70)
              }));
            case 4:
            case "end":
              return _context71.stop();
          }
        }, _callee71, this, [[1, 3]]);
      }));
      function handleRemoteRestartIce(_x64) {
        return _handleRemoteRestartIce.apply(this, arguments);
      }
      return handleRemoteRestartIce;
    }()
  }, {
    key: "restartIce",
    value: function () {
      var _restartIce = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee72() {
        var iceParameters, _iceParameters, _this$_videosdkLogs104, _t71;
        return regenerator_default().wrap(function (_context72) {
          while (1) switch (_context72.prev = _context72.next) {
            case 0:
              logger.debug("restartIce()");
              store.dispatch(setRestartIceInProgress(true));
              _context72.prev = 1;
              if (!this._sendTransport) {
                _context72.next = 3;
                break;
              }
              _context72.next = 2;
              return this._socketRequest("restartIce", {
                transportId: this._sendTransport.id
              });
            case 2:
              iceParameters = _context72.sent;
              _context72.next = 3;
              return this._sendTransport.restartIce({
                iceParameters: iceParameters
              });
            case 3:
              if (!this._recvTransport) {
                _context72.next = 5;
                break;
              }
              _context72.next = 4;
              return this._socketRequest("restartIce", {
                transportId: this._recvTransport.id
              });
            case 4:
              _iceParameters = _context72.sent;
              _context72.next = 5;
              return this._recvTransport.restartIce({
                iceParameters: _iceParameters
              });
            case 5:
              store.dispatch(notify({
                text: "ICE restarted"
              }));
              _context72.next = 7;
              break;
            case 6:
              _context72.prev = 6;
              _t71 = _context72["catch"](1);
              logger.error("restartIce() | failed:%o", _t71);
              store.dispatch(notify({
                type: "error",
                text: "ICE restart failed: ".concat(_t71)
              }));
              (_this$_videosdkLogs104 = this._videosdkLogs) === null || _this$_videosdkLogs104 === void 0 || _this$_videosdkLogs104.pushLogs({
                logText: "Error restartIce() ICE restart failed",
                logType: "ERROR",
                attributes: {
                  error: _t71.message
                }
              });
            case 7:
              store.dispatch(setRestartIceInProgress(false));
            case 8:
            case "end":
              return _context72.stop();
          }
        }, _callee72, this, [[1, 6]]);
      }));
      function restartIce() {
        return _restartIce.apply(this, arguments);
      }
      return restartIce;
    }()
  }, {
    key: "_socketRequest",
    value: function () {
      var _socketRequest2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee73(event) {
        var _this6 = this;
        var data,
          _args73 = arguments;
        return regenerator_default().wrap(function (_context73) {
          while (1) switch (_context73.prev = _context73.next) {
            case 0:
              data = _args73.length > 1 && _args73[1] !== undefined ? _args73[1] : {};
              return _context73.abrupt("return", new Promise(function (resolve, reject) {
                _this6._webSocket.emit("request", {
                  method: event,
                  request: true,
                  data: data
                }, function (response) {
                  if (response !== null && response !== void 0 && response.error) {
                    reject(new Error(response.error));
                  } else {
                    resolve(response.data);
                  }
                });
              }));
            case 1:
            case "end":
              return _context73.stop();
          }
        }, _callee73);
      }));
      function _socketRequest(_x65) {
        return _socketRequest2.apply(this, arguments);
      }
      return _socketRequest;
    }()
  }, {
    key: "_socketRequestForPubsub",
    value: function () {
      var _socketRequestForPubsub2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee74(event) {
        var _this7 = this;
        var data,
          _args74 = arguments;
        return regenerator_default().wrap(function (_context74) {
          while (1) switch (_context74.prev = _context74.next) {
            case 0:
              data = _args74.length > 1 && _args74[1] !== undefined ? _args74[1] : {};
              return _context74.abrupt("return", new Promise(function (resolve, reject) {
                _this7._webSocket.timeout(30000).emit("request", {
                  method: event,
                  request: true,
                  data: data
                }, function (err, response) {
                  if (err) {
                    return reject(err);
                  }

                  // normal response handling
                  if (response !== null && response !== void 0 && response.error) {
                    reject(new Error(response.error));
                  } else {
                    resolve(response.data);
                  }
                });
              }));
            case 1:
            case "end":
              return _context74.stop();
          }
        }, _callee74);
      }));
      function _socketRequestForPubsub(_x66) {
        return _socketRequestForPubsub2.apply(this, arguments);
      }
      return _socketRequestForPubsub;
    }()
  }, {
    key: "setMaxSendingSpatialLayer",
    value: function () {
      var _setMaxSendingSpatialLayer = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee75(spatialLayer) {
        var _this$_videosdkLogs105, _t72;
        return regenerator_default().wrap(function (_context75) {
          while (1) switch (_context75.prev = _context75.next) {
            case 0:
              logger.debug("setMaxSendingSpatialLayer() [spatialLayer:%s]", spatialLayer);
              _context75.prev = 1;
              if (!this._webcamProducer) {
                _context75.next = 3;
                break;
              }
              _context75.next = 2;
              return this._webcamProducer.setMaxSpatialLayer(spatialLayer);
            case 2:
              _context75.next = 4;
              break;
            case 3:
              if (!this._shareProducer) {
                _context75.next = 4;
                break;
              }
              _context75.next = 4;
              return this._shareProducer.setMaxSpatialLayer(spatialLayer);
            case 4:
              _context75.next = 6;
              break;
            case 5:
              _context75.prev = 5;
              _t72 = _context75["catch"](1);
              logger.error("setMaxSendingSpatialLayer() | failed:%o", _t72);
              (_this$_videosdkLogs105 = this._videosdkLogs) === null || _this$_videosdkLogs105 === void 0 || _this$_videosdkLogs105.pushLogs({
                logText: "Error setting max sending video spatial layer",
                logType: "ERROR",
                attributes: {
                  error: _t72.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Error setting max sending video spatial layer: ".concat(_t72)
              }));
            case 6:
            case "end":
              return _context75.stop();
          }
        }, _callee75, this, [[1, 5]]);
      }));
      function setMaxSendingSpatialLayer(_x67) {
        return _setMaxSendingSpatialLayer.apply(this, arguments);
      }
      return setMaxSendingSpatialLayer;
    }()
    /**
     *
     * @param {"low" | "med" | 'high'} quality
     */
  }, {
    key: "setWebcamQuality",
    value: (function () {
      var _setWebcamQuality = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee76(quality) {
        var resolution, spatialLayers;
        return regenerator_default().wrap(function (_context76) {
          while (1) switch (_context76.prev = _context76.next) {
            case 0:
              if (this._webcamProducer) {
                _context76.next = 1;
                break;
              }
              return _context76.abrupt("return");
            case 1:
              resolution = this._webcam.resolution;
              spatialLayers = VIDEO_LAYERS[resolution][quality].s;
              if (!(this._webcamProducer.maxSpatialLayer == spatialLayers)) {
                _context76.next = 2;
                break;
              }
              return _context76.abrupt("return");
            case 2:
              _context76.next = 3;
              return this._webcamProducer.setMaxSpatialLayer(spatialLayers);
            case 3:
            case "end":
              return _context76.stop();
          }
        }, _callee76, this);
      }));
      function setWebcamQuality(_x68) {
        return _setWebcamQuality.apply(this, arguments);
      }
      return setWebcamQuality;
    }()
    /**
     *
     * @param {"low" | "med" | 'high'} quality
     */
    )
  }, {
    key: "setConsumerScreenShareQuality",
    value: (function () {
      var _setConsumerScreenShareQuality = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee77(consumerId, quality) {
        var _this$_openTelemetry216, _this$_openTelemetry217, _this$_openTelemetry218;
        var setScreenShareQualitySpan, qualities, selectedQuality;
        return regenerator_default().wrap(function (_context77) {
          while (1) switch (_context77.prev = _context77.next) {
            case 0:
              setScreenShareQualitySpan = (_this$_openTelemetry216 = this._openTelemetry) === null || _this$_openTelemetry216 === void 0 ? void 0 : _this$_openTelemetry216.trace({
                spanName: "Setting \"".concat(quality, "\" Quality for Screen Share")
              });
              qualities = {
                high: {
                  spatialLayer: 2,
                  temporalLayer: 2
                },
                med: {
                  spatialLayer: 1,
                  temporalLayer: 2
                },
                low: {
                  spatialLayer: 0,
                  temporalLayer: 2
                }
              };
              selectedQuality = qualities[quality] || qualities.high;
              (_this$_openTelemetry217 = this._openTelemetry) === null || _this$_openTelemetry217 === void 0 || _this$_openTelemetry217.traceAutoComplete({
                spanName: "Getting spatial & temporal layers",
                span: setScreenShareQualitySpan,
                attributes: {
                  selectedQuality: selectedQuality
                },
                status: 1
              });
              _context77.next = 1;
              return this.setConsumerPreferredLayers(consumerId, selectedQuality.spatialLayer, selectedQuality.temporalLayer);
            case 1:
              (_this$_openTelemetry218 = this._openTelemetry) === null || _this$_openTelemetry218 === void 0 || _this$_openTelemetry218.completeSpan({
                message: "Done",
                span: setScreenShareQualitySpan,
                status: 1
              });
            case 2:
            case "end":
              return _context77.stop();
          }
        }, _callee77, this);
      }));
      function setConsumerScreenShareQuality(_x69, _x70) {
        return _setConsumerScreenShareQuality.apply(this, arguments);
      }
      return setConsumerScreenShareQuality;
    }()
    /**
     *
     * @param {"low" | "med" | 'high'} quality
     */
    )
  }, {
    key: "setConsumerQuality",
    value: (function () {
      var _setConsumerQuality = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee78(consumerId, quality) {
        var _this$_openTelemetry219, _this$_openTelemetry220, _this$_openTelemetry221;
        var resolution, setWebcamQualitySpan, spatialLayers, temporalLayers;
        return regenerator_default().wrap(function (_context78) {
          while (1) switch (_context78.prev = _context78.next) {
            case 0:
              resolution = this._webcam.resolution;
              setWebcamQualitySpan = (_this$_openTelemetry219 = this._openTelemetry) === null || _this$_openTelemetry219 === void 0 ? void 0 : _this$_openTelemetry219.trace({
                spanName: "Setting \"".concat(quality, "\" Quality")
              });
              spatialLayers = VIDEO_LAYERS[resolution][quality].s;
              temporalLayers = VIDEO_LAYERS[resolution][quality].t;
              (_this$_openTelemetry220 = this._openTelemetry) === null || _this$_openTelemetry220 === void 0 || _this$_openTelemetry220.traceAutoComplete({
                spanName: "Getting spatial & temporal layers",
                span: setWebcamQualitySpan,
                attributes: {
                  spatialLayers: JSON.parse(spatialLayers),
                  temporalLayers: JSON.parse(temporalLayers)
                },
                status: 1
              });
              _context78.next = 1;
              return this.setConsumerPreferredLayers(consumerId, spatialLayers, temporalLayers);
            case 1:
              (_this$_openTelemetry221 = this._openTelemetry) === null || _this$_openTelemetry221 === void 0 || _this$_openTelemetry221.completeSpan({
                message: "Done",
                span: setWebcamQualitySpan,
                status: 1
              });
            case 2:
            case "end":
              return _context78.stop();
          }
        }, _callee78, this);
      }));
      function setConsumerQuality(_x71, _x72) {
        return _setConsumerQuality.apply(this, arguments);
      }
      return setConsumerQuality;
    }())
  }, {
    key: "setViewPort",
    value: function () {
      var _setViewPort = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee79(consumer, viewportWidth, viewportHeight) {
        var _getAdaptivePreffered, consumerId, newPreferredSpatialLayer, newPreferredTemporalLayer;
        return regenerator_default().wrap(function (_context79) {
          while (1) switch (_context79.prev = _context79.next) {
            case 0:
              if (this._consumers.get(consumer.id)) {
                _context79.next = 1;
                break;
              }
              return _context79.abrupt("return");
            case 1:
              _getAdaptivePreffered = (0,sdkCapabilities/* getAdaptivePrefferedLayers */.ed)(this._consumers.get(consumer.id), viewportWidth, viewportHeight), consumerId = _getAdaptivePreffered.consumerId, newPreferredSpatialLayer = _getAdaptivePreffered.newPreferredSpatialLayer, newPreferredTemporalLayer = _getAdaptivePreffered.newPreferredTemporalLayer;
              if (!(newPreferredSpatialLayer === consumer.preferredSpatialLayer && newPreferredTemporalLayer === consumer.preferredTemporalLayer)) {
                _context79.next = 2;
                break;
              }
              return _context79.abrupt("return");
            case 2:
              if (!consumerId) {
                _context79.next = 3;
                break;
              }
              _context79.next = 3;
              return this.setConsumerPreferredLayers(consumerId, newPreferredSpatialLayer, newPreferredTemporalLayer);
            case 3:
            case "end":
              return _context79.stop();
          }
        }, _callee79, this);
      }));
      function setViewPort(_x73, _x74, _x75) {
        return _setViewPort.apply(this, arguments);
      }
      return setViewPort;
    }()
  }, {
    key: "setConsumerPreferredLayers",
    value: function () {
      var _setConsumerPreferredLayers = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee80(consumerId, spatialLayer, temporalLayer) {
        var consumer, _this$_videosdkLogs106, _t73;
        return regenerator_default().wrap(function (_context80) {
          while (1) switch (_context80.prev = _context80.next) {
            case 0:
              logger.debug("setConsumerPreferredLayers() [consumerId:%s, spatialLayer:%s, temporalLayer:%s]", consumerId, spatialLayer, temporalLayer);
              _context80.prev = 1;
              consumer = this._consumers.get(consumerId);
              if (consumer.spatialLayers > 1) {
                consumer.preferredSpatialLayer = spatialLayer;
                consumer.preferredTemporalLayer = temporalLayer;
              }
              _context80.next = 2;
              return this._socketRequest("setConsumerPreferredLayers", {
                consumerId: consumerId,
                spatialLayer: spatialLayer,
                temporalLayer: temporalLayer
              });
            case 2:
              store.dispatch(stateActions_setConsumerPreferredLayers(consumerId, spatialLayer, temporalLayer));
              _context80.next = 4;
              break;
            case 3:
              _context80.prev = 3;
              _t73 = _context80["catch"](1);
              logger.error("setConsumerPreferredLayers() | failed:%o", _t73);
              (_this$_videosdkLogs106 = this._videosdkLogs) === null || _this$_videosdkLogs106 === void 0 || _this$_videosdkLogs106.pushLogs({
                logText: "Error setting Consumer preferred layers:",
                logType: "ERROR",
                attributes: {
                  error: _t73.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Error setting Consumer preferred layers: ".concat(_t73)
              }));
            case 4:
            case "end":
              return _context80.stop();
          }
        }, _callee80, this, [[1, 3]]);
      }));
      function setConsumerPreferredLayers(_x76, _x77, _x78) {
        return _setConsumerPreferredLayers.apply(this, arguments);
      }
      return setConsumerPreferredLayers;
    }()
  }, {
    key: "setConsumerPriority",
    value: function () {
      var _setConsumerPriority = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee81(consumerId, priority) {
        var _this$_videosdkLogs107, _t74;
        return regenerator_default().wrap(function (_context81) {
          while (1) switch (_context81.prev = _context81.next) {
            case 0:
              logger.debug("setConsumerPriority() [consumerId:%s, priority:%d]", consumerId, priority);
              _context81.prev = 1;
              _context81.next = 2;
              return this._socketRequest("setConsumerPriority", {
                consumerId: consumerId,
                priority: priority
              });
            case 2:
              store.dispatch(stateActions_setConsumerPriority(consumerId, priority));
              _context81.next = 4;
              break;
            case 3:
              _context81.prev = 3;
              _t74 = _context81["catch"](1);
              logger.error("setConsumerPriority() | failed:%o", _t74);
              (_this$_videosdkLogs107 = this._videosdkLogs) === null || _this$_videosdkLogs107 === void 0 || _this$_videosdkLogs107.pushLogs({
                logText: "Error setting Consumer priority",
                logType: "ERROR",
                attributes: {
                  error: _t74.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Error setting Consumer priority: ".concat(_t74)
              }));
            case 4:
            case "end":
              return _context81.stop();
          }
        }, _callee81, this, [[1, 3]]);
      }));
      function setConsumerPriority(_x79, _x80) {
        return _setConsumerPriority.apply(this, arguments);
      }
      return setConsumerPriority;
    }()
  }, {
    key: "requestConsumerKeyFrame",
    value: function () {
      var _requestConsumerKeyFrame = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee82(consumerId) {
        var _this$_videosdkLogs108, _t75;
        return regenerator_default().wrap(function (_context82) {
          while (1) switch (_context82.prev = _context82.next) {
            case 0:
              logger.debug("requestConsumerKeyFrame() [consumerId:%s]", consumerId);
              _context82.prev = 1;
              _context82.next = 2;
              return this._socketRequest("requestConsumerKeyFrame", {
                consumerId: consumerId
              });
            case 2:
              store.dispatch(notify({
                text: "Keyframe requested for video consumer"
              }));
              _context82.next = 4;
              break;
            case 3:
              _context82.prev = 3;
              _t75 = _context82["catch"](1);
              logger.error("requestConsumerKeyFrame() | failed:%o", _t75);
              (_this$_videosdkLogs108 = this._videosdkLogs) === null || _this$_videosdkLogs108 === void 0 || _this$_videosdkLogs108.pushLogs({
                logText: "Error requesting key frame for Consumer",
                logType: "ERROR",
                attributes: {
                  error: _t75.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Error requesting key frame for Consumer: ".concat(_t75)
              }));
            case 4:
            case "end":
              return _context82.stop();
          }
        }, _callee82, this, [[1, 3]]);
      }));
      function requestConsumerKeyFrame(_x81) {
        return _requestConsumerKeyFrame.apply(this, arguments);
      }
      return requestConsumerKeyFrame;
    }()
  }, {
    key: "enableChatDataProducer",
    value: function () {
      var _enableChatDataProducer = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee83() {
        var _this8 = this;
        var _this$_videosdkLogs109, _t76;
        return regenerator_default().wrap(function (_context83) {
          while (1) switch (_context83.prev = _context83.next) {
            case 0:
              logger.debug("enableChatDataProducer()");
              _context83.prev = 1;
              _context83.next = 2;
              return this._sendTransport.produceData({
                ordered: true,
                maxRetransmits: 5,
                label: "reliable_data_producer",
                appData: {
                  info: "my-chat-DataProducer"
                }
              });
            case 2:
              this._reliableDataProducer = _context83.sent;
              this._reliableDataProducer.bufferedAmountLowThreshold = 65535;
              _context83.next = 3;
              return this._sendTransport.produceData({
                ordered: false,
                label: "unreliable_data_producer",
                appData: {
                  info: "my-chat-DataProducer"
                }
              });
            case 3:
              this._unreliableDataProducer = _context83.sent;
              this._unreliableDataProducer.bufferedAmountLowThreshold = 65535;
              store.dispatch(addDataProducer({
                id: this._reliableDataProducer.id,
                sctpStreamParameters: this._reliableDataProducer.sctpStreamParameters,
                label: this._reliableDataProducer.label,
                protocol: this._reliableDataProducer.protocol
              }));
              this._reliableDataProducer.on("transportclose", function () {
                _this8._reliableDataProducer = null;
              });
              this._reliableDataProducer.on("open", function () {
                logger.debug('chat DataProducer "open" event');
              });
              this._reliableDataProducer.on("close", function () {
                logger.error('chat DataProducer "close" event');
                _this8._reliableDataProducer = null;
                store.dispatch(notify({
                  type: "error",
                  text: "Chat DataProducer closed"
                }));
              });
              this._reliableDataProducer.on("error", function (error) {
                logger.error('chat DataProducer "error" event:%o', error);
                store.dispatch(notify({
                  type: "error",
                  text: "Chat DataProducer error: ".concat(error)
                }));
              });
              store.dispatch(addDataProducer({
                id: this._unreliableDataProducer.id,
                sctpStreamParameters: this._unreliableDataProducer.sctpStreamParameters,
                label: this._unreliableDataProducer.label,
                protocol: this._unreliableDataProducer.protocol
              }));
              this._unreliableDataProducer.on("transportclose", function () {
                _this8._unreliableDataProducer = null;
              });
              this._unreliableDataProducer.on("open", function () {
                logger.debug('unreliable DataProducer "open" event');
              });
              this._unreliableDataProducer.on("close", function () {
                logger.error('unreliable DataProducer "close" event');
                _this8._unreliableDataProducer = null;
                store.dispatch(notify({
                  type: "error",
                  text: "unreliable DataProducer closed"
                }));
              });
              this._unreliableDataProducer.on("error", function (error) {
                logger.error('unreliable DataProducer "error" event:%o', error);
                store.dispatch(notify({
                  type: "error",
                  text: "unreliable DataProducer error: ".concat(error)
                }));
              });
              _context83.next = 5;
              break;
            case 4:
              _context83.prev = 4;
              _t76 = _context83["catch"](1);
              logger.error("enableChatDataProducer() | failed:%o", _t76);
              (_this$_videosdkLogs109 = this._videosdkLogs) === null || _this$_videosdkLogs109 === void 0 || _this$_videosdkLogs109.pushLogs({
                logText: "Error enabling chat DataProducer",
                logType: "ERROR",
                attributes: {
                  error: _t76.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Error enabling chat DataProducer: ".concat(_t76)
              }));
              throw _t76;
            case 5:
            case "end":
              return _context83.stop();
          }
        }, _callee83, this, [[1, 4]]);
      }));
      function enableChatDataProducer() {
        return _enableChatDataProducer.apply(this, arguments);
      }
      return enableChatDataProducer;
    }()
  }, {
    key: "send",
    value: function () {
      var _send = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee84(payload) {
        var _this9 = this;
        var opts,
          isValid,
          size,
          _args84 = arguments,
          _t77;
        return regenerator_default().wrap(function (_context84) {
          while (1) switch (_context84.prev = _context84.next) {
            case 0:
              opts = _args84.length > 1 && _args84[1] !== undefined ? _args84[1] : {
                reliability: reliabilityModes/* reliabilityMode */.y.RELIABLE
              };
              _context84.prev = 1;
              isValid = typeof payload === "string" || payload instanceof Blob || payload instanceof ArrayBuffer || ArrayBuffer.isView(payload);
              if (isValid) {
                _context84.next = 2;
                break;
              }
              throw new TypeError("Invalid payload type. Expected string | Blob | ArrayBuffer | ArrayBufferView");
            case 2:
              size = 0;
              if (typeof payload === "string") {
                size = new TextEncoder().encode(payload).length;
              } else if (payload instanceof Blob) {
                size = payload.size;
              } else if (payload instanceof ArrayBuffer) {
                size = payload.byteLength;
              } else if (ArrayBuffer.isView(payload)) {
                size = payload.byteLength;
              }
              if (!(size > 15 * 1024)) {
                _context84.next = 3;
                break;
              }
              throw new Error("Payload too large: ".concat(size, " bytes. Max allowed is 15 KiB."));
            case 3:
              if (!(!this._sendTransport || this._sendTransport.connectionState !== "connected")) {
                _context84.next = 4;
                break;
              }
              throw new Error("Cannot send message, Network is not available.");
            case 4:
              if (!(opts.reliability === reliabilityModes/* reliabilityMode */.y.RELIABLE)) {
                _context84.next = 6;
                break;
              }
              if (!(this._reliableDataProducer.bufferedAmount > this._reliableDataProducer.bufferedAmountLowThreshold)) {
                _context84.next = 5;
                break;
              }
              logger.warn("Buffer full, waiting to resume");
              return _context84.abrupt("return", new Promise(function (resolve, reject) {
                var _resumeHandler = function resumeHandler() {
                  try {
                    _this9._reliableDataProducer.send(payload);
                    resolve(true);
                  } catch (err) {
                    reject(err);
                  } finally {
                    _this9._reliableDataProducer.off("bufferedamountlow", _resumeHandler);
                  }
                };
                _this9._reliableDataProducer.on("bufferedamountlow", _resumeHandler);
              }));
            case 5:
              this._reliableDataProducer.send(payload);
              // console.log("sent message")
              return _context84.abrupt("return", true);
            case 6:
              if (!(opts.reliability === reliabilityModes/* reliabilityMode */.y.UNRELIABLE)) {
                _context84.next = 8;
                break;
              }
              if (!(this._unreliableDataProducer.bufferedAmount > this._unreliableDataProducer.bufferedAmountLowThreshold)) {
                _context84.next = 7;
                break;
              }
              logger.warn("Buffer full, waiting to resume");
              return _context84.abrupt("return", new Promise(function (resolve, reject) {
                var _resumeHandler2 = function resumeHandler() {
                  try {
                    _this9._unreliableDataProducer.send(payload);
                    resolve(true);
                  } catch (err) {
                    reject(err);
                  } finally {
                    _this9._unreliableDataProducer.off("bufferedamountlow", _resumeHandler2);
                  }
                };
                _this9._unreliableDataProducer.on("bufferedamountlow", _resumeHandler2);
              }));
            case 7:
              this._unreliableDataProducer.send(payload);
              return _context84.abrupt("return", true);
            case 8:
              _context84.next = 10;
              break;
            case 9:
              _context84.prev = 9;
              _t77 = _context84["catch"](1);
              logger.error("DataProducer.send() failed:%o", _t77);
              store.dispatch(notify({
                type: "error",
                text: "DataProducer.send() failed: ".concat(_t77)
              }));
              throw _t77;
            case 10:
            case "end":
              return _context84.stop();
          }
        }, _callee84, this, [[1, 9]]);
      }));
      function send(_x82) {
        return _send.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "changeDisplayName",
    value: function () {
      var _changeDisplayName = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee85(displayName) {
        var _t78;
        return regenerator_default().wrap(function (_context85) {
          while (1) switch (_context85.prev = _context85.next) {
            case 0:
              logger.debug('changeDisplayName() [displayName:"%s"]', displayName);

              // Store in cookie.
              setUser({
                displayName: displayName
              });
              _context85.prev = 1;
              _context85.next = 2;
              return this._socketRequest("changeDisplayName", {
                displayName: displayName
              });
            case 2:
              this._displayName = displayName;
              store.dispatch(setDisplayName(displayName));
              store.dispatch(notify({
                text: "Display name changed"
              }));
              _context85.next = 4;
              break;
            case 3:
              _context85.prev = 3;
              _t78 = _context85["catch"](1);
              logger.error("changeDisplayName() | failed: %o", _t78);
              store.dispatch(notify({
                type: "error",
                text: "Could not change display name: ".concat(_t78)
              }));

              // We need to refresh the component for it to render the previous
              // displayName again.
              store.dispatch(setDisplayName());
            case 4:
            case "end":
              return _context85.stop();
          }
        }, _callee85, this, [[1, 3]]);
      }));
      function changeDisplayName(_x83) {
        return _changeDisplayName.apply(this, arguments);
      }
      return changeDisplayName;
    }()
  }, {
    key: "openConnection",
    value: function () {
      var _openConnection = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee86(_ref19) {
        var roomId, payload;
        return regenerator_default().wrap(function (_context86) {
          while (1) switch (_context86.prev = _context86.next) {
            case 0:
              roomId = _ref19.roomId, payload = _ref19.payload;
              _context86.next = 1;
              return this._socketRequest("openConnection", {
                roomId: roomId,
                payload: payload
              })["catch"](function (err) {
                throw new Error(err);
              });
            case 1:
            case "end":
              return _context86.stop();
          }
        }, _callee86, this);
      }));
      function openConnection(_x84) {
        return _openConnection.apply(this, arguments);
      }
      return openConnection;
    }()
  }, {
    key: "closeConnection",
    value: function () {
      var _closeConnection = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee87(roomId) {
        return regenerator_default().wrap(function (_context87) {
          while (1) switch (_context87.prev = _context87.next) {
            case 0:
              _context87.next = 1;
              return this._socketRequest("closeConnection", {
                roomId: roomId
              });
            case 1:
            case "end":
              return _context87.stop();
          }
        }, _callee87, this);
      }));
      function closeConnection(_x85) {
        return _closeConnection.apply(this, arguments);
      }
      return closeConnection;
    }()
  }, {
    key: "switchPeerRoom",
    value: function () {
      var _switchPeerRoom = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee88(_ref20) {
        var peerId, roomId, payload, token;
        return regenerator_default().wrap(function (_context88) {
          while (1) switch (_context88.prev = _context88.next) {
            case 0:
              peerId = _ref20.peerId, roomId = _ref20.roomId, payload = _ref20.payload, token = _ref20.token;
              _context88.next = 1;
              return this._socketRequest("switchPeerRoom", {
                roomId: roomId,
                peerId: peerId,
                payload: payload,
                token: token
              });
            case 1:
            case "end":
              return _context88.stop();
          }
        }, _callee88, this);
      }));
      function switchPeerRoom(_x86) {
        return _switchPeerRoom.apply(this, arguments);
      }
      return switchPeerRoom;
    }()
  }, {
    key: "connectionSwitchPeerRoom",
    value: function () {
      var _connectionSwitchPeerRoom = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee89(_ref21) {
        var roomId, connectionRoomId, peerId, payload, token;
        return regenerator_default().wrap(function (_context89) {
          while (1) switch (_context89.prev = _context89.next) {
            case 0:
              roomId = _ref21.roomId, connectionRoomId = _ref21.connectionRoomId, peerId = _ref21.peerId, payload = _ref21.payload, token = _ref21.token;
              _context89.next = 1;
              return this._socketRequest("connectionSwitchPeerRoom", {
                roomId: roomId,
                connectionRoomId: connectionRoomId,
                peerId: peerId,
                payload: payload,
                token: token
              });
            case 1:
            case "end":
              return _context89.stop();
          }
        }, _callee89, this);
      }));
      function connectionSwitchPeerRoom(_x87) {
        return _connectionSwitchPeerRoom.apply(this, arguments);
      }
      return connectionSwitchPeerRoom;
    }()
  }, {
    key: "connectionSendChatMessage",
    value: function () {
      var _connectionSendChatMessage = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee90(_ref22) {
        var roomId, message;
        return regenerator_default().wrap(function (_context90) {
          while (1) switch (_context90.prev = _context90.next) {
            case 0:
              roomId = _ref22.roomId, message = _ref22.message;
              _context90.next = 1;
              return this._socketRequest("connectionSendChatMessage", {
                roomId: roomId,
                message: message
              });
            case 1:
            case "end":
              return _context90.stop();
          }
        }, _callee90, this);
      }));
      function connectionSendChatMessage(_x88) {
        return _connectionSendChatMessage.apply(this, arguments);
      }
      return connectionSendChatMessage;
    }()
  }, {
    key: "connectionEndMeeting",
    value: function () {
      var _connectionEndMeeting = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee91(_ref23) {
        var roomId;
        return regenerator_default().wrap(function (_context91) {
          while (1) switch (_context91.prev = _context91.next) {
            case 0:
              roomId = _ref23.roomId;
              _context91.next = 1;
              return this._socketRequest("connectionCloseRoom", {
                roomId: roomId
              });
            case 1:
            case "end":
              return _context91.stop();
          }
        }, _callee91, this);
      }));
      function connectionEndMeeting(_x89) {
        return _connectionEndMeeting.apply(this, arguments);
      }
      return connectionEndMeeting;
    }()
  }, {
    key: "pubsubPublish",
    value: function () {
      var _pubsubPublish = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee92(topic, message, options, payload) {
        var sendOnly, sendOnlyToString, _iterator4, _step4, s, _this$_videosdkLogs110, _t79;
        return regenerator_default().wrap(function (_context92) {
          while (1) switch (_context92.prev = _context92.next) {
            case 0:
              _context92.prev = 0;
              if (options !== null && options !== void 0 && options.sendOnly) {
                sendOnly = options.sendOnly;
                sendOnlyToString = [];
                if (sendOnly) {
                  _iterator4 = RoomClient_createForOfIteratorHelper(sendOnly);
                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                      s = _step4.value;
                      if (s) {
                        sendOnlyToString.push(s.toString());
                      }
                    }
                  } catch (err) {
                    _iterator4.e(err);
                  } finally {
                    _iterator4.f();
                  }
                }
                options.sendOnly = sendOnlyToString;
              }
              _context92.next = 1;
              return this._socketRequestForPubsub("pubsubPublish", {
                topic: topic,
                message: message,
                options: options,
                payload: payload
              });
            case 1:
              _context92.next = 3;
              break;
            case 2:
              _context92.prev = 2;
              _t79 = _context92["catch"](0);
              (_this$_videosdkLogs110 = this._videosdkLogs) === null || _this$_videosdkLogs110 === void 0 || _this$_videosdkLogs110.pushLogs({
                logText: "Error pubsubPublish() | failed",
                logType: "ERROR",
                attributes: {
                  error: _t79.message
                }
              });
              logger.error("pubsubPublish() | failed: %o", _t79);
              throw new Error("".concat(_t79.message === "operation has timed out" ? "Message publishing timed out. Please check your network connection and try again." : "Pubsub Publish Error : ".concat(_t79.message)));
            case 3:
            case "end":
              return _context92.stop();
          }
        }, _callee92, this, [[0, 2]]);
      }));
      function pubsubPublish(_x90, _x91, _x92, _x93) {
        return _pubsubPublish.apply(this, arguments);
      }
      return pubsubPublish;
    }()
  }, {
    key: "pubsubSubscribe",
    value: function () {
      var _pubsubSubscribe = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee93(topic) {
        var messageArr, _this$_videosdkLogs111, _t80;
        return regenerator_default().wrap(function (_context93) {
          while (1) switch (_context93.prev = _context93.next) {
            case 0:
              if (!this._closed) {
                _context93.next = 1;
                break;
              }
              return _context93.abrupt("return");
            case 1:
              _context93.prev = 1;
              _context93.next = 2;
              return this._socketRequest("pubsubSubscribe", {
                topic: topic
              });
            case 2:
              messageArr = _context93.sent;
              return _context93.abrupt("return", messageArr);
            case 3:
              _context93.prev = 3;
              _t80 = _context93["catch"](1);
              (_this$_videosdkLogs111 = this._videosdkLogs) === null || _this$_videosdkLogs111 === void 0 || _this$_videosdkLogs111.pushLogs({
                logText: "Error pubsubSubscribe() | failed",
                logType: "ERROR",
                attributes: {
                  error: _t80.message
                }
              });
              logger.error("pubsubSubscribe() | failed: %o", _t80);
            case 4:
            case "end":
              return _context93.stop();
          }
        }, _callee93, this, [[1, 3]]);
      }));
      function pubsubSubscribe(_x94) {
        return _pubsubSubscribe.apply(this, arguments);
      }
      return pubsubSubscribe;
    }()
  }, {
    key: "pubsubUnsubscribe",
    value: function () {
      var _pubsubUnsubscribe = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee94(topic) {
        var _this$_videosdkLogs112, _this$_videosdkLogs113, _t81;
        return regenerator_default().wrap(function (_context94) {
          while (1) switch (_context94.prev = _context94.next) {
            case 0:
              if (!this._closed) {
                _context94.next = 1;
                break;
              }
              return _context94.abrupt("return");
            case 1:
              _context94.prev = 1;
              _context94.next = 2;
              return this._socketRequest("pubsubUnsubscribe", {
                topic: topic
              });
            case 2:
              (_this$_videosdkLogs112 = this._videosdkLogs) === null || _this$_videosdkLogs112 === void 0 || _this$_videosdkLogs112.pushLogs({
                logText: "Pubsub Unsubscribing Successfully for topic ".concat(topic),
                logType: "INFO"
              });
              _context94.next = 4;
              break;
            case 3:
              _context94.prev = 3;
              _t81 = _context94["catch"](1);
              (_this$_videosdkLogs113 = this._videosdkLogs) === null || _this$_videosdkLogs113 === void 0 || _this$_videosdkLogs113.pushLogs({
                logText: "Error pubsubUnsubscribe() | failed",
                logType: "ERROR",
                attributes: {
                  error: _t81.message
                }
              });
              logger.error("pubsubUnsubscribe() | failed: %o", _t81);
            case 4:
            case "end":
              return _context94.stop();
          }
        }, _callee94, this, [[1, 3]]);
      }));
      function pubsubUnsubscribe(_x95) {
        return _pubsubUnsubscribe.apply(this, arguments);
      }
      return pubsubUnsubscribe;
    }()
  }, {
    key: "closeRoom",
    value: function () {
      var _closeRoom = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee95() {
        return regenerator_default().wrap(function (_context95) {
          while (1) switch (_context95.prev = _context95.next) {
            case 0:
              _context95.next = 1;
              return this._socketRequest("closeRoom", {});
            case 1:
            case "end":
              return _context95.stop();
          }
        }, _callee95, this);
      }));
      function closeRoom() {
        return _closeRoom.apply(this, arguments);
      }
      return closeRoom;
    }()
  }, {
    key: "removePeer",
    value: function () {
      var _removePeer = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee96(peerId) {
        var _this$_openTelemetry222;
        return regenerator_default().wrap(function (_context96) {
          while (1) switch (_context96.prev = _context96.next) {
            case 0:
              (_this$_openTelemetry222 = this._openTelemetry) === null || _this$_openTelemetry222 === void 0 || _this$_openTelemetry222.traceAutoComplete({
                spanName: "Removing peer ".concat(peerId),
                status: 1
              });
              if (!(peerId == null)) {
                _context96.next = 1;
                break;
              }
              return _context96.abrupt("return");
            case 1:
              _context96.next = 2;
              return this._socketRequest("removePeer", {
                peerId: peerId
              });
            case 2:
            case "end":
              return _context96.stop();
          }
        }, _callee96, this);
      }));
      function removePeer(_x96) {
        return _removePeer.apply(this, arguments);
      }
      return removePeer;
    }()
  }, {
    key: "getSendTransportRemoteStats",
    value: function () {
      var _getSendTransportRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee97() {
        return regenerator_default().wrap(function (_context97) {
          while (1) switch (_context97.prev = _context97.next) {
            case 0:
              logger.debug("getSendTransportRemoteStats()");
              if (this._sendTransport) {
                _context97.next = 1;
                break;
              }
              return _context97.abrupt("return");
            case 1:
              return _context97.abrupt("return", this._socketRequest("getTransportStats", {
                transportId: this._sendTransport.id
              }));
            case 2:
            case "end":
              return _context97.stop();
          }
        }, _callee97, this);
      }));
      function getSendTransportRemoteStats() {
        return _getSendTransportRemoteStats.apply(this, arguments);
      }
      return getSendTransportRemoteStats;
    }()
  }, {
    key: "getRecvTransportRemoteStats",
    value: function () {
      var _getRecvTransportRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee98() {
        return regenerator_default().wrap(function (_context98) {
          while (1) switch (_context98.prev = _context98.next) {
            case 0:
              logger.debug("getRecvTransportRemoteStats()");
              if (this._recvTransport) {
                _context98.next = 1;
                break;
              }
              return _context98.abrupt("return");
            case 1:
              return _context98.abrupt("return", this._socketRequest("getTransportStats", {
                transportId: this._recvTransport.id
              }));
            case 2:
            case "end":
              return _context98.stop();
          }
        }, _callee98, this);
      }));
      function getRecvTransportRemoteStats() {
        return _getRecvTransportRemoteStats.apply(this, arguments);
      }
      return getRecvTransportRemoteStats;
    }()
    /**
     *
     * @returns {Promise<[{
     *   bitrate: number,
     *   roundTripTime: number,
     *   jitter: number,
     *   totalPackets: number,
     *   packetsLost: number,
     *   network: String,
     *   codec: String,
     * }]>}
     */
  }, {
    key: "getAudioRemoteStats",
    value: (function () {
      var _getAudioRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee99() {
        var producer;
        return regenerator_default().wrap(function (_context99) {
          while (1) switch (_context99.prev = _context99.next) {
            case 0:
              logger.debug("getAudioRemoteStats()");
              producer = this._micProducer;
              if (producer) {
                _context99.next = 1;
                break;
              }
              return _context99.abrupt("return");
            case 1:
              return _context99.abrupt("return", this._latestStats[producer.id]);
            case 2:
            case "end":
              return _context99.stop();
          }
        }, _callee99, this);
      }));
      function getAudioRemoteStats() {
        return _getAudioRemoteStats.apply(this, arguments);
      }
      return getAudioRemoteStats;
    }()
    /**
     *
     * @returns {Promise<[{
     *   bitrate: number,
     *   roundTripTime: number,
     *   jitter: number,
     *   totalPackets: number,
     *   packetsLost: number,
     *   network: String,
     *   codec: String,
     *   limitaion: Object,
     *   size: Object
     * }]>}
     */
    )
  }, {
    key: "getVideoRemoteStats",
    value: (function () {
      var _getVideoRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee100() {
        var producer;
        return regenerator_default().wrap(function (_context100) {
          while (1) switch (_context100.prev = _context100.next) {
            case 0:
              logger.debug("getVideoRemoteStats()");
              producer = this._webcamProducer;
              if (producer) {
                _context100.next = 1;
                break;
              }
              return _context100.abrupt("return");
            case 1:
              return _context100.abrupt("return", this._latestStats[producer.id]);
            case 2:
            case "end":
              return _context100.stop();
          }
        }, _callee100, this);
      }));
      function getVideoRemoteStats() {
        return _getVideoRemoteStats.apply(this, arguments);
      }
      return getVideoRemoteStats;
    }()
    /**
     *
     * @returns {Promise<[{
     *   bitrate: number,
     *   roundTripTime: number,
     *   jitter: number,
     *   totalPackets: number,
     *   packetsLost: number,
     *   network: String,
     *   codec: String,
     *   limitaion: Object,
     *   size: Object
     * }]>}
     */
    )
  }, {
    key: "getShareRemoteStats",
    value: (function () {
      var _getShareRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee101() {
        var producer;
        return regenerator_default().wrap(function (_context101) {
          while (1) switch (_context101.prev = _context101.next) {
            case 0:
              logger.debug("getVideoRemoteStats()");
              producer = this._shareProducer;
              if (producer) {
                _context101.next = 1;
                break;
              }
              return _context101.abrupt("return");
            case 1:
              return _context101.abrupt("return", this._latestStats[producer.id]);
            case 2:
            case "end":
              return _context101.stop();
          }
        }, _callee101, this);
      }));
      function getShareRemoteStats() {
        return _getShareRemoteStats.apply(this, arguments);
      }
      return getShareRemoteStats;
    }())
  }, {
    key: "getShareAudioRemoteStats",
    value: function () {
      var _getShareAudioRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee102() {
        var shareAudioProducer;
        return regenerator_default().wrap(function (_context102) {
          while (1) switch (_context102.prev = _context102.next) {
            case 0:
              shareAudioProducer = this._shareAudioProducer;
              if (shareAudioProducer) {
                _context102.next = 1;
                break;
              }
              return _context102.abrupt("return");
            case 1:
              return _context102.abrupt("return", this._latestStats[shareAudioProducer.id]);
            case 2:
            case "end":
              return _context102.stop();
          }
        }, _callee102, this);
      }));
      function getShareAudioRemoteStats() {
        return _getShareAudioRemoteStats.apply(this, arguments);
      }
      return getShareAudioRemoteStats;
    }()
    /**
     *
     * @param {string} consumerId
     * @returns {Promise<[{
     *   bitrate: number,
     *   rtt: number,
     *   network:String,
     *   codec: String,
     *   jitter: number,
     *   totalPackets: number,
     *   packetsLost: number,
     *   concealmentEvents: number,
     *   insertedSamplesForDecelaration: number,
     *   removedSamplesForAccelaration: number,
     *   size:Object
     * }]>}
     */
  }, {
    key: "getConsumerRemoteStats",
    value: (function () {
      var _getConsumerRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee103(consumerId) {
        var consumer, result;
        return regenerator_default().wrap(function (_context103) {
          while (1) switch (_context103.prev = _context103.next) {
            case 0:
              logger.debug("getConsumerRemoteStats()");
              consumer = this._consumers.get(consumerId);
              if (consumer) {
                _context103.next = 1;
                break;
              }
              return _context103.abrupt("return");
            case 1:
              if (this._latestStats[consumerId]) {
                this._latestStats[consumerId][0].currentSpatialLayer = consumer.currentSpatialLayer;
                this._latestStats[consumerId][0].currentTemporalLayer = consumer.currentTemporalLayer;
                this._latestStats[consumerId][0].preferredSpatialLayer = consumer.preferredSpatialLayer;
                this._latestStats[consumerId][0].preferredTemporalLayer = consumer.preferredTemporalLayer;
              }
              result = consumer.track.id.replace(/[{}]/g, "");
              return _context103.abrupt("return", this._latestStats[result]);
            case 2:
            case "end":
              return _context103.stop();
          }
        }, _callee103, this);
      }));
      function getConsumerRemoteStats(_x97) {
        return _getConsumerRemoteStats.apply(this, arguments);
      }
      return getConsumerRemoteStats;
    }())
  }, {
    key: "getChatDataProducerRemoteStats",
    value: function () {
      var _getChatDataProducerRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee104() {
        var dataProducer;
        return regenerator_default().wrap(function (_context104) {
          while (1) switch (_context104.prev = _context104.next) {
            case 0:
              logger.debug("getChatDataProducerRemoteStats()");
              dataProducer = this._reliableDataProducer;
              if (dataProducer) {
                _context104.next = 1;
                break;
              }
              return _context104.abrupt("return");
            case 1:
              return _context104.abrupt("return", this._socketRequest("getDataProducerStats", {
                dataProducerId: dataProducer.id
              }));
            case 2:
            case "end":
              return _context104.stop();
          }
        }, _callee104, this);
      }));
      function getChatDataProducerRemoteStats() {
        return _getChatDataProducerRemoteStats.apply(this, arguments);
      }
      return getChatDataProducerRemoteStats;
    }()
  }, {
    key: "getDataConsumerRemoteStats",
    value: function () {
      var _getDataConsumerRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee105(dataConsumerId) {
        var dataConsumer;
        return regenerator_default().wrap(function (_context105) {
          while (1) switch (_context105.prev = _context105.next) {
            case 0:
              logger.debug("getDataConsumerRemoteStats()");
              dataConsumer = this._dataConsumers.get(dataConsumerId);
              if (dataConsumer) {
                _context105.next = 1;
                break;
              }
              return _context105.abrupt("return");
            case 1:
              return _context105.abrupt("return", this._socketRequest("getDataConsumerStats", {
                dataConsumerId: dataConsumerId
              }));
            case 2:
            case "end":
              return _context105.stop();
          }
        }, _callee105, this);
      }));
      function getDataConsumerRemoteStats(_x98) {
        return _getDataConsumerRemoteStats.apply(this, arguments);
      }
      return getDataConsumerRemoteStats;
    }()
  }, {
    key: "getSendTransportLocalStats",
    value: function () {
      var _getSendTransportLocalStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee106() {
        return regenerator_default().wrap(function (_context106) {
          while (1) switch (_context106.prev = _context106.next) {
            case 0:
              logger.debug("getSendTransportLocalStats()");
              if (this._sendTransport) {
                _context106.next = 1;
                break;
              }
              return _context106.abrupt("return");
            case 1:
              return _context106.abrupt("return", this._sendTransport.getStats());
            case 2:
            case "end":
              return _context106.stop();
          }
        }, _callee106, this);
      }));
      function getSendTransportLocalStats() {
        return _getSendTransportLocalStats.apply(this, arguments);
      }
      return getSendTransportLocalStats;
    }()
  }, {
    key: "getRecvTransportLocalStats",
    value: function () {
      var _getRecvTransportLocalStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee107() {
        return regenerator_default().wrap(function (_context107) {
          while (1) switch (_context107.prev = _context107.next) {
            case 0:
              logger.debug("getRecvTransportLocalStats()");
              if (this._recvTransport) {
                _context107.next = 1;
                break;
              }
              return _context107.abrupt("return");
            case 1:
              return _context107.abrupt("return", this._recvTransport.getStats());
            case 2:
            case "end":
              return _context107.stop();
          }
        }, _callee107, this);
      }));
      function getRecvTransportLocalStats() {
        return _getRecvTransportLocalStats.apply(this, arguments);
      }
      return getRecvTransportLocalStats;
    }()
  }, {
    key: "getAudioLocalStats",
    value: function () {
      var _getAudioLocalStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee108() {
        return regenerator_default().wrap(function (_context108) {
          while (1) switch (_context108.prev = _context108.next) {
            case 0:
              logger.debug("getAudioLocalStats()");
              if (this._micProducer) {
                _context108.next = 1;
                break;
              }
              return _context108.abrupt("return");
            case 1:
              return _context108.abrupt("return", this._micProducer.getStats());
            case 2:
            case "end":
              return _context108.stop();
          }
        }, _callee108, this);
      }));
      function getAudioLocalStats() {
        return _getAudioLocalStats.apply(this, arguments);
      }
      return getAudioLocalStats;
    }()
  }, {
    key: "getVideoLocalStats",
    value: function () {
      var _getVideoLocalStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee109() {
        var producer;
        return regenerator_default().wrap(function (_context109) {
          while (1) switch (_context109.prev = _context109.next) {
            case 0:
              logger.debug("getVideoLocalStats()");
              producer = this._webcamProducer || this._shareProducer;
              if (producer) {
                _context109.next = 1;
                break;
              }
              return _context109.abrupt("return");
            case 1:
              return _context109.abrupt("return", producer.getStats());
            case 2:
            case "end":
              return _context109.stop();
          }
        }, _callee109, this);
      }));
      function getVideoLocalStats() {
        return _getVideoLocalStats.apply(this, arguments);
      }
      return getVideoLocalStats;
    }()
  }, {
    key: "getConsumerLocalStats",
    value: function () {
      var _getConsumerLocalStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee110(consumerId) {
        var consumer;
        return regenerator_default().wrap(function (_context110) {
          while (1) switch (_context110.prev = _context110.next) {
            case 0:
              consumer = this._consumers.get(consumerId);
              if (consumer) {
                _context110.next = 1;
                break;
              }
              return _context110.abrupt("return");
            case 1:
              return _context110.abrupt("return", consumer.getStats());
            case 2:
            case "end":
              return _context110.stop();
          }
        }, _callee110, this);
      }));
      function getConsumerLocalStats(_x99) {
        return _getConsumerLocalStats.apply(this, arguments);
      }
      return getConsumerLocalStats;
    }()
  }, {
    key: "getTransportRemoteStats",
    value: function () {
      var _getTransportRemoteStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee111(_ref24) {
        var _response$recv, _response$recv2;
        var participantId, response, result;
        return regenerator_default().wrap(function (_context111) {
          while (1) switch (_context111.prev = _context111.next) {
            case 0:
              participantId = _ref24.participantId;
              if (participantId) {
                _context111.next = 1;
                break;
              }
              return _context111.abrupt("return");
            case 1:
              _context111.next = 2;
              return this._socketRequest("getTransportStats", {
                peerId: participantId
              });
            case 2:
              response = _context111.sent;
              result = {
                availableBitrate: response === null || response === void 0 || (_response$recv = response.recv) === null || _response$recv === void 0 ? void 0 : _response$recv.availableBitrate,
                targetBitrate: response === null || response === void 0 || (_response$recv2 = response.recv) === null || _response$recv2 === void 0 ? void 0 : _response$recv2.targetBitrate
              };
              return _context111.abrupt("return", result);
            case 3:
            case "end":
              return _context111.stop();
          }
        }, _callee111, this);
      }));
      function getTransportRemoteStats(_x100) {
        return _getTransportRemoteStats.apply(this, arguments);
      }
      return getTransportRemoteStats;
    }()
  }, {
    key: "applyNetworkThrottle",
    value: function () {
      var _applyNetworkThrottle = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee112(_ref25) {
        var uplink, downlink, rtt, secret, _t82;
        return regenerator_default().wrap(function (_context112) {
          while (1) switch (_context112.prev = _context112.next) {
            case 0:
              uplink = _ref25.uplink, downlink = _ref25.downlink, rtt = _ref25.rtt, secret = _ref25.secret;
              logger.debug("applyNetworkThrottle() [uplink:%s, downlink:%s, rtt:%s]", uplink, downlink, rtt);
              _context112.prev = 1;
              _context112.next = 2;
              return this._socketRequest("applyNetworkThrottle", {
                uplink: uplink,
                downlink: downlink,
                rtt: rtt,
                secret: secret
              });
            case 2:
              _context112.next = 4;
              break;
            case 3:
              _context112.prev = 3;
              _t82 = _context112["catch"](1);
              logger.error("applyNetworkThrottle() | failed:%o", _t82);
              store.dispatch(notify({
                type: "error",
                text: "Error applying network throttle: ".concat(_t82)
              }));
            case 4:
            case "end":
              return _context112.stop();
          }
        }, _callee112, this, [[1, 3]]);
      }));
      function applyNetworkThrottle(_x101) {
        return _applyNetworkThrottle.apply(this, arguments);
      }
      return applyNetworkThrottle;
    }()
  }, {
    key: "resetNetworkThrottle",
    value: function () {
      var _resetNetworkThrottle = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee113(_ref26) {
        var _ref26$silent, silent, secret, _t83;
        return regenerator_default().wrap(function (_context113) {
          while (1) switch (_context113.prev = _context113.next) {
            case 0:
              _ref26$silent = _ref26.silent, silent = _ref26$silent === void 0 ? false : _ref26$silent, secret = _ref26.secret;
              logger.debug("resetNetworkThrottle()");
              _context113.prev = 1;
              _context113.next = 2;
              return this._socketRequest("resetNetworkThrottle", {
                secret: secret
              });
            case 2:
              _context113.next = 4;
              break;
            case 3:
              _context113.prev = 3;
              _t83 = _context113["catch"](1);
              if (!silent) {
                logger.error("resetNetworkThrottle() | failed:%o", _t83);
                store.dispatch(notify({
                  type: "error",
                  text: "Error resetting network throttle: ".concat(_t83)
                }));
              }
            case 4:
            case "end":
              return _context113.stop();
          }
        }, _callee113, this, [[1, 3]]);
      }));
      function resetNetworkThrottle(_x102) {
        return _resetNetworkThrottle.apply(this, arguments);
      }
      return resetNetworkThrottle;
    }()
  }, {
    key: "createProducerTransport",
    value: function () {
      var _createProducerTransport = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee118(transportInfo, parentSpan) {
        var _this$_openTelemetry223,
          _this0 = this,
          _this$_openTelemetry224;
        var id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, producerTransportspan, outbTraces, remoteInbTraces, ewmaRttInMs, congested, cpuLimited, bandwidthLimited, reportCounter, probe;
        return regenerator_default().wrap(function (_context118) {
          while (1) switch (_context118.prev = _context118.next) {
            case 0:
              id = transportInfo.id, iceParameters = transportInfo.iceParameters, iceCandidates = transportInfo.iceCandidates, dtlsParameters = transportInfo.dtlsParameters, sctpParameters = transportInfo.sctpParameters;
              producerTransportspan = (_this$_openTelemetry223 = this._openTelemetry) === null || _this$_openTelemetry223 === void 0 ? void 0 : _this$_openTelemetry223.trace({
                spanName: "Creating Send Transport",
                span: parentSpan ? parentSpan : null
              });
              this._sendTransport = this._mediasoupDevice.createSendTransport({
                id: id,
                iceParameters: iceParameters,
                iceCandidates: iceCandidates,
                dtlsParameters: dtlsParameters,
                sctpParameters: sctpParameters,
                iceServers: this._iceServers
              });
              outbTraces = new Map();
              remoteInbTraces = new Map();
              congested = false;
              cpuLimited = false;
              bandwidthLimited = false;
              this._sendTransportInternal = setInterval(/*#__PURE__*/(0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee114() {
                var roundTripTimeMeasurements, reports, _this0$_sendTransport, avgRoundTripTimeInMs, isCurrentlyBandwidthLimited, isCurrentlyCPULimited, _this0$_videosdkLogs, _this0$_videosdkLogs2, _this0$_videosdkLogs3, _this0$_videosdkLogs4, _this0$_videosdkLogs5, _this0$_videosdkLogs6, _t84;
                return regenerator_default().wrap(function (_context114) {
                  while (1) switch (_context114.prev = _context114.next) {
                    case 0:
                      roundTripTimeMeasurements = [];
                      _context114.prev = 1;
                      _context114.next = 2;
                      return (_this0$_sendTransport = _this0._sendTransport) === null || _this0$_sendTransport === void 0 ? void 0 : _this0$_sendTransport.getStats();
                    case 2:
                      reports = _context114.sent;
                      _context114.next = 4;
                      break;
                    case 3:
                      _context114.prev = 3;
                      _t84 = _context114["catch"](1);
                      console.error("Error fetching stats:", _t84);
                      return _context114.abrupt("return");
                    case 4:
                      try {
                        reports.forEach(function (report) {
                          try {
                            if (report.type === "outbound-rtp") {
                              var newTrace = {
                                qualityLimitationReason: report.qualityLimitationReason
                              };
                              outbTraces.set(report.id, newTrace);
                            }
                            if (report.type === "remote-inbound-rtp" && report.totalRoundTripTime && report.roundTripTimeMeasurements) {
                              var trace = remoteInbTraces.get(report.id);
                              if (!trace) {
                                trace = {
                                  totalRoundTripTime: 0,
                                  roundTripTimeMeasurements: 0
                                };
                                remoteInbTraces.set(report.id, trace);
                              }
                              var diffMeasurements = report.roundTripTimeMeasurements - trace.roundTripTimeMeasurements;
                              var diffTotalRoundTripTime = report.totalRoundTripTime - trace.totalRoundTripTime;
                              if (diffMeasurements > 0 && diffTotalRoundTripTime > 0) {
                                var avgRttInInterval = diffTotalRoundTripTime / diffMeasurements;
                                trace.totalRoundTripTime = report.totalRoundTripTime;
                                trace.roundTripTimeMeasurements = report.roundTripTimeMeasurements;
                                roundTripTimeMeasurements.push(avgRttInInterval * 1000);
                              }
                            }
                          } catch (e) {}
                        });
                        try {
                          avgRoundTripTimeInMs = roundTripTimeMeasurements.reduce(function (a, b) {
                            return a + b;
                          }, 0) / roundTripTimeMeasurements.length;
                          if (!Number.isNaN(avgRoundTripTimeInMs)) {
                            if (!ewmaRttInMs) {
                              ewmaRttInMs = avgRoundTripTimeInMs;
                            }
                            isCurrentlyBandwidthLimited = (0,toConsumableArray/* default */.A)(outbTraces.values()).some(function (trace) {
                              return trace.qualityLimitationReason === "bandwidth";
                            });
                            isCurrentlyCPULimited = (0,toConsumableArray/* default */.A)(outbTraces.values()).some(function (trace) {
                              return trace.qualityLimitationReason === "cpu";
                            });
                            if (!congested && isCurrentlyBandwidthLimited && avgRoundTripTimeInMs - ewmaRttInMs > 50) {
                              (_this0$_videosdkLogs = _this0._videosdkLogs) === null || _this0$_videosdkLogs === void 0 || _this0$_videosdkLogs.pushLogs({
                                logType: "WARN",
                                attributes: {
                                  avgRoundTripTimeInMs: avgRoundTripTimeInMs,
                                  ewmaRttInMs: ewmaRttInMs
                                },
                                logText: "Send Transport Congestion detected, the network is bandwidth limited and the round trip time is increasing (ewmaRtt: ".concat(ewmaRttInMs, ", avgRoundTripTime: ").concat(avgRoundTripTimeInMs, ")")
                              });
                              congested = true;
                              _this0._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                type: "congestion",
                                state: "detected",
                                timestamp: new Date().getTime()
                              });
                            } else if (congested && avgRoundTripTimeInMs - ewmaRttInMs < 30) {
                              (_this0$_videosdkLogs2 = _this0._videosdkLogs) === null || _this0$_videosdkLogs2 === void 0 || _this0$_videosdkLogs2.pushLogs({
                                logType: "INFO",
                                attributes: {
                                  avgRoundTripTimeInMs: avgRoundTripTimeInMs,
                                  ewmaRttInMs: ewmaRttInMs
                                },
                                logText: "Send Transport  Congestion resolved, the round trip time is back to normal (ewmaRtt: ".concat(ewmaRttInMs, ", avgRoundTripTime: ").concat(avgRoundTripTimeInMs, ")")
                              });
                              congested = false;
                              _this0._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                type: "congestion",
                                state: "resolved",
                                timestamp: new Date().getTime()
                              });
                            }
                            if (isCurrentlyBandwidthLimited && !bandwidthLimited) {
                              (_this0$_videosdkLogs3 = _this0._videosdkLogs) === null || _this0$_videosdkLogs3 === void 0 || _this0$_videosdkLogs3.pushLogs({
                                logType: "WARN",
                                logText: "Bandwidth Limitation detected"
                              });
                              _this0._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                type: "bandwidth",
                                state: "detected",
                                timestamp: new Date().getTime()
                              });
                              bandwidthLimited = true;
                            } else if (!isCurrentlyBandwidthLimited && bandwidthLimited) {
                              (_this0$_videosdkLogs4 = _this0._videosdkLogs) === null || _this0$_videosdkLogs4 === void 0 || _this0$_videosdkLogs4.pushLogs({
                                logType: "INFO",
                                logText: "Bandwidth Limitation resolved"
                              });
                              _this0._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                type: "bandwidth",
                                state: "resolved",
                                timestamp: new Date().getTime()
                              });
                              bandwidthLimited = false;
                            }
                            ewmaRttInMs = 0.9 * ewmaRttInMs + 0.1 * avgRoundTripTimeInMs;
                            if (!cpuLimited && isCurrentlyCPULimited) {
                              _this0._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                type: "cpu",
                                state: "detected",
                                timestamp: new Date().getTime()
                              });
                              (_this0$_videosdkLogs5 = _this0._videosdkLogs) === null || _this0$_videosdkLogs5 === void 0 || _this0$_videosdkLogs5.pushLogs({
                                logType: "WARN",
                                logText: "CPU Limitation detected"
                              });
                              cpuLimited = true;
                            } else if (cpuLimited && !isCurrentlyCPULimited) {
                              _this0._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                type: "cpu",
                                state: "resolved",
                                timestamp: new Date().getTime()
                              });
                              (_this0$_videosdkLogs6 = _this0._videosdkLogs) === null || _this0$_videosdkLogs6 === void 0 || _this0$_videosdkLogs6.pushLogs({
                                logType: "INFO",
                                logText: "CPU Limitation resolved"
                              });
                              cpuLimited = false;
                            }
                          }
                        } catch (eee) {}
                      } catch (err) {}
                    case 5:
                    case "end":
                      return _context114.stop();
                  }
                }, _callee114, null, [[1, 3]]);
              })), 1000);
              this._sendTransport.on("connect", function (_ref28, callback, errback // eslint-disable-line no-shadow
              ) {
                var _this0$_openTelemetry;
                var dtlsParameters = _ref28.dtlsParameters;
                (_this0$_openTelemetry = _this0._openTelemetry) === null || _this0$_openTelemetry === void 0 || _this0$_openTelemetry.traceAutoComplete({
                  spanName: "this._sendTransport `connect` Event : Transport is about to establish the ICE+DTLS connection",
                  span: producerTransportspan,
                  status: 1
                });
                _this0._socketRequest("connectWebRtcTransport", {
                  transportId: _this0._sendTransport.id,
                  dtlsParameters: dtlsParameters
                }).then(function () {
                  callback();
                })["catch"](function (error) {
                  errback(error);
                });
              });
              this._sendTransport.on("produce", /*#__PURE__*/function () {
                var _ref30 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee115(_ref29, callback, errback) {
                  var kind, rtpParameters, appData, _this0$_openTelemetry2, _yield$_this0$_socket, _id3, _this0$_videosdkLogs7, _t85;
                  return regenerator_default().wrap(function (_context115) {
                    while (1) switch (_context115.prev = _context115.next) {
                      case 0:
                        kind = _ref29.kind, rtpParameters = _ref29.rtpParameters, appData = _ref29.appData;
                        _context115.prev = 1;
                        (_this0$_openTelemetry2 = _this0._openTelemetry) === null || _this0$_openTelemetry2 === void 0 || _this0$_openTelemetry2.traceAutoComplete({
                          spanName: "this._sendTransport `produce` Event : Transmit information about a new producer ",
                          span: producerTransportspan,
                          status: 1
                        });
                        _context115.next = 2;
                        return _this0._socketRequest("produce", {
                          transportId: _this0._sendTransport.id,
                          kind: kind,
                          rtpParameters: rtpParameters,
                          appData: appData
                        });
                      case 2:
                        _yield$_this0$_socket = _context115.sent;
                        _id3 = _yield$_this0$_socket.id;
                        callback({
                          id: _id3
                        });
                        _context115.next = 4;
                        break;
                      case 3:
                        _context115.prev = 3;
                        _t85 = _context115["catch"](1);
                        (_this0$_videosdkLogs7 = _this0._videosdkLogs) === null || _this0$_videosdkLogs7 === void 0 || _this0$_videosdkLogs7.pushLogs({
                          logText: "Error this._sendTransport \"produce\" Event catch",
                          logType: "ERROR",
                          attributes: {
                            error: _t85.message
                          }
                        });
                        errback(_t85);
                      case 4:
                      case "end":
                        return _context115.stop();
                    }
                  }, _callee115, null, [[1, 3]]);
                }));
                return function (_x105, _x106, _x107) {
                  return _ref30.apply(this, arguments);
                };
              }());
              this._sendTransport.on("producedata", /*#__PURE__*/function () {
                var _ref32 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee116(_ref31, callback, errback) {
                  var sctpStreamParameters, label, protocol, appData, _yield$_this0$_socket2, _id4, _this0$_videosdkLogs8, _t86;
                  return regenerator_default().wrap(function (_context116) {
                    while (1) switch (_context116.prev = _context116.next) {
                      case 0:
                        sctpStreamParameters = _ref31.sctpStreamParameters, label = _ref31.label, protocol = _ref31.protocol, appData = _ref31.appData;
                        _context116.prev = 1;
                        _context116.next = 2;
                        return _this0._socketRequest("produceData", {
                          transportId: _this0._sendTransport.id,
                          sctpStreamParameters: sctpStreamParameters,
                          label: label,
                          protocol: protocol,
                          appData: appData
                        });
                      case 2:
                        _yield$_this0$_socket2 = _context116.sent;
                        _id4 = _yield$_this0$_socket2.id;
                        callback({
                          id: _id4
                        });
                        _context116.next = 4;
                        break;
                      case 3:
                        _context116.prev = 3;
                        _t86 = _context116["catch"](1);
                        (_this0$_videosdkLogs8 = _this0._videosdkLogs) === null || _this0$_videosdkLogs8 === void 0 || _this0$_videosdkLogs8.pushLogs({
                          logText: "Error producedata event catch",
                          logType: "ERROR",
                          attributes: {
                            error: _t86.message
                          }
                        });
                        errback(_t86);
                      case 4:
                      case "end":
                        return _context116.stop();
                    }
                  }, _callee116, null, [[1, 3]]);
                }));
                return function (_x108, _x109, _x110) {
                  return _ref32.apply(this, arguments);
                };
              }());
              this._sendTransport.on("connectionstatechange", /*#__PURE__*/function () {
                var _ref33 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee117(connectionState) {
                  var _this0$_openTelemetry3;
                  var candidates, _this0$_videosdkLogs9, _this0$_videosdkLogs0, _t87;
                  return regenerator_default().wrap(function (_context117) {
                    while (1) switch (_context117.prev = _context117.next) {
                      case 0:
                        _t87 = Array;
                        _context117.next = 1;
                        return _this0._sendTransport.getStats();
                      case 1:
                        candidates = _t87.from.call(_t87, _context117.sent).filter(function (_ref34) {
                          var _ref35 = (0,slicedToArray/* default */.A)(_ref34, 2),
                            data = _ref35[1];
                          return data.type === "local-candidate" || data.type === "remote-candidate";
                        }).map(function (_ref36) {
                          var _ref37 = (0,slicedToArray/* default */.A)(_ref36, 2),
                            data = _ref37[1];
                          return data;
                        });
                        if (candidates.length > 0) {
                          (_this0$_videosdkLogs9 = _this0._videosdkLogs) === null || _this0$_videosdkLogs9 === void 0 || _this0$_videosdkLogs9.pushLogs({
                            logText: "Send Trasnport State Change \"".concat(connectionState, "\" candidates"),
                            logType: "INFO",
                            attributes: {
                              candidates: JSON.stringify(candidates)
                            }
                          });
                        }
                        if (connectionState === "connected") {
                          _this0.emitMeetingStateChange(state.CONNECTED);
                        }
                        (_this0$_openTelemetry3 = _this0._openTelemetry) === null || _this0$_openTelemetry3 === void 0 || _this0$_openTelemetry3.traceAutoComplete({
                          spanName: "_sendTransport Event connectionstatechange ".concat(connectionState),
                          span: producerTransportspan,
                          status: 1
                        });
                        if (connectionState === "failed") {
                          (_this0$_videosdkLogs0 = _this0._videosdkLogs) === null || _this0$_videosdkLogs0 === void 0 || _this0$_videosdkLogs0.pushLogs({
                            logText: "ERROR_MEETING_MEDIA_CONNECTION_FAILED",
                            logType: "ERROR",
                            attributes: {
                              error: "Unable to connect to the meeting or media. Please check your network connection, ensure your firewall or security settings are not blocking the application, or try connecting using a different network."
                            },
                            dashboardLog: true
                          });
                          _this0.restartIce();
                        }
                        _this0._transportState = connectionState;
                      case 2:
                      case "end":
                        return _context117.stop();
                    }
                  }, _callee117);
                }));
                return function (_x111) {
                  return _ref33.apply(this, arguments);
                };
              }());
              reportCounter = 0;
              probe = this._metrics.addNewProbe(this._sendTransport, "transport");
              probe.onStatsCollected = function (report) {
                try {
                  var processStat = function processStat(stat, producer, producertype) {
                    if (!_this0._stats.producerStats) {
                      _this0._stats.producerStats = {};
                    }
                    var peerId = _this0._peerId;
                    if (!_this0._stats.producerStats[peerId]) {
                      _this0._stats.producerStats[peerId] = {};
                    }
                    if (!_this0._stats.producerStats[peerId][producertype]) {
                      _this0._stats.producerStats[peerId][producertype] = [];
                    }
                    _this0._latestStats[producer.id] = [stat];
                    if (reportCounter % 5 === 0) {
                      _this0._stats.producerStats[peerId][producertype].push(stat);
                    }
                  };
                  var processReport = function processReport(producer, kind, reportType) {
                    if (report[reportType]) {
                      report[reportType].forEach(function (stat) {
                        if (producer && producer.track && !producer._paused) {
                          processStat(stat, producer, kind);
                        }
                      });
                    }
                  };
                  if (report.video) {
                    if (_this0._shareProducer && _this0._shareProducer.appData && _this0._shareProducer.appData.share) {
                      processReport(_this0._shareProducer, "share", "video");
                    }
                    if (_this0._webcamProducer) {
                      processReport(_this0._webcamProducer, "video", "video");
                    }
                  }
                  if (report.audio) {
                    if (_this0._shareAudioProducer && _this0._shareAudioProducer.appData && _this0._shareAudioProducer.appData.share) {
                      processReport(_this0._shareAudioProducer, "shareAudio", "audio");
                    }
                    if (_this0._micProducer) {
                      processReport(_this0._micProducer, "audio", "audio");
                    }
                  }
                  reportCounter++;
                } catch (error) {
                  var _this0$_videosdkLogs1;
                  (_this0$_videosdkLogs1 = _this0._videosdkLogs) === null || _this0$_videosdkLogs1 === void 0 || _this0$_videosdkLogs1.pushLogs({
                    logText: "Error PRODUCER Stats ERROR",
                    logType: "ERROR",
                    attributes: {
                      error: error.message
                    }
                  });
                  console.log("PRODUCER CATCH", error);
                }
              };
              probe.start();
              this._sendTransport.observer.on("close", function () {
                probe.stop();
                _this0._metrics.removeExistingProbe(probe);
              });
              (_this$_openTelemetry224 = this._openTelemetry) === null || _this$_openTelemetry224 === void 0 || _this$_openTelemetry224.completeSpan({
                span: producerTransportspan,
                status: 1,
                message: "Send Transport Created Successfully"
              });
            case 1:
            case "end":
              return _context118.stop();
          }
        }, _callee118, this);
      }));
      function createProducerTransport(_x103, _x104) {
        return _createProducerTransport.apply(this, arguments);
      }
      return createProducerTransport;
    }()
  }, {
    key: "createConsumerTransport",
    value: function () {
      var _createConsumerTransport = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee120(transportInfo, parentSpan) {
        var _this$_openTelemetry225,
          _this1 = this,
          _this$_openTelemetry226;
        var id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, consumerTransportspan, reportCounter, probe, traces, freezeTraces, freezeTimestamps, freezeResolvedEmitted;
        return regenerator_default().wrap(function (_context120) {
          while (1) switch (_context120.prev = _context120.next) {
            case 0:
              id = transportInfo.id, iceParameters = transportInfo.iceParameters, iceCandidates = transportInfo.iceCandidates, dtlsParameters = transportInfo.dtlsParameters, sctpParameters = transportInfo.sctpParameters;
              consumerTransportspan = (_this$_openTelemetry225 = this._openTelemetry) === null || _this$_openTelemetry225 === void 0 ? void 0 : _this$_openTelemetry225.trace({
                spanName: "Creating Recieve Transport",
                span: parentSpan ? parentSpan : null
              });
              this._recvTransport = this._mediasoupDevice.createRecvTransport({
                id: id,
                iceParameters: iceParameters,
                iceCandidates: iceCandidates,
                dtlsParameters: dtlsParameters,
                sctpParameters: sctpParameters,
                iceServers: this._iceServers
              });
              this._recvTransport.on("connect", function (_ref38, callback, errback // eslint-disable-line no-shadow
              ) {
                var _this1$_openTelemetry;
                var dtlsParameters = _ref38.dtlsParameters;
                (_this1$_openTelemetry = _this1._openTelemetry) === null || _this1$_openTelemetry === void 0 || _this1$_openTelemetry.traceAutoComplete({
                  spanName: "this._recvTransport `connect` Event : Recieve Transport is about to establish the ICE+DTLS connection",
                  span: consumerTransportspan,
                  status: 1
                });
                _this1._socketRequest("connectWebRtcTransport", {
                  transportId: _this1._recvTransport.id,
                  dtlsParameters: dtlsParameters
                }).then(function () {
                  callback();
                })["catch"](function (error) {
                  errback(error);
                });
              });
              this._recvTransport.on("connectionstatechange", /*#__PURE__*/function () {
                var _ref39 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee119(connectionState) {
                  var _this1$_openTelemetry2;
                  var candidates, _this1$_videosdkLogs, _t88;
                  return regenerator_default().wrap(function (_context119) {
                    while (1) switch (_context119.prev = _context119.next) {
                      case 0:
                        _t88 = Array;
                        _context119.next = 1;
                        return _this1._recvTransport.getStats();
                      case 1:
                        candidates = _t88.from.call(_t88, _context119.sent).filter(function (_ref40) {
                          var _ref41 = (0,slicedToArray/* default */.A)(_ref40, 2),
                            data = _ref41[1];
                          return data.type === "local-candidate" || data.type === "remote-candidate";
                        }).map(function (_ref42) {
                          var _ref43 = (0,slicedToArray/* default */.A)(_ref42, 2),
                            data = _ref43[1];
                          return data;
                        });
                        if (candidates.length > 0) {
                          (_this1$_videosdkLogs = _this1._videosdkLogs) === null || _this1$_videosdkLogs === void 0 || _this1$_videosdkLogs.pushLogs({
                            logText: "Recv Trasnport State Change \"".concat(connectionState, "\" candidates"),
                            logType: "INFO",
                            attributes: {
                              candidates: JSON.stringify(candidates)
                            }
                          });
                        }
                        (_this1$_openTelemetry2 = _this1._openTelemetry) === null || _this1$_openTelemetry2 === void 0 || _this1$_openTelemetry2.traceAutoComplete({
                          spanName: "_recvTransport Event connectionstatechange ".concat(connectionState),
                          span: consumerTransportspan,
                          status: 1
                        });
                        if (connectionState === "failed") {
                          _this1.restartIce();
                        }
                        _this1._transportState = connectionState;
                      case 2:
                      case "end":
                        return _context119.stop();
                    }
                  }, _callee119);
                }));
                return function (_x114) {
                  return _ref39.apply(this, arguments);
                };
              }());
              reportCounter = 0;
              probe = this._metrics.addNewProbe(this._recvTransport, "transport");
              traces = new Map();
              freezeTraces = new Map();
              freezeTimestamps = new Map();
              freezeResolvedEmitted = new Set();
              probe.onStatsCollected = function (report) {
                try {
                  var processStat = function processStat(stat, consumer, consumerType) {
                    if (!_this1._stats.consumerStats) {
                      _this1._stats.consumerStats = {};
                    }
                    var peerId = consumer.appData.peerId;
                    if (!_this1._stats.consumerStats[peerId]) {
                      _this1._stats.consumerStats[peerId] = {};
                    }
                    if (!_this1._stats.consumerStats[peerId][consumerType]) {
                      _this1._stats.consumerStats[peerId][consumerType] = [];
                    }
                    _this1._latestStats[consumer.track.id.replace(/[{}]/g, "")] = [stat];
                    if (reportCounter % 5 === 0) {
                      _this1._stats.consumerStats[peerId][consumerType].push(stat);
                    }
                  };
                  var processReport = function processReport(reportType) {
                    report[reportType].forEach(function (stat) {
                      var _iterator5 = RoomClient_createForOfIteratorHelper(_this1._consumers),
                        _step5;
                      try {
                        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                          var _step5$value = (0,slicedToArray/* default */.A)(_step5.value, 2),
                            _id5 = _step5$value[0],
                            consumer = _step5$value[1];
                          var consumerTrackId = consumer.track.id.replace(/[{}]/g, "");
                          if (consumerTrackId === stat.trackId) {
                            var consumerType = consumer.appData["share"] ? consumer.kind === "audio" ? "shareAudio" : "share" : consumer.kind;
                            processStat(stat, consumer, consumerType);
                            if (consumerType === "audio" || consumerType === "shareAudio") return;
                            if (stat.bitrate > 0) {
                              if (traces.has(consumerTrackId)) {
                                traces["delete"](consumerTrackId);
                              }
                            } else {
                              var trace = traces.get(consumerTrackId);
                              if (!trace) {
                                traces.set(consumerTrackId, {
                                  detected: Date.now()
                                });
                              } else if (trace.detected + 5000 < Date.now()) {
                                _this1._eventEmitter.emit("STREAM_STATE_CHANGED", {
                                  state: "stuck",
                                  peerId: consumer.appData.peerId,
                                  streamId: consumerTrackId
                                });
                              }
                            }
                            var trackId = stat.trackId,
                              freezeCount = stat.freezeCount;
                            if (!trackId || freezeCount === undefined) return;
                            var lastFreezeCount = freezeTraces.get(trackId);
                            if (lastFreezeCount === undefined) {
                              freezeTraces.set(trackId, freezeCount);
                              return;
                            }
                            if (freezeCount > lastFreezeCount) {
                              _this1._eventEmitter.emit("STREAM_STATE_CHANGED", {
                                state: "freeze-detected",
                                peerId: consumer.appData.peerId,
                                streamId: consumerTrackId
                              });
                              freezeTimestamps.set(trackId, Date.now());
                              freezeResolvedEmitted["delete"](trackId);
                            } else {
                              // Check for freeze resolution (e.g., no new freeze for 5 seconds)
                              var lastFreezeAt = freezeTimestamps.get(trackId);
                              if (lastFreezeAt && !freezeResolvedEmitted.has(trackId)) {
                                var timeSinceLastFreeze = Date.now() - lastFreezeAt;
                                if (timeSinceLastFreeze > 5000) {
                                  // 5 seconds threshold
                                  _this1._eventEmitter.emit("STREAM_STATE_CHANGED", {
                                    state: "freeze-resolved",
                                    peerId: consumer.appData.peerId,
                                    streamId: consumerTrackId
                                  });
                                  freezeResolvedEmitted.add(trackId);
                                }
                              }
                            }
                            freezeTraces.set(trackId, freezeCount);
                          }
                        }
                      } catch (err) {
                        _iterator5.e(err);
                      } finally {
                        _iterator5.f();
                      }
                    });
                  };
                  processReport("audio");
                  processReport("video");
                  reportCounter++;
                } catch (error) {
                  var _this1$_videosdkLogs2;
                  (_this1$_videosdkLogs2 = _this1._videosdkLogs) === null || _this1$_videosdkLogs2 === void 0 || _this1$_videosdkLogs2.pushLogs({
                    logText: "Error CONSUMER Stats ERROR",
                    logType: "ERROR",
                    attributes: {
                      error: error.message
                    }
                  });
                  console.log("CONSUMER CATCH", error);
                }
              };
              probe.start();
              this._recvTransport.observer.on("close", function () {
                probe.stop();
                _this1._metrics.removeExistingProbe(probe);
              });
              (_this$_openTelemetry226 = this._openTelemetry) === null || _this$_openTelemetry226 === void 0 || _this$_openTelemetry226.completeSpan({
                span: consumerTransportspan,
                status: 1,
                message: "Recieve Transport Created Successfully"
              });
            case 1:
            case "end":
              return _context120.stop();
          }
        }, _callee120, this);
      }));
      function createConsumerTransport(_x112, _x113) {
        return _createConsumerTransport.apply(this, arguments);
      }
      return createConsumerTransport;
    }()
  }, {
    key: "emitMeetingStateChange",
    value: function emitMeetingStateChange(newState) {
      // Emit the event
      this._eventEmitter.emit("MEETING_STATE_CHANGED", {
        state: newState
      });

      // Update the last emitted state
      this._meetingConnectionState = newState;
    }
  }, {
    key: "joinRoom",
    value: function () {
      var _joinRoom = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee121() {
        var _this$_openTelemetry227, _this$_openTelemetry228, _this$_mediasoupDevic, _this$_mediasoupDevic2, _this$_openTelemetry229, _this$_openTelemetry232, routerSpan, routerRtpCapabilities, isFirefox, _routerRtpCapabilitie3, _routerRtpCapabilitie4, transportInfo, _transportInfo2, _yield$this$_socketRe, peers, poll, messages, _iterator6, _step6, peer, action, _this$_openTelemetry230, devicesCookie, _this$_openTelemetry231, _store$getState4, me, _this$_videosdkLogs114, _this$_openTelemetry233, _t89;
        return regenerator_default().wrap(function (_context121) {
          while (1) switch (_context121.prev = _context121.next) {
            case 0:
              logger.debug("joinRoom()");
              _context121.prev = 1;
              routerSpan = (_this$_openTelemetry227 = this._openTelemetry) === null || _this$_openTelemetry227 === void 0 ? void 0 : _this$_openTelemetry227.trace({
                spanName: "Loading Router Capabilities",
                span: this._joinSpan
              });
              this._mediasoupDevice = new lib/* Device */.pF({
                handlerName: this._handlerName
              });
              _context121.next = 2;
              return this._socketRequest("getRouterRtpCapabilities");
            case 2:
              routerRtpCapabilities = _context121.sent;
              // This only runs if the browser is FireFox and the logic is for the video-orientation
              if (this._deviceInfo.sdkType != "react-native") {
                isFirefox = navigator.userAgent.indexOf("Firefox");
                if (isFirefox) {
                  routerRtpCapabilities.headerExtensions = (_routerRtpCapabilitie3 = routerRtpCapabilities.headerExtensions) === null || _routerRtpCapabilitie3 === void 0 ? void 0 : _routerRtpCapabilitie3.filter(function (c) {
                    return c.uri != "urn:3gpp:video-orientation";
                  });
                }
              } else {
                //This runs when the SDK is react-native
                routerRtpCapabilities.headerExtensions = (_routerRtpCapabilitie4 = routerRtpCapabilities.headerExtensions) === null || _routerRtpCapabilitie4 === void 0 ? void 0 : _routerRtpCapabilitie4.filter(function (c) {
                  return c.uri != "urn:3gpp:video-orientation";
                });
              }
              _context121.next = 3;
              return this._mediasoupDevice.load({
                routerRtpCapabilities: routerRtpCapabilities
              });
            case 3:
              (_this$_openTelemetry228 = this._openTelemetry) === null || _this$_openTelemetry228 === void 0 || _this$_openTelemetry228.completeSpan({
                span: routerSpan,
                status: 1,
                attributes: {
                  routerRtpCapabilities: JSON.stringify(routerRtpCapabilities).toString()
                },
                message: "Router Capabilities Loaded"
              });

              // Create mediasoup Transport for sending (unless we don't want to produce).
              if (!this._produce) {
                _context121.next = 5;
                break;
              }
              _context121.next = 4;
              return this._socketRequest("createWebRtcTransport", {
                preferredProtocol: this._preferredProtocol,
                producing: true,
                consuming: false,
                sctpCapabilities: this._mediasoupDevice.sctpCapabilities
              });
            case 4:
              transportInfo = _context121.sent;
              this.createProducerTransport(transportInfo, this._joinSpan);
            case 5:
              if (!this._consume) {
                _context121.next = 7;
                break;
              }
              _context121.next = 6;
              return this._socketRequest("createWebRtcTransport", {
                preferredProtocol: this._preferredProtocol,
                producing: false,
                consuming: true,
                sctpCapabilities: this._mediasoupDevice.sctpCapabilities
              });
            case 6:
              _transportInfo2 = _context121.sent;
              this.createConsumerTransport(_transportInfo2, this._joinSpan);
            case 7:
              _context121.next = 8;
              return this._socketRequest("join", {
                displayName: this._displayName,
                device: this._device,
                secret: this._secret,
                rtpCapabilities: (_this$_mediasoupDevic = this._mediasoupDevice) === null || _this$_mediasoupDevic === void 0 ? void 0 : _this$_mediasoupDevic.rtpCapabilities,
                sctpCapabilities: (_this$_mediasoupDevic2 = this._mediasoupDevice) === null || _this$_mediasoupDevic2 === void 0 ? void 0 : _this$_mediasoupDevic2.sctpCapabilities,
                deviceInfo: this._deviceInfo,
                debugMode: this._debugMode,
                autoConsume: this._autoConsume,
                metaData: this._metaData
              });
            case 8:
              _yield$this$_socketRe = _context121.sent;
              peers = _yield$this$_socketRe.peers;
              poll = _yield$this$_socketRe.poll;
              messages = _yield$this$_socketRe.messages;
              store.dispatch(setRoomState("connected"));
              (_this$_openTelemetry229 = this._openTelemetry) === null || _this$_openTelemetry229 === void 0 || _this$_openTelemetry229.traceAutoComplete({
                spanName: "Emitted `MEETING_JOINED` Event",
                span: this._joinSpan,
                status: 1
              });
              this._eventEmitter.emit("MEETING_JOINED", {
                peers: peers,
                poll: poll,
                messages: messages,
                baseUrl: this._baseUrl
              });

              // Clean all the existing notifcations.
              store.dispatch(removeAllNotifications());
              store.dispatch(notify({
                text: "You are in the room!",
                timeout: 3000
              }));
              _iterator6 = RoomClient_createForOfIteratorHelper(peers);
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  peer = _step6.value;
                  action = addPeer(RoomClient_objectSpread(RoomClient_objectSpread({}, peer), {}, {
                    consumers: [],
                    dataConsumers: []
                  }));
                  store.dispatch(action);
                  this._eventEmitter.emit(action.type, action.payload);
                }

                // Enable mic/webcam.
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
              if (this._produce) {
                // Set our media capabilities.
                store.dispatch(setMediaCapabilities({
                  canSendMic: this._mediasoupDevice.canProduce("audio"),
                  canSendWebcam: this._mediasoupDevice.canProduce("video")
                }));
                if (this._micEnabled) {
                  this.enableMic(this.customMicrophoneAudioTrack, this._joinSpan);
                } else {
                  if (this.customMicrophoneAudioTrack) {
                    (_this$_openTelemetry230 = this._openTelemetry) === null || _this$_openTelemetry230 === void 0 || _this$_openTelemetry230.traceAutoComplete({
                      spanName: "Disposing Audio Track",
                      span: this._joinSpan,
                      status: 2
                    });
                    this.customMicrophoneAudioTrack.getTracks().forEach(function (track) {
                      track.stop();
                    });
                  }
                }
                devicesCookie = getDevices();
                if (this._webcamEnabled && (!devicesCookie || devicesCookie.webcamEnabled || this._externalVideo)) {
                  this.enableWebcam(this.customCameraVideoTrack, this._joinSpan);
                } else {
                  if (this.customCameraVideoTrack) {
                    (_this$_openTelemetry231 = this._openTelemetry) === null || _this$_openTelemetry231 === void 0 || _this$_openTelemetry231.traceAutoComplete({
                      spanName: "Disposing Video Track",
                      span: this._joinSpan,
                      status: 2
                    });
                    this.customCameraVideoTrack.getTracks().forEach(function (track) {
                      track.stop();
                    });
                  }
                }
                this.enableChatDataProducer();
              }

              // NOTE: For testing.
              if (window.SHOW_INFO) {
                _store$getState4 = store.getState(), me = _store$getState4.me;
                store.dispatch(setRoomStatsPeerId(me.id));
              }
              (_this$_openTelemetry232 = this._openTelemetry) === null || _this$_openTelemetry232 === void 0 || _this$_openTelemetry232.completeSpan({
                span: this._joinSpan,
                status: 1,
                message: "Room Joined"
              });
              _context121.next = 10;
              break;
            case 9:
              _context121.prev = 9;
              _t89 = _context121["catch"](1);
              logger.error("joinRoom() failed:%o", _t89);
              (_this$_videosdkLogs114 = this._videosdkLogs) === null || _this$_videosdkLogs114 === void 0 || _this$_videosdkLogs114.pushLogs({
                logText: "Error Could not join the room",
                logType: "ERROR",
                attributes: {
                  error: _t89.message
                }
              });
              (_this$_openTelemetry233 = this._openTelemetry) === null || _this$_openTelemetry233 === void 0 || _this$_openTelemetry233.completeSpan({
                span: this._joinSpan,
                status: 2,
                message: "Could not join the room ".concat(_t89)
              });
              store.dispatch(notify({
                type: "error",
                text: "Could not join the room: ".concat(_t89)
              }));
              this.close({
                sendLeft: true
              });
            case 10:
            case "end":
              return _context121.stop();
          }
        }, _callee121, this, [[1, 9]]);
      }));
      function joinRoom() {
        return _joinRoom.apply(this, arguments);
      }
      return joinRoom;
    }()
  }, {
    key: "switchingRoom",
    value: function () {
      var _switchingRoom = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee122(switchingRoomId) {
        var _this$_openTelemetry234;
        var switchRoomSpan, _this$_openTelemetry235, _this$_mediasoupDevic3, _this$_mediasoupDevic4, _this$_openTelemetry236, _this$_openTelemetry237, joinRequestSpan, _yield$this$_socketRe2, peers, poll, messages, _iterator7, _step7, peer, action, _this$_videosdkLogs115, _this$_openTelemetry238, _t90;
        return regenerator_default().wrap(function (_context122) {
          while (1) switch (_context122.prev = _context122.next) {
            case 0:
              // Create a span for room switching
              switchRoomSpan = (_this$_openTelemetry234 = this._openTelemetry) === null || _this$_openTelemetry234 === void 0 ? void 0 : _this$_openTelemetry234.trace({
                name: "switchingRoom() start",
                attributes: {
                  "room.id": switchingRoomId,
                  "peer.id": this._peerId,
                  display_name: this._displayName
                }
              });
              _context122.prev = 1;
              // Create child span for join request
              joinRequestSpan = (_this$_openTelemetry235 = this._openTelemetry) === null || _this$_openTelemetry235 === void 0 ? void 0 : _this$_openTelemetry235.trace({
                name: "switch room join request",
                parentSpan: switchRoomSpan
              });
              _context122.next = 2;
              return this._socketRequest("join", {
                displayName: this._displayName,
                device: this._device,
                secret: this._secret,
                rtpCapabilities: (_this$_mediasoupDevic3 = this._mediasoupDevice) === null || _this$_mediasoupDevic3 === void 0 ? void 0 : _this$_mediasoupDevic3.rtpCapabilities,
                sctpCapabilities: (_this$_mediasoupDevic4 = this._mediasoupDevice) === null || _this$_mediasoupDevic4 === void 0 ? void 0 : _this$_mediasoupDevic4.sctpCapabilities,
                deviceInfo: this._deviceInfo,
                debugMode: this._debugMode,
                autoConsume: this._autoConsume,
                metaData: this._metaData,
                switchingRoom: true
              });
            case 2:
              _yield$this$_socketRe2 = _context122.sent;
              peers = _yield$this$_socketRe2.peers;
              poll = _yield$this$_socketRe2.poll;
              messages = _yield$this$_socketRe2.messages;
              (_this$_openTelemetry236 = this._openTelemetry) === null || _this$_openTelemetry236 === void 0 || _this$_openTelemetry236.completeSpan({
                span: joinRequestSpan,
                status: 1,
                message: "Join request successful in switched room"
              });
              store.dispatch(setRoomState("connected"));
              this._eventEmitter.emit("MEETING_JOINED", {
                switchRoomId: switchingRoomId,
                peers: peers,
                poll: poll,
                messages: messages,
                baseUrl: this._baseUrl
              });

              // Clean all the existing notifcations.
              store.dispatch(removeAllNotifications());
              store.dispatch(notify({
                text: "You are in the room!",
                timeout: 3000
              }));
              _iterator7 = RoomClient_createForOfIteratorHelper(peers);
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  peer = _step7.value;
                  action = addPeer(RoomClient_objectSpread(RoomClient_objectSpread({}, peer), {}, {
                    consumers: [],
                    dataConsumers: []
                  }));
                  store.dispatch(action);
                  this._eventEmitter.emit(action.type, action.payload);
                }

                // Complete the main switching room span
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
              (_this$_openTelemetry237 = this._openTelemetry) === null || _this$_openTelemetry237 === void 0 || _this$_openTelemetry237.completeSpan({
                span: switchRoomSpan,
                status: 1,
                message: "Room switch completed successfully"
              });
              _context122.next = 4;
              break;
            case 3:
              _context122.prev = 3;
              _t90 = _context122["catch"](1);
              logger.error("joinRoom() failed:%o", _t90);
              (_this$_videosdkLogs115 = this._videosdkLogs) === null || _this$_videosdkLogs115 === void 0 || _this$_videosdkLogs115.pushLogs({
                logText: "Error Could not join the switched room",
                logType: "ERROR",
                attributes: {
                  error: _t90.message
                }
              });

              // Complete spans with error status
              (_this$_openTelemetry238 = this._openTelemetry) === null || _this$_openTelemetry238 === void 0 || _this$_openTelemetry238.completeSpan({
                span: switchRoomSpan,
                status: 2,
                message: "Room switch failed: ".concat(_t90.message)
              });
              store.dispatch(notify({
                type: "error",
                text: "Could not join the switched room: ".concat(_t90)
              }));
              this.close({
                sendLeft: true
              });
            case 4:
            case "end":
              return _context122.stop();
          }
        }, _callee122, this, [[1, 3]]);
      }));
      function switchingRoom(_x115) {
        return _switchingRoom.apply(this, arguments);
      }
      return switchingRoom;
    }()
  }, {
    key: "_updateMics",
    value: function () {
      var _updateMics2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee123() {
        var _this$_openTelemetry239;
        var parentSpan,
          updateMicSpan,
          _this$_openTelemetry240,
          _this$_openTelemetry241,
          devices,
          _iterator8,
          _step8,
          device,
          array,
          len,
          currentMicId,
          _this$_openTelemetry242,
          sdkError,
          _this$_openTelemetry243,
          _args123 = arguments,
          _t91;
        return regenerator_default().wrap(function (_context123) {
          while (1) switch (_context123.prev = _context123.next) {
            case 0:
              parentSpan = _args123.length > 0 && _args123[0] !== undefined ? _args123[0] : undefined;
              //reset the mic list
              this._mics = new Map();
              logger.debug("_updateMics() |");
              updateMicSpan = (_this$_openTelemetry239 = this._openTelemetry) === null || _this$_openTelemetry239 === void 0 ? void 0 : _this$_openTelemetry239.trace({
                spanName: "_updateMics() Calling for Getting System Mic list",
                span: parentSpan ? parentSpan : null
              });
              _context123.prev = 1;
              _context123.next = 2;
              return navigator.mediaDevices.enumerateDevices();
            case 2:
              devices = _context123.sent;
              (_this$_openTelemetry240 = this._openTelemetry) === null || _this$_openTelemetry240 === void 0 || _this$_openTelemetry240.traceAutoComplete({
                spanName: "Getting System Mic list",
                span: updateMicSpan,
                status: 1,
                attributes: {
                  systemDevice: devices ? JSON.stringify(devices) : "Device not found"
                }
              });
              _iterator8 = RoomClient_createForOfIteratorHelper(devices);
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  device = _step8.value;
                  if (device.kind == "audioinput") this._mics.set(device.deviceId, device);
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
              array = Array.from(this._mics.values());
              len = array.length;
              currentMicId = this._mic.device ? this._mic.device.deviceId : undefined;
              if (len === 0) {
                this._mic.device = null;
              } else if (!this._mics.has(currentMicId)) {
                this._mic.device = array[0];
              }
              // if (this._deviceInfo.sdkType != "react-native") {
              //   this._tracesEnabled &&
              //     updateMicSpan.setAttribute({
              //       "this._mic": JSON.stringify(this._mic),
              //     });
              // }

              (_this$_openTelemetry241 = this._openTelemetry) === null || _this$_openTelemetry241 === void 0 || _this$_openTelemetry241.completeSpan({
                span: updateMicSpan,
                status: 1,
                message: "Update Mic"
              });
              _context123.next = 5;
              break;
            case 3:
              _context123.prev = 3;
              _t91 = _context123["catch"](1);
              if (!(_t91 instanceof TypeError)) {
                _context123.next = 5;
                break;
              }
              if (!(_t91.name === "TypeError")) {
                _context123.next = 4;
                break;
              }
              sdkError = errors/* sdkErrors */.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE;
              this._emitError(sdkError);
              (_this$_openTelemetry242 = this._openTelemetry) === null || _this$_openTelemetry242 === void 0 || _this$_openTelemetry242.completeSpan({
                span: updateMicSpan,
                status: 2,
                message: "Error in updateMics() :: ".concat(sdkError.message)
              });
              throw new Error(sdkError.message);
            case 4:
              (_this$_openTelemetry243 = this._openTelemetry) === null || _this$_openTelemetry243 === void 0 || _this$_openTelemetry243.completeSpan({
                span: updateMicSpan,
                status: 2,
                message: "Error in updateMics() :: ".concat(_t91.message)
              });
              throw new Error(_t91.message);
            case 5:
            case "end":
              return _context123.stop();
          }
        }, _callee123, this, [[1, 3]]);
      }));
      function _updateMics() {
        return _updateMics2.apply(this, arguments);
      }
      return _updateMics;
    }()
  }, {
    key: "_updateWebcams",
    value: function () {
      var _updateWebcams2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee124() {
        var _this$_openTelemetry244;
        var parentSpan,
          updateWebcamSpan,
          _this$_openTelemetry245,
          _this$_openTelemetry246,
          devices,
          _iterator9,
          _step9,
          device,
          array,
          len,
          currentWebcamId,
          _this$_openTelemetry247,
          sdkError,
          _this$_openTelemetry248,
          _args124 = arguments,
          _t92,
          _t93;
        return regenerator_default().wrap(function (_context124) {
          while (1) switch (_context124.prev = _context124.next) {
            case 0:
              parentSpan = _args124.length > 0 && _args124[0] !== undefined ? _args124[0] : undefined;
              logger.debug("_updateWebcams()");
              // Reset the list.
              this._webcams = new Map();
              logger.debug("_updateWebcams() | calling enumerateDevices()");
              updateWebcamSpan = (_this$_openTelemetry244 = this._openTelemetry) === null || _this$_openTelemetry244 === void 0 ? void 0 : _this$_openTelemetry244.trace({
                spanName: "_updateWebcams() Calling for Getting System Webcam list",
                span: parentSpan ? parentSpan : null
              });
              _context124.prev = 1;
              _context124.next = 2;
              return navigator.mediaDevices.enumerateDevices();
            case 2:
              devices = _context124.sent;
              (_this$_openTelemetry245 = this._openTelemetry) === null || _this$_openTelemetry245 === void 0 || _this$_openTelemetry245.traceAutoComplete({
                spanName: "Getting System Webcam list",
                span: updateWebcamSpan,
                status: 1,
                attributes: {
                  systemDevice: devices ? JSON.stringify(devices) : "Device not found"
                }
              });
              _iterator9 = RoomClient_createForOfIteratorHelper(devices);
              _context124.prev = 3;
              _iterator9.s();
            case 4:
              if ((_step9 = _iterator9.n()).done) {
                _context124.next = 7;
                break;
              }
              device = _step9.value;
              if (!(device.kind !== "videoinput")) {
                _context124.next = 5;
                break;
              }
              return _context124.abrupt("continue", 6);
            case 5:
              this._webcams.set(device.deviceId, device);
            case 6:
              _context124.next = 4;
              break;
            case 7:
              _context124.next = 9;
              break;
            case 8:
              _context124.prev = 8;
              _t92 = _context124["catch"](3);
              _iterator9.e(_t92);
            case 9:
              _context124.prev = 9;
              _iterator9.f();
              return _context124.finish(9);
            case 10:
              array = Array.from(this._webcams.values());
              len = array.length;
              currentWebcamId = this._webcam.device ? this._webcam.device.deviceId : undefined;
              if (currentWebcamId) {
                this._defaultCameraIndex = currentWebcamId;
              }
              logger.debug("_updateWebcams() [webcams:%o]", array);
              if (len === 0) this._webcam.device = null;else if (!this._webcams.has(currentWebcamId)) {
                this._webcam.device = array[0];
                // this._webcam.device = array[this._defaultCameraIndex];
              }
              (_this$_openTelemetry246 = this._openTelemetry) === null || _this$_openTelemetry246 === void 0 || _this$_openTelemetry246.completeSpan({
                span: updateWebcamSpan,
                status: 1,
                message: "Update Webcam"
              });
              store.dispatch(setCanChangeWebcam(this._webcams.size > 1));
              _context124.next = 13;
              break;
            case 11:
              _context124.prev = 11;
              _t93 = _context124["catch"](1);
              if (!(_t93 instanceof TypeError)) {
                _context124.next = 13;
                break;
              }
              if (!(_t93.name === "TypeError")) {
                _context124.next = 12;
                break;
              }
              sdkError = errors/* sdkErrors */.q.ERROR_CAMERA_ACCESS_UNAVAILABLE;
              this._emitError(sdkError);
              (_this$_openTelemetry247 = this._openTelemetry) === null || _this$_openTelemetry247 === void 0 || _this$_openTelemetry247.completeSpan({
                span: updateWebcamSpan,
                status: 2,
                message: "Error in updateWebcams() :: ".concat(sdkError.message)
              });
              throw new Error(sdkError.message);
            case 12:
              (_this$_openTelemetry248 = this._openTelemetry) === null || _this$_openTelemetry248 === void 0 || _this$_openTelemetry248.completeSpan({
                span: updateWebcamSpan,
                status: 2,
                message: "Error in updateWebcams() :: ".concat(_t93.message)
              });
              throw new Error(_t93.message);
            case 13:
            case "end":
              return _context124.stop();
          }
        }, _callee124, this, [[1, 11], [3, 8, 9, 10]]);
      }));
      function _updateWebcams() {
        return _updateWebcams2.apply(this, arguments);
      }
      return _updateWebcams;
    }()
  }, {
    key: "_getWebcamType",
    value: function _getWebcamType(device) {
      if (/(back|rear)/i.test(device.label)) {
        logger.debug("_getWebcamType() | it seems to be a back camera");
        return "back";
      } else {
        logger.debug("_getWebcamType() | it seems to be a front camera");
        return "front";
      }
    }
  }, {
    key: "_pauseConsumer",
    value: function () {
      var _pauseConsumer2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee125(consumer) {
        var _this$_videosdkLogs116, _t94;
        return regenerator_default().wrap(function (_context125) {
          while (1) switch (_context125.prev = _context125.next) {
            case 0:
              if (!consumer.paused) {
                _context125.next = 1;
                break;
              }
              return _context125.abrupt("return");
            case 1:
              _context125.prev = 1;
              _context125.next = 2;
              return this._socketRequest("pauseConsumer", {
                consumerId: consumer.id
              });
            case 2:
              // pauses the track
              consumer.pause();
              store.dispatch(setConsumerPaused(consumer.id, "local"));
              _context125.next = 4;
              break;
            case 3:
              _context125.prev = 3;
              _t94 = _context125["catch"](1);
              logger.error("_pauseConsumer() | failed:%o", _t94);
              (_this$_videosdkLogs116 = this._videosdkLogs) === null || _this$_videosdkLogs116 === void 0 || _this$_videosdkLogs116.pushLogs({
                logText: "Error pausing Consumer",
                logType: "ERROR",
                attributes: {
                  error: _t94.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Error pausing Consumer: ".concat(_t94)
              }));
            case 4:
            case "end":
              return _context125.stop();
          }
        }, _callee125, this, [[1, 3]]);
      }));
      function _pauseConsumer(_x116) {
        return _pauseConsumer2.apply(this, arguments);
      }
      return _pauseConsumer;
    }()
  }, {
    key: "_resumeConsumer",
    value: function () {
      var _resumeConsumer2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee126(consumer) {
        var _this$_videosdkLogs117, _t95;
        return regenerator_default().wrap(function (_context126) {
          while (1) switch (_context126.prev = _context126.next) {
            case 0:
              if (consumer.paused) {
                _context126.next = 1;
                break;
              }
              return _context126.abrupt("return");
            case 1:
              _context126.prev = 1;
              _context126.next = 2;
              return this._socketRequest("resumeConsumer", {
                consumerId: consumer.id
              });
            case 2:
              consumer.resume();
              store.dispatch(setConsumerResumed(consumer.id, "local"));
              _context126.next = 4;
              break;
            case 3:
              _context126.prev = 3;
              _t95 = _context126["catch"](1);
              logger.error("_resumeConsumer() | failed:%o", _t95);
              (_this$_videosdkLogs117 = this._videosdkLogs) === null || _this$_videosdkLogs117 === void 0 || _this$_videosdkLogs117.pushLogs({
                logText: "Error resuming Consumer",
                logType: "ERROR",
                attributes: {
                  error: _t95.message
                }
              });
              store.dispatch(notify({
                type: "error",
                text: "Error resuming Consumer: ".concat(_t95)
              }));
            case 4:
            case "end":
              return _context126.stop();
          }
        }, _callee126, this, [[1, 3]]);
      }));
      function _resumeConsumer(_x117) {
        return _resumeConsumer2.apply(this, arguments);
      }
      return _resumeConsumer;
    }()
  }, {
    key: "_getExternalVideoStream",
    value: function () {
      var _getExternalVideoStream2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee127() {
        var _this10 = this;
        return regenerator_default().wrap(function (_context127) {
          while (1) switch (_context127.prev = _context127.next) {
            case 0:
              if (!this._externalVideoStream) {
                _context127.next = 1;
                break;
              }
              return _context127.abrupt("return", this._externalVideoStream);
            case 1:
              if (!(this._externalVideo.readyState < 3)) {
                _context127.next = 2;
                break;
              }
              _context127.next = 2;
              return new Promise(function (resolve) {
                return _this10._externalVideo.addEventListener("canplay", resolve);
              });
            case 2:
              if (!this._externalVideo.captureStream) {
                _context127.next = 3;
                break;
              }
              this._externalVideoStream = this._externalVideo.captureStream();
              _context127.next = 5;
              break;
            case 3:
              if (!this._externalVideo.mozCaptureStream) {
                _context127.next = 4;
                break;
              }
              this._externalVideoStream = this._externalVideo.mozCaptureStream();
              _context127.next = 5;
              break;
            case 4:
              throw new Error("video.captureStream() not supported");
            case 5:
              return _context127.abrupt("return", this._externalVideoStream);
            case 6:
            case "end":
              return _context127.stop();
          }
        }, _callee127, this);
      }));
      function _getExternalVideoStream() {
        return _getExternalVideoStream2.apply(this, arguments);
      }
      return _getExternalVideoStream;
    }()
  }, {
    key: "toggleE2EEEnabled",
    value: function () {
      var _toggleE2EEEnabled = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee128(enabled) {
        return regenerator_default().wrap(function (_context128) {
          while (1) switch (_context128.prev = _context128.next) {
            case 0:
              if (!this.e2eeManager) {
                _context128.next = 1;
                break;
              }
              if (this._peerId) {
                this.e2eeManager.setParticipantCryptorEnabled(enabled, this._peerId);
              }
              this.isE2EEEnabled = enabled;
              _context128.next = 2;
              break;
            case 1:
              throw Error("e2ee not configured, please set e2ee settings within the room options");
            case 2:
            case "end":
              return _context128.stop();
          }
        }, _callee128, this);
      }));
      function toggleE2EEEnabled(_x118) {
        return _toggleE2EEEnabled.apply(this, arguments);
      }
      return toggleE2EEEnabled;
    }()
  }, {
    key: "_emitError",
    value: function _emitError(error) {
      this._eventEmitter.emit("ERROR", error);
    }
  }], [{
    key: "init",
    value:
    /**
     * @param  {Object} data
     * @param  {Object} data.store - The Redux store.
     */
    function init(data) {
      store = data.store;
    }
  }]);
}();
function _setupE2EE(_x119) {
  return _setupE2EE2.apply(this, arguments);
}
function _setupE2EE2() {
  _setupE2EE2 = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee129(keyProvider) {
    var _this11 = this;
    var _this$e2eeManager, _t96, _t97, _t98, _t99, _t100;
    return regenerator_default().wrap(function (_context129) {
      while (1) switch (_context129.prev = _context129.next) {
        case 0:
          _context129.prev = 0;
          if (this.e2eeManager) {
            _context129.next = 2;
            break;
          }
          _t96 = E2EEManager;
          _t97 = keyProvider;
          _context129.next = 1;
          return createE2EEWorker();
        case 1:
          _t98 = _context129.sent;
          _t99 = {
            keyProvider: _t97,
            worker: _t98
          };
          this.e2eeManager = new _t96(_t99);
          this.e2eeManager.on(e2ee_events/* EncryptionEvent */.KS.ParticipantEncryptionStatusChanged, function (enabled) {
            _this11.isE2EEEnabled = enabled;
          });
          this.e2eeManager.on(e2ee_events/* EncryptionEvent */.KS.E2EEStateChange, function (data) {
            _this11._eventEmitter.emit("E2EE_STATE_CHANGE", data);
          });
          (_this$e2eeManager = this.e2eeManager) === null || _this$e2eeManager === void 0 || _this$e2eeManager.setup(this);
          this.toggleE2EEEnabled(true);
        case 2:
          _context129.next = 4;
          break;
        case 3:
          _context129.prev = 3;
          _t100 = _context129["catch"](0);
          console.error("Error setting up E2EE: ", _t100);
          throw new Error("Error setting up E2EE: " + _t100.message);
        case 4:
        case "end":
          return _context129.stop();
      }
    }, _callee129, this, [[0, 3]]);
  }));
  return _setupE2EE2.apply(this, arguments);
}


/***/ }),

/***/ 2067:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   y: () => (/* binding */ reliabilityMode)
/* harmony export */ });
var reliabilityMode = {
  RELIABLE: "RELIABLE",
  UNRELIABLE: "UNRELIABLE"
};

/***/ }),

/***/ 2073:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));

/***/ }),

/***/ 2107:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   kR: () => (/* binding */ isSendRecvMode),
/* harmony export */   nI: () => (/* binding */ modes),
/* harmony export */   wZ: () => (/* binding */ isViewerMode)
/* harmony export */ });
/* unused harmony export isRecvOnlyMode */
var modes = {
  /** @deprecated CONFERENCE mode is deprecated and will be removed in future versions. Use SEND_AND_RECV mode instead. */
  CONFERENCE: "CONFERENCE",
  /** @deprecated VIEWER mode is deprecated and will be removed in future versions. Use SIGNALLING_ONLY mode instead. */
  VIEWER: "VIEWER",
  SEND_AND_RECV: "SEND_AND_RECV",
  SIGNALLING_ONLY: "SIGNALLING_ONLY",
  RECV_ONLY: "RECV_ONLY"
};
function isSendRecvMode(mode) {
  return mode === modes.CONFERENCE || mode === modes.SEND_AND_RECV;
}
function isViewerMode(mode) {
  return mode === modes.VIEWER || mode === modes.SIGNALLING_ONLY;
}
function isRecvOnlyMode(mode) {
  return mode === modes.RECV_ONLY;
}

/***/ }),

/***/ 2109:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/////////////////////////////////////////////////////////////////////////////////
/* UAParser.js v2.0.5
   Copyright © 2012-2025 Faisal Salman <f@faisalman.com>
   AGPLv3 License *//*
   Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
   Supports browser & node.js environment. 
   Demo   : https://uaparser.dev
   Source : https://github.com/faisalman/ua-parser-js */
/////////////////////////////////////////////////////////////////////////////////

/* jshint esversion: 3 */ 
/* globals window */

(function (window, undefined) {

    'use strict';
    
    //////////////
    // Constants
    /////////////

    var LIBVERSION  = '2.0.5',
        UA_MAX_LENGTH = 500,
        USER_AGENT  = 'user-agent',
        EMPTY       = '',
        UNKNOWN     = '?',

        // typeof
        FUNC_TYPE   = 'function',
        UNDEF_TYPE  = 'undefined',
        OBJ_TYPE    = 'object',
        STR_TYPE    = 'string',

        // properties
        UA_BROWSER  = 'browser',
        UA_CPU      = 'cpu',
        UA_DEVICE   = 'device',
        UA_ENGINE   = 'engine',
        UA_OS       = 'os',
        UA_RESULT   = 'result',
        
        NAME        = 'name',
        TYPE        = 'type',
        VENDOR      = 'vendor',
        VERSION     = 'version',
        ARCHITECTURE= 'architecture',
        MAJOR       = 'major',
        MODEL       = 'model',

        // device types
        CONSOLE     = 'console',
        MOBILE      = 'mobile',
        TABLET      = 'tablet',
        SMARTTV     = 'smarttv',
        WEARABLE    = 'wearable',
        XR          = 'xr',
        EMBEDDED    = 'embedded',

        // browser types
        INAPP       = 'inapp',

        // client hints
        BRANDS      = 'brands',
        FORMFACTORS = 'formFactors',
        FULLVERLIST = 'fullVersionList',
        PLATFORM    = 'platform',
        PLATFORMVER = 'platformVersion',
        BITNESS     = 'bitness',
        CH_HEADER   = 'sec-ch-ua',
        CH_HEADER_FULL_VER_LIST = CH_HEADER + '-full-version-list',
        CH_HEADER_ARCH      = CH_HEADER + '-arch',
        CH_HEADER_BITNESS   = CH_HEADER + '-' + BITNESS,
        CH_HEADER_FORM_FACTORS = CH_HEADER + '-form-factors',
        CH_HEADER_MOBILE    = CH_HEADER + '-' + MOBILE,
        CH_HEADER_MODEL     = CH_HEADER + '-' + MODEL,
        CH_HEADER_PLATFORM  = CH_HEADER + '-' + PLATFORM,
        CH_HEADER_PLATFORM_VER = CH_HEADER_PLATFORM + '-version',
        CH_ALL_VALUES       = [BRANDS, FULLVERLIST, MOBILE, MODEL, PLATFORM, PLATFORMVER, ARCHITECTURE, FORMFACTORS, BITNESS],

        // device vendors
        AMAZON      = 'Amazon',
        APPLE       = 'Apple',
        ASUS        = 'ASUS',
        BLACKBERRY  = 'BlackBerry',
        GOOGLE      = 'Google',
        HUAWEI      = 'Huawei',
        LENOVO      = 'Lenovo',
        HONOR       = 'Honor',
        LG          = 'LG',
        MICROSOFT   = 'Microsoft',
        MOTOROLA    = 'Motorola',
        NVIDIA      = 'Nvidia',
        ONEPLUS     = 'OnePlus',
        OPPO        = 'OPPO',
        SAMSUNG     = 'Samsung',
        SHARP       = 'Sharp',
        SONY        = 'Sony',
        XIAOMI      = 'Xiaomi',
        ZEBRA       = 'Zebra',

        // browsers
        CHROME      = 'Chrome',
        CHROMIUM    = 'Chromium',
        CHROMECAST  = 'Chromecast',
        EDGE        = 'Edge',
        FIREFOX     = 'Firefox',
        OPERA       = 'Opera',
        FACEBOOK    = 'Facebook',
        SOGOU       = 'Sogou',

        PREFIX_MOBILE  = 'Mobile ',
        SUFFIX_BROWSER = ' Browser',

        // os
        WINDOWS     = 'Windows';
   
    var isWindow            = typeof window !== UNDEF_TYPE,
        NAVIGATOR           = (isWindow && window.navigator) ? 
                                window.navigator : 
                                undefined,
        NAVIGATOR_UADATA    = (NAVIGATOR && NAVIGATOR.userAgentData) ? 
                                NAVIGATOR.userAgentData : 
                                undefined;

    ///////////
    // Helper
    //////////

    var extend = function (defaultRgx, extensions) {
            var mergedRgx = {};
            var extraRgx = extensions;
            if (!isExtensions(extensions)) {
                extraRgx = {};
                for (var i in extensions) {
                    for (var j in extensions[i]) {
                        extraRgx[j] = extensions[i][j].concat(extraRgx[j] ? extraRgx[j] : []);
                    }
                }
            }
            for (var k in defaultRgx) {
                mergedRgx[k] = extraRgx[k] && extraRgx[k].length % 2 === 0 ? extraRgx[k].concat(defaultRgx[k]) : defaultRgx[k];
            }
            return mergedRgx;
        },
        enumerize = function (arr) {
            var enums = {};
            for (var i=0; i<arr.length; i++) {
                enums[arr[i].toUpperCase()] = arr[i];
            }
            return enums;
        },
        has = function (str1, str2) {
            if (typeof str1 === OBJ_TYPE && str1.length > 0) {
                for (var i in str1) {
                    if (lowerize(str2) == lowerize(str1[i])) return true;
                }
                return false;
            }
            return isString(str1) ? lowerize(str2) == lowerize(str1) : false;
        },
        isExtensions = function (obj, deep) {
            for (var prop in obj) {
                return /^(browser|cpu|device|engine|os)$/.test(prop) || (deep ? isExtensions(obj[prop]) : false);
            }
        },
        isString = function (val) {
            return typeof val === STR_TYPE;
        },
        itemListToArray = function (header) {
            if (!header) return undefined;
            var arr = [];
            var tokens = strip(/\\?\"/g, header).split(',');
            for (var i = 0; i < tokens.length; i++) {
                if (tokens[i].indexOf(';') > -1) {
                    var token = trim(tokens[i]).split(';v=');
                    arr[i] = { brand : token[0], version : token[1] };
                } else {
                    arr[i] = trim(tokens[i]);
                }
            }
            return arr;
        },
        lowerize = function (str) {
            return isString(str) ? str.toLowerCase() : str;
        },
        majorize = function (version) {
            return isString(version) ? strip(/[^\d\.]/g, version).split('.')[0] : undefined;
        },
        setProps = function (arr) {
            for (var i in arr) {
                if (!arr.hasOwnProperty(i)) continue;

                var propName = arr[i];
                if (typeof propName == OBJ_TYPE && propName.length == 2) {
                    this[propName[0]] = propName[1];
                } else {
                    this[propName] = undefined;
                }
            }
            return this;
        },
        strip = function (pattern, str) {
            return isString(str) ? str.replace(pattern, EMPTY) : str;
        },
        stripQuotes = function (str) {
            return strip(/\\?\"/g, str); 
        },
        trim = function (str, len) {
            if (isString(str)) {
                str = strip(/^\s\s*/, str);
                return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
            }
    };

    ///////////////
    // Map helper
    //////////////

    var rgxMapper = function (ua, arrays) {

            if(!ua || !arrays) return;

            var i = 0, j, k, p, q, matches, match;

            // loop through all regexes maps
            while (i < arrays.length && !matches) {

                var regex = arrays[i],       // even sequence (0,2,4,..)
                    props = arrays[i + 1];   // odd sequence (1,3,5,..)
                j = k = 0;

                // try matching uastring with regexes
                while (j < regex.length && !matches) {

                    if (!regex[j]) { break; }
                    matches = regex[j++].exec(ua);

                    if (!!matches) {
                        for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            // check if given property is actually array
                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                if (q.length === 2) {
                                    if (typeof q[1] == FUNC_TYPE) {
                                        // assign modified match
                                        this[q[0]] = q[1].call(this, match);
                                    } else {
                                        // assign given value, ignore regex match
                                        this[q[0]] = q[1];
                                    }
                                } else if (q.length >= 3) {
                                    // Check whether q[1] FUNCTION or REGEX
                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                        if (q.length > 3) {
                                            this[q[0]] = match ? q[1].apply(this, q.slice(2)) : undefined;
                                        } else {
                                            // call function (usually string mapper)
                                            this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                        }
                                    } else {
                                        if (q.length == 3) {
                                            // sanitize match using given regex
                                            this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                        } else if (q.length == 4) {
                                            this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                        } else if (q.length > 4) {
                                            this[q[0]] = match ? q[3].apply(this, [match.replace(q[1], q[2])].concat(q.slice(4))) : undefined;
                                        }
                                    }
                                }
                            } else {
                                this[q] = match ? match : undefined;
                            }
                        }
                    }
                }
                i += 2;
            }
        },

        strMapper = function (str, map) {

            for (var i in map) {
                // check if current value is array
                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                    for (var j = 0; j < map[i].length; j++) {
                        if (has(map[i][j], str)) {
                            return (i === UNKNOWN) ? undefined : i;
                        }
                    }
                } else if (has(map[i], str)) {
                    return (i === UNKNOWN) ? undefined : i;
                }
            }
            return map.hasOwnProperty('*') ? map['*'] : str;
    };

    ///////////////
    // String map
    //////////////

    var windowsVersionMap = {
            'ME'    : '4.90',
            'NT 3.51': '3.51',
            'NT 4.0': '4.0',
            '2000'  : ['5.0', '5.01'],
            'XP'    : ['5.1', '5.2'],
            'Vista' : '6.0',
            '7'     : '6.1',
            '8'     : '6.2',
            '8.1'   : '6.3',
            '10'    : ['6.4', '10.0'],
            'NT'    : ''
        },
        
        formFactorsMap = {
            'embedded'  : 'Automotive',
            'mobile'    : 'Mobile',
            'tablet'    : ['Tablet', 'EInk'],
            'smarttv'   : 'TV',
            'wearable'  : 'Watch',
            'xr'        : ['VR', 'XR'],
            '?'         : ['Desktop', 'Unknown'],
            '*'         : undefined
        },

        browserHintsMap = {
            'Chrome'        : 'Google Chrome',
            'Edge'          : 'Microsoft Edge',
            'Edge WebView2' : 'Microsoft Edge WebView2',
            'Chrome WebView': 'Android WebView',
            'Chrome Headless':'HeadlessChrome',
            'Huawei Browser': 'HuaweiBrowser',
            'MIUI Browser'  : 'Miui Browser',
            'Opera Mobi'    : 'OperaMobile',
            'Yandex'        : 'YaBrowser'
    };

    //////////////
    // Regex map
    /////////////

    var defaultRegexes = {

        browser : [[

            // Most common regardless engine
            /\b(?:crmo|crios)\/([\w\.]+)/i                                      // Chrome for Android/iOS
            ], [VERSION, [NAME, PREFIX_MOBILE + 'Chrome']], [
            /webview.+edge\/([\w\.]+)/i                                         // Microsoft Edge
            ], [VERSION, [NAME, EDGE+' WebView']], [
            /edg(?:e|ios|a)?\/([\w\.]+)/i                                       
            ], [VERSION, [NAME, 'Edge']], [

            // Presto based
            /(opera mini)\/([-\w\.]+)/i,                                        // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,                 // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i                           // Opera
            ], [NAME, VERSION], [
            /opios[\/ ]+([\w\.]+)/i                                             // Opera mini on iphone >= 8.0
            ], [VERSION, [NAME, OPERA+' Mini']], [
            /\bop(?:rg)?x\/([\w\.]+)/i                                          // Opera GX
            ], [VERSION, [NAME, OPERA+' GX']], [
            /\bopr\/([\w\.]+)/i                                                 // Opera Webkit
            ], [VERSION, [NAME, OPERA]], [

            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i            // Baidu
            ], [VERSION, [NAME, 'Baidu']], [
            /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i                       // Maxthon
            ], [VERSION, [NAME, 'Maxthon']], [
            /(kindle)\/([\w\.]+)/i,                                             // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,      
                                                                                // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,        // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
            /(?:ms|\()(ie) ([\w\.]+)/i,                                         // Internet Explorer

            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon/LG Browser/Otter/qutebrowser/Dooble
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon|otter|dooble|(?:lg |qute)browser)\/([-\w\.]+)/i,
                                                                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
            /(heytap|ovi|115|surf)browser\/([\d\.]+)/i,                         // HeyTap/Ovi/115/Surf
            /(ecosia|weibo)(?:__| \w+@)([\d\.]+)/i                              // Ecosia/Weibo
            ], [NAME, VERSION], [
            /quark(?:pc)?\/([-\w\.]+)/i                                         // Quark
            ], [VERSION, [NAME, 'Quark']], [
            /\bddg\/([\w\.]+)/i                                                 // DuckDuckGo
            ], [VERSION, [NAME, 'DuckDuckGo']], [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i                 // UCBrowser
            ], [VERSION, [NAME, 'UCBrowser']], [
            /microm.+\bqbcore\/([\w\.]+)/i,                                     // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i                                        // WeChat
            ], [VERSION, [NAME, 'WeChat']], [
            /konqueror\/([\w\.]+)/i                                             // Konqueror
            ], [VERSION, [NAME, 'Konqueror']], [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i                       // IE11
            ], [VERSION, [NAME, 'IE']], [
            /ya(?:search)?browser\/([\w\.]+)/i                                  // Yandex
            ], [VERSION, [NAME, 'Yandex']], [
            /slbrowser\/([\w\.]+)/i                                             // Smart Lenovo Browser
            ], [VERSION, [NAME, 'Smart ' + LENOVO + SUFFIX_BROWSER]], [
            /(avast|avg)\/([\w\.]+)/i                                           // Avast/AVG Secure Browser
            ], [[NAME, /(.+)/, '$1 Secure' + SUFFIX_BROWSER], VERSION], [
            /\bfocus\/([\w\.]+)/i                                               // Firefox Focus
            ], [VERSION, [NAME, FIREFOX+' Focus']], [
            /\bopt\/([\w\.]+)/i                                                 // Opera Touch
            ], [VERSION, [NAME, OPERA+' Touch']], [
            /coc_coc\w+\/([\w\.]+)/i                                            // Coc Coc Browser
            ], [VERSION, [NAME, 'Coc Coc']], [
            /dolfin\/([\w\.]+)/i                                                // Dolphin
            ], [VERSION, [NAME, 'Dolphin']], [
            /coast\/([\w\.]+)/i                                                 // Opera Coast
            ], [VERSION, [NAME, OPERA+' Coast']], [
            /miuibrowser\/([\w\.]+)/i                                           // MIUI Browser
            ], [VERSION, [NAME, 'MIUI' + SUFFIX_BROWSER]], [
            /fxios\/([\w\.-]+)/i                                                // Firefox for iOS
            ], [VERSION, [NAME, PREFIX_MOBILE + FIREFOX]], [
            /\bqihoobrowser\/?([\w\.]*)/i                                       // 360
            ], [VERSION, [NAME, '360']], [
            /\b(qq)\/([\w\.]+)/i                                                // QQ
            ], [[NAME, /(.+)/, '$1Browser'], VERSION], [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
            ], [[NAME, /(.+)/, '$1' + SUFFIX_BROWSER], VERSION], [              // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i                                        // Samsung Internet
            ], [VERSION, [NAME, SAMSUNG + ' Internet']], [
            /metasr[\/ ]?([\d\.]+)/i                                            // Sogou Explorer
            ], [VERSION, [NAME, SOGOU + ' Explorer']], [
            /(sogou)mo\w+\/([\d\.]+)/i                                          // Sogou Mobile
            ], [[NAME, SOGOU + ' Mobile'], VERSION], [
            /(electron)\/([\w\.]+) safari/i,                                    // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,                   // Tesla
            /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i   // QQ/2345
            ], [NAME, VERSION], [
            /(lbbrowser|rekonq)/i                                               // LieBao Browser/Rekonq
            ], [NAME], [
            /ome\/([\w\.]+) \w* ?(iron) saf/i,                                  // Iron
            /ome\/([\w\.]+).+qihu (360)[es]e/i                                  // 360
            ], [VERSION, NAME], [

            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i       // Facebook App for iOS & Android
            ], [[NAME, FACEBOOK], VERSION, [TYPE, INAPP]], [
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,                             // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,                                  // Naver InApp
            /(daum)apps[\/ ]([\w\.]+)/i,                                        // Daum App
            /safari (line)\/([\w\.]+)/i,                                        // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,                                        // Line App for Android
            /(alipay)client\/([\w\.]+)/i,                                       // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,                               // Twitter
            /(instagram|snapchat|klarna)[\/ ]([-\w\.]+)/i                       // Instagram/Snapchat/Klarna
            ], [NAME, VERSION, [TYPE, INAPP]], [
            /\bgsa\/([\w\.]+) .*safari\//i                                      // Google Search Appliance on iOS
            ], [VERSION, [NAME, 'GSA'], [TYPE, INAPP]], [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i                        // TikTok
            ], [VERSION, [NAME, 'TikTok'], [TYPE, INAPP]], [
            /\[(linkedin)app\]/i                                                // LinkedIn App for iOS & Android
            ], [NAME, [TYPE, INAPP]], [
            /(zalo(?:app)?)[\/\sa-z]*([\w\.-]+)/i                               // Zalo 
            ], [[NAME, /(.+)/, 'Zalo'], VERSION, [TYPE, INAPP]], [

            /(chromium)[\/ ]([-\w\.]+)/i                                        // Chromium
            ], [NAME, VERSION], [

            /headlesschrome(?:\/([\w\.]+)| )/i                                  // Chrome Headless
            ], [VERSION, [NAME, CHROME+' Headless']], [

            /wv\).+chrome\/([\w\.]+).+edgw\//i                                  // Edge WebView2
            ], [VERSION, [NAME, EDGE+' WebView2']], [

            / wv\).+(chrome)\/([\w\.]+)/i                                       // Chrome WebView
            ], [[NAME, CHROME+' WebView'], VERSION], [

            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i           // Android Browser
            ], [VERSION, [NAME, 'Android' + SUFFIX_BROWSER]], [

            /chrome\/([\w\.]+) mobile/i                                         // Chrome Mobile
            ], [VERSION, [NAME, PREFIX_MOBILE + 'Chrome']], [

            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i       // Chrome/OmniWeb/Arora/Tizen/Nokia
            ], [NAME, VERSION], [

            /version\/([\w\.\,]+) .*mobile(?:\/\w+ | ?)safari/i                 // Safari Mobile
            ], [VERSION, [NAME, PREFIX_MOBILE + 'Safari']], [
            /iphone .*mobile(?:\/\w+ | ?)safari/i
            ], [[NAME, PREFIX_MOBILE + 'Safari']], [
            /version\/([\w\.\,]+) .*(safari)/i                                  // Safari
            ], [VERSION, NAME], [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i                      // Safari < 3.0
            ], [NAME, [VERSION, '1']], [

            /(webkit|khtml)\/([\w\.]+)/i
            ], [NAME, VERSION], [

            // Gecko based
            /(?:mobile|tablet);.*(firefox)\/([\w\.-]+)/i                        // Firefox Mobile
            ], [[NAME, PREFIX_MOBILE + FIREFOX], VERSION], [
            /(navigator|netscape\d?)\/([-\w\.]+)/i                              // Netscape
            ], [[NAME, 'Netscape'], VERSION], [
            /(wolvic|librewolf)\/([\w\.]+)/i                                    // Wolvic/LibreWolf
            ], [NAME, VERSION], [
            /mobile vr; rv:([\w\.]+)\).+firefox/i                               // Firefox Reality
            ], [VERSION, [NAME, FIREFOX+' Reality']], [
            /ekiohf.+(flow)\/([\w\.]+)/i,                                       // Flow
            /(swiftfox)/i,                                                      // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
                                                                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                                                                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,                                            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,                         // Mozilla

            // Other
            /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                                                                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser/Ladybird
            /\b(links) \(([\w\.]+)/i                                            // Links
            ], [NAME, [VERSION, /_/g, '.']], [
            
            /(cobalt)\/([\w\.]+)/i                                              // Cobalt
            ], [NAME, [VERSION, /[^\d\.]+./, EMPTY]]
        ],

        cpu : [[

            /\b((amd|x|x86[-_]?|wow|win)64)\b/i                                 // AMD64 (x64)
            ], [[ARCHITECTURE, 'amd64']], [

            /(ia32(?=;))/i,                                                     // IA32 (quicktime)
            /\b((i[346]|x)86)(pc)?\b/i                                          // IA32 (x86)
            ], [[ARCHITECTURE, 'ia32']], [

            /\b(aarch64|arm(v?[89]e?l?|_?64))\b/i                               // ARM64
            ], [[ARCHITECTURE, 'arm64']], [

            /\b(arm(v[67])?ht?n?[fl]p?)\b/i                                     // ARMHF
            ], [[ARCHITECTURE, 'armhf']], [

            // PocketPC mistakenly identified as PowerPC
            /( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i
            ], [[ARCHITECTURE, 'arm']], [

            / sun4\w[;\)]/i                                                     // SPARC
            ], [[ARCHITECTURE, 'sparc']], [
                                                                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            /\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i,
            /((ppc|powerpc)(64)?)( mac|;|\))/i,                                 // PowerPC
            /(?:osf1|[freopnt]{3,4}bsd) (alpha)/i                               // Alpha
            ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [
            /winnt.+\[axp/i
            ], [[ARCHITECTURE, 'alpha']]
        ],

        device : [[

            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////

            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr]|browser)[-\w]+)/i,
            /sec-(sgh\w+)/i
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [

            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i                          // iPod/iPhone
            ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [
            /\((ipad);[-\w\),; ]+apple/i,                                       // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [
            /(macintosh);/i
            ], [MODEL, [VENDOR, APPLE]], [

            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [

            // Honor
            /\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i
            ], [MODEL, [VENDOR, HONOR], [TYPE, TABLET]], [
            /honor([-\w ]+)[;\)]/i
            ], [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]], [

            // Huawei
            /\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [
            /(?:huawei)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
            ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [

            // Xiaomi
            /oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i,
            /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i                                // Mi Pad tablets
            ],[[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [

            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,                  // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,                                           // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,                             // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,                   // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,        // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i, // Xiaomi Mi
            / ([\w ]+) miui\/v?\d/i
            ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [

            // OnePlus
            /droid.+; (cph2[3-6]\d[13579]|((gm|hd)19|(ac|be|in|kb)20|(d[en]|eb|le|mt)21|ne22)[0-2]\d|p[g-k]\w[1m]10)\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ], [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]], [

            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ], [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]], [
            /\b(opd2(\d{3}a?))(?: bui|\))/i
            ], [MODEL, [VENDOR, strMapper, { 'OnePlus' : ['203', '304', '403', '404', '413', '415'], '*' : OPPO }], [TYPE, TABLET]], [

            // BLU
            /(vivo (5r?|6|8l?|go|one|s|x[il]?[2-4]?)[\w\+ ]*)(?: bui|\))/i  // Vivo series
            ], [MODEL, [VENDOR, 'BLU'], [TYPE, MOBILE]], [    

            // Vivo
            /; vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [

            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
            ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [

            // Lenovo
            /(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i,
            /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i
            ], [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]], [            
            /lenovo[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i
            ], [MODEL, [VENDOR, LENOVO], [TYPE, MOBILE]], [

            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ]([\w\s]+)(\)| bui)/i,
            /((?:moto(?! 360)[-\w\(\) ]+|xt\d{3,4}[cgkosw\+]?[-\d]*|nexus 6)(?= bui|\)))/i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [

            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+(?!.*(?:browser|netcast|android tv|watch|webos))(\w+)/i,
            /\blg-?([\d\w]+) bui/i
            ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [

            // Nokia
            /(nokia) (t[12][01])/i
            ], [VENDOR, MODEL, [TYPE, TABLET]], [
            /(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i,
            /nokia[-_ ]?(([-\w\. ]*))/i
            ], [[MODEL, /_/g, ' '], [TYPE, MOBILE], [VENDOR, 'Nokia']], [

            // Google
            /(pixel (c|tablet))\b/i                                             // Google Pixel C/Tablet
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [
                                                                                // Google Pixel
            /droid.+;(?: google)? (g(01[13]a|020[aem]|025[jn]|1b60|1f8f|2ybb|4s1m|576d|5nz6|8hhn|8vou|a02099|c15s|d1yq|e2ae|ec77|gh2x|kv4x|p4bc|pj41|r83y|tt9q|ur25|wvk6)|pixel[\d ]*a?( pro)?( xl)?( fold)?( \(5g\))?)( bui|\))/i
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [
            /(google) (pixelbook( go)?)/i
            ], [VENDOR, MODEL], [

            // Sony
            /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-\w\w\d\d)(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
            ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [

            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,                           // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i                                      // Kindle Fire HD
            ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i                     // Fire Phone
            ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [

            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i                                      // BlackBerry PlayBook
            ], [MODEL, VENDOR, [TYPE, TABLET]], [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i                                                    // BlackBerry 10
            ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [

            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [

            // HTC
            /(nexus 9)/i                                                        // HTC Nexus 9
            ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,                         // HTC

            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i         // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [

            // TCL
            /tcl (xess p17aa)/i,
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])(_\w(\w|\w\w))?(\)| bui)/i
            ], [MODEL, [VENDOR, 'TCL'], [TYPE, TABLET]], [
            /droid [\w\.]+; (418(?:7d|8v)|5087z|5102l|61(?:02[dh]|25[adfh]|27[ai]|56[dh]|59k|65[ah])|a509dl|t(?:43(?:0w|1[adepqu])|50(?:6d|7[adju])|6(?:09dl|10k|12b|71[efho]|76[hjk])|7(?:66[ahju]|67[hw]|7[045][bh]|71[hk]|73o|76[ho]|79w|81[hks]?|82h|90[bhsy]|99b)|810[hs]))(_\w(\w|\w\w))?(\)| bui)/i
            ], [MODEL, [VENDOR, 'TCL'], [TYPE, MOBILE]], [

            // itel
            /(itel) ((\w+))/i
            ], [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { 'tablet' : ['p10001l', 'w7001'], '*' : 'mobile' }]], [

            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [

            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
            ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
                
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
            ], [MODEL, [VENDOR, 'Ulefone'], [TYPE, MOBILE]], [

            // Energizer
            /; (energy ?\w+)(?: bui|\))/i,
            /; energizer ([\w ]+)(?: bui|\))/i
            ], [MODEL, [VENDOR, 'Energizer'], [TYPE, MOBILE]], [

            // Cat
            /; cat (b35);/i,
            /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
            ], [MODEL, [VENDOR, 'Cat'], [TYPE, MOBILE]], [

            // Smartfren
            /((?:new )?andromax[\w- ]+)(?: bui|\))/i
            ], [MODEL, [VENDOR, 'Smartfren'], [TYPE, MOBILE]], [

            // Nothing
            /droid.+; (a(in)?(0(15|59|6[35])|142)p?)/i
            ], [MODEL, [VENDOR, 'Nothing'], [TYPE, MOBILE]], [

            // Archos
            /; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i,
            /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i
            ], [MODEL, [VENDOR, 'Archos'], [TYPE, TABLET]], [
            /archos ([\w ]+)( b|\))/i,
            /; (ac[3-6]\d\w{2,8})( b|\))/i 
            ], [MODEL, [VENDOR, 'Archos'], [TYPE, MOBILE]], [

            // HMD
            /; (n159v)/i
            ], [MODEL, [VENDOR, 'HMD'], [TYPE, MOBILE]], [

            // MIXED
            /(imo) (tab \w+)/i,                                                 // IMO
            /(infinix|tecno) (x1101b?|p904|dp(7c|8d|10a)( pro)?|p70[1-3]a?|p904|t1101)/i                     // Infinix XPad / Tecno
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
                                                                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Tecno/Micromax/Advan
            /; (blu|hmd|imo|infinix|lava|oneplus|tcl)[_ ]([\w\+ ]+?)(?: bui|\)|; r)/i,  // BLU/HMD/IMO/Infinix/Lava/OnePlus/TCL
            /(hp) ([\w ]+\w)/i,                                                 // HP iPAQ
            /(microsoft); (lumia[\w ]+)/i,                                      // Microsoft Lumia
            /(oppo) ?([\w ]+) bui/i,                                            // OPPO
            /droid[^;]+; (philips)[_ ]([sv-x][\d]{3,4}[xz]?)/i                  // Philips
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [

            /(kobo)\s(ereader|touch)/i,                                         // Kobo
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,                             // HP TouchPad
            /(kindle)\/([\w\.]+)/i                                              // Kindle
            ], [VENDOR, MODEL, [TYPE, TABLET]], [

            /(surface duo)/i                                                    // Surface Duo
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i                                 // Fairphone
            ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [
            /((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i              // Nvidia Tablets
            ], [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]], [
            /(sprint) (\w+)/i                                                   // Sprint Phones
            ], [VENDOR, MODEL, [TYPE, MOBILE]], [
            /(kin\.[onetw]{3})/i                                                // Microsoft Kin
            ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [
            /droid.+; ([c6]+|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i               // Zebra
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [

            ///////////////////
            // SMARTTVS
            ///////////////////

            /(philips)[\w ]+tv/i,                                               // Philips
            /smart-tv.+(samsung)/i                                              // Samsung
            ], [VENDOR, [TYPE, SMARTTV]], [
            /hbbtv.+maple;(\d+)/i
            ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [
            /(vizio)(?: |.+model\/)(\w+-\w+)/i,                                 // Vizio
            /tcast.+(lg)e?. ([-\w]+)/i                                          // LG SmartTV
            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            ], [[VENDOR, LG], [TYPE, SMARTTV]], [
            /(apple) ?tv/i                                                      // Apple TV
            ], [VENDOR, [MODEL, APPLE+' TV'], [TYPE, SMARTTV]], [
            /crkey.*devicetype\/chromecast/i                                    // Google Chromecast Third Generation
            ], [[MODEL, CHROMECAST+' Third Generation'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
            /crkey.*devicetype\/([^/]*)/i                                       // Google Chromecast with specific device type
            ], [[MODEL, /^/, 'Chromecast '], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
            /fuchsia.*crkey/i                                                   // Google Chromecast Nest Hub
            ], [[MODEL, CHROMECAST+' Nest Hub'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
            /crkey/i                                                            // Google Chromecast, Linux-based or unknown
            ], [[MODEL, CHROMECAST], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
            /(portaltv)/i                                                       // Facebook Portal TV
            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, SMARTTV]], [
            /droid.+aft(\w+)( bui|\))/i                                         // Fire TV
            ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [
            /(shield \w+ tv)/i                                                  // Nvidia Shield TV
            ], [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]], [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i                                               // Sharp
            ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],[
            /(bravia[\w ]+)( bui|\))/i                                          // Sony
            ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [
            /(mi(tv|box)-?\w+) bui/i                                            // Xiaomi
            ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [
            /Hbbtv.*(technisat) (.*);/i                                         // TechniSAT
            ], [VENDOR, MODEL, [TYPE, SMARTTV]], [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,                          // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i         // HbbTV devices
            ], [[VENDOR, /.+\/(\w+)/, '$1', strMapper, {'LG':'lge'}], [MODEL, trim], [TYPE, SMARTTV]], [

            ///////////////////
            // CONSOLES
            ///////////////////

            /(playstation \w+)/i                                                // Playstation
            ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i                                // Microsoft Xbox
            ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [
            /(ouya)/i,                                                          // Ouya
            /(nintendo) (\w+)/i,                                                // Nintendo
            /(retroid) (pocket ([^\)]+))/i                                      // Retroid Pocket
            ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
            /droid.+; (shield)( bui|\))/i                                       // Nvidia Portable
            ], [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]], [

            ///////////////////
            // WEARABLES
            ///////////////////

            /\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i                       // Samsung Galaxy Watch
            ], [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]], [
            /((pebble))app/i,                                                   // Pebble
            /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i        // Asus ZenWatch / LG Watch / Pixel Watch
            ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
            /(ow(?:19|20)?we?[1-3]{1,3})/i                                      // Oppo Watch
            ], [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]], [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i                              // Apple Watch
            ], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [
            /(opwwe\d{3})/i                                                     // OnePlus Watch
            ], [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]], [
            /(moto 360)/i                                                       // Motorola 360
            ], [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]], [
            /(smartwatch 3)/i                                                   // Sony SmartWatch
            ], [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]], [
            /(g watch r)/i                                                      // LG G Watch R
            ], [MODEL, [VENDOR, LG], [TYPE, WEARABLE]], [
            /droid.+; (wt63?0{2,3})\)/i
            ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [

            ///////////////////
            // XR
            ///////////////////

            /droid.+; (glass) \d/i                                              // Google Glass
            ], [MODEL, [VENDOR, GOOGLE], [TYPE, XR]], [
            /(pico) ([\w ]+) os\d/i                                             // Pico
            ], [VENDOR, MODEL, [TYPE, XR]], [
            /(quest( \d| pro)?s?).+vr/i                                         // Meta Quest
            ], [MODEL, [VENDOR, FACEBOOK], [TYPE, XR]], [
            /mobile vr; rv.+firefox/i                                           // Unidentifiable VR device using Firefox Reality / Wolvic
            ], [[TYPE, XR]], [

            ///////////////////
            // EMBEDDED
            ///////////////////

            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i                              // Tesla
            ], [VENDOR, [TYPE, EMBEDDED]], [
            /(aeobc)\b/i                                                        // Echo Dot
            ], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [
            /(homepod).+mac os/i                                                // Apple HomePod
            ], [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]], [
            /windows iot/i                                                      // Unidentifiable embedded device using Windows IoT
            ], [[TYPE, EMBEDDED]], [

            ////////////////////
            // MIXED (GENERIC)
            ///////////////////

            /droid.+; ([\w- ]+) (4k|android|smart|google)[- ]?tv/i              // Unidentifiable SmartTV
            ], [MODEL, [TYPE, SMARTTV]], [
            /\b((4k|android|smart|opera)[- ]?tv|tv; rv:|large screen[\w ]+safari)\b/i
            ], [[TYPE, SMARTTV]], [
            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+?(mobile|vr|\d) safari/i
            ], [MODEL, [TYPE, strMapper, { 'mobile' : 'Mobile', 'xr' : 'VR', '*' : TABLET }]], [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i                      // Unidentifiable Tablet
            ], [[TYPE, TABLET]], [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i    // Unidentifiable Mobile
            ], [[TYPE, MOBILE]], [
            /droid .+?; ([\w\. -]+)( bui|\))/i                                  // Generic Android Device
            ], [MODEL, [VENDOR, 'Generic']]
        ],

        engine : [[

            /windows.+ edge\/([\w\.]+)/i                                       // EdgeHTML
            ], [VERSION, [NAME, EDGE+'HTML']], [

            /(arkweb)\/([\w\.]+)/i                                              // ArkWeb
            ], [NAME, VERSION], [

            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i                         // Blink
            ], [VERSION, [NAME, 'Blink']], [

            /(presto)\/([\w\.]+)/i,                                             // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
            /ekioh(flow)\/([\w\.]+)/i,                                          // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,                           // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,                                      // iCab

            /\b(libweb)/i                                                       // LibWeb
            ], [NAME, VERSION], [
            /ladybird\//i
            ], [[NAME, 'LibWeb']], [

            /rv\:([\w\.]{1,9})\b.+(gecko)/i                                     // Gecko
            ], [VERSION, NAME]
        ],

        os : [[

            // Windows
            /(windows nt) (6\.[23]); arm/i                                      // Windows RT
            ], [[NAME, /N/, 'R'], [VERSION, strMapper, windowsVersionMap]], [
            /(windows (?:phone|mobile|iot))(?: os)?[\/ ]?([\d\.]*( se)?)/i,     // Windows IoT/Mobile/Phone
                                                                                // Windows NT/3.1/95/98/ME/2000/XP/Vista/7/8/8.1/10/11
            /(windows)[\/ ](1[01]|2000|3\.1|7|8(\.1)?|9[58]|me|server 20\d\d( r2)?|vista|xp)/i
            ], [NAME, VERSION], [
            /windows nt ?([\d\.\)]*)(?!.+xbox)/i,
            /\bwin(?=3| ?9|n)(?:nt| 9x )?([\d\.;]*)/i
            ], [[VERSION, /(;|\))/g, '', strMapper, windowsVersionMap], [NAME, WINDOWS]], [
            /(windows ce)\/?([\d\.]*)/i                                         // Windows CE
            ], [NAME, VERSION], [

            // iOS/macOS
            /[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i,             // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
            /cfnetwork\/.+darwin/i
            ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+(haiku|morphos))/i                   // Mac OS
            ], [[NAME, 'macOS'], [VERSION, /_/g, '.']], [

            // Google Chromecast
            /android ([\d\.]+).*crkey/i                                         // Google Chromecast, Android-based
            ], [VERSION, [NAME, CHROMECAST + ' Android']], [
            /fuchsia.*crkey\/([\d\.]+)/i                                        // Google Chromecast, Fuchsia-based
            ], [VERSION, [NAME, CHROMECAST + ' Fuchsia']], [
            /crkey\/([\d\.]+).*devicetype\/smartspeaker/i                       // Google Chromecast, Linux-based Smart Speaker
            ], [VERSION, [NAME, CHROMECAST + ' SmartSpeaker']], [
            /linux.*crkey\/([\d\.]+)/i                                          // Google Chromecast, Legacy Linux-based
            ], [VERSION, [NAME, CHROMECAST + ' Linux']], [
            /crkey\/([\d\.]+)/i                                                 // Google Chromecast, unknown
            ], [VERSION, [NAME, CHROMECAST]], [

            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86)/i                              // Android-x86
            ], [VERSION, NAME], [                                               
            /(ubuntu) ([\w\.]+) like android/i                                  // Ubuntu Touch
            ], [[NAME, /(.+)/, '$1 Touch'], VERSION], [
            /(harmonyos)[\/ ]?([\d\.]*)/i,                                      // HarmonyOS
                                                                                // Android/Blackberry/WebOS/QNX/Bada/RIM/KaiOS/Maemo/MeeGo/S40/Sailfish OS/OpenHarmony/Tizen
            /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen)\w*[-\/\.; ]?([\d\.]*)/i
            ], [NAME, VERSION], [
            /\(bb(10);/i                                                        // BlackBerry 10
            ], [VERSION, [NAME, BLACKBERRY]], [
            /(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i       // Symbian
            ], [VERSION, [NAME, 'Symbian']], [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
            ], [VERSION, [NAME, FIREFOX+' OS']], [
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i,                             // WebOS
            /webos(?:[ \/]?|\.tv-20(?=2[2-9]))(\d[\d\.]*)/i
            ], [VERSION, [NAME, 'webOS']], [
            /web0s;.+?(?:chr[o0]me|safari)\/(\d+)/i
                                                                                // https://webostv.developer.lge.com/develop/specifications/web-api-and-web-engine
            ], [[VERSION, strMapper, {'25':'120','24':'108','23':'94','22':'87','6':'79','5':'68','4':'53','3':'38','2':'538','1':'537','*':'TV'}], [NAME, 'webOS']], [                   
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i                              // watchOS
            ], [VERSION, [NAME, 'watchOS']], [

            // Google ChromeOS
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i                                  // Chromium OS
            ], [[NAME, "Chrome OS"], VERSION],[

            // Smart TVs
            /panasonic;(viera)/i,                                               // Panasonic Viera
            /(netrange)mmh/i,                                                   // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,                                         // NetTV

            // Console
            /(nintendo|playstation) (\w+)/i,                                    // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,                                         // Microsoft Xbox (360, One, X, S, Series X, Series S)
            /(pico) .+os([\w\.]+)/i,                                            // Pico

            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,                            // Joli/Palm
            /linux.+(mint)[\/\(\) ]?([\w\.]*)/i,                                // Mint
            /(mageia|vectorlinux|fuchsia|arcaos|arch(?= ?linux))[;l ]([\d\.]*)/i,  // Mageia/VectorLinux/Fuchsia/ArcaOS/Arch
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire|knoppix)(?: gnu[\/ ]linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                                                                                // Ubuntu/Debian/SUSE/Gentoo/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire/Knoppix
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,                              // Solaris
            /\b(aix)[; ]([1-9\.]{0,4})/i,                                       // AIX
            /(hurd|linux|morphos)(?: (?:arm|x86|ppc)\w*| ?)([\w\.]*)/i,         // Hurd/Linux/MorphOS
            /(gnu) ?([\w\.]*)/i,                                                // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) ?(r\d)?/i                                                  // Haiku
            ], [NAME, VERSION], [
            /(sunos) ?([\d\.]*)/i                                               // Solaris
            ], [[NAME, 'Solaris'], VERSION], [
            /\b(beos|os\/2|amigaos|openvms|hp-ux|serenityos)/i,                 // BeOS/OS2/AmigaOS/OpenVMS/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i                                                // UNIX
            ], [NAME, VERSION]
        ]
    };

    /////////////////
    // Factories
    ////////////////

    var defaultProps = (function () {
            var props = { init : {}, isIgnore : {}, isIgnoreRgx : {}, toString : {}};
            setProps.call(props.init, [
                [UA_BROWSER, [NAME, VERSION, MAJOR, TYPE]],
                [UA_CPU, [ARCHITECTURE]],
                [UA_DEVICE, [TYPE, MODEL, VENDOR]],
                [UA_ENGINE, [NAME, VERSION]],
                [UA_OS, [NAME, VERSION]]
            ]);
            setProps.call(props.isIgnore, [
                [UA_BROWSER, [VERSION, MAJOR]],
                [UA_ENGINE, [VERSION]],
                [UA_OS, [VERSION]]
            ]);
            setProps.call(props.isIgnoreRgx, [
                [UA_BROWSER, / ?browser$/i],
                [UA_OS, / ?os$/i]
            ]);
            setProps.call(props.toString, [
                [UA_BROWSER, [NAME, VERSION]],
                [UA_CPU, [ARCHITECTURE]],
                [UA_DEVICE, [VENDOR, MODEL]],
                [UA_ENGINE, [NAME, VERSION]],
                [UA_OS, [NAME, VERSION]]
            ]);
            return props;
    })();

    var createIData = function (item, itemType) {

        var init_props = defaultProps.init[itemType],
            is_ignoreProps = defaultProps.isIgnore[itemType] || 0,
            is_ignoreRgx = defaultProps.isIgnoreRgx[itemType] || 0,
            toString_props = defaultProps.toString[itemType] || 0;

        function IData () {
            setProps.call(this, init_props);
        }

        IData.prototype.getItem = function () {
            return item;
        };

        IData.prototype.withClientHints = function () {

            // nodejs / non-client-hints browsers
            if (!NAVIGATOR_UADATA) {
                return item
                        .parseCH()
                        .get();
            }

            // browsers based on chromium 85+
            return NAVIGATOR_UADATA
                    .getHighEntropyValues(CH_ALL_VALUES)
                    .then(function (res) {
                        return item
                                .setCH(new UACHData(res, false))
                                .parseCH()
                                .get();
            });
        };

        IData.prototype.withFeatureCheck = function () {
            return item.detectFeature().get();
        };

        if (itemType != UA_RESULT) {
            IData.prototype.is = function (strToCheck) {
                var is = false;
                for (var i in this) {
                    if (this.hasOwnProperty(i) && !has(is_ignoreProps, i) && lowerize(is_ignoreRgx ? strip(is_ignoreRgx, this[i]) : this[i]) == lowerize(is_ignoreRgx ? strip(is_ignoreRgx, strToCheck) : strToCheck)) {
                        is = true;
                        if (strToCheck != UNDEF_TYPE) break;
                    } else if (strToCheck == UNDEF_TYPE && is) {
                        is = !is;
                        break;
                    }
                }
                return is;
            };
            IData.prototype.toString = function () {
                var str = EMPTY;
                for (var i in toString_props) {
                    if (typeof(this[toString_props[i]]) !== UNDEF_TYPE) {
                        str += (str ? ' ' : EMPTY) + this[toString_props[i]];
                    }
                }
                return str || UNDEF_TYPE;
            };
        }

        if (!NAVIGATOR_UADATA) {
            IData.prototype.then = function (cb) { 
                var that = this;
                var IDataResolve = function () {
                    for (var prop in that) {
                        if (that.hasOwnProperty(prop)) {
                            this[prop] = that[prop];
                        }
                    }
                };
                IDataResolve.prototype = {
                    is : IData.prototype.is,
                    toString : IData.prototype.toString
                };
                var resolveData = new IDataResolve();
                cb(resolveData);
                return resolveData;
            };
        }

        return new IData();
    };

    /////////////////
    // Constructor
    ////////////////

    function UACHData (uach, isHttpUACH) {
        uach = uach || {};
        setProps.call(this, CH_ALL_VALUES);
        if (isHttpUACH) {
            setProps.call(this, [
                [BRANDS, itemListToArray(uach[CH_HEADER])],
                [FULLVERLIST, itemListToArray(uach[CH_HEADER_FULL_VER_LIST])],
                [MOBILE, /\?1/.test(uach[CH_HEADER_MOBILE])],
                [MODEL, stripQuotes(uach[CH_HEADER_MODEL])],
                [PLATFORM, stripQuotes(uach[CH_HEADER_PLATFORM])],
                [PLATFORMVER, stripQuotes(uach[CH_HEADER_PLATFORM_VER])],
                [ARCHITECTURE, stripQuotes(uach[CH_HEADER_ARCH])],
                [FORMFACTORS, itemListToArray(uach[CH_HEADER_FORM_FACTORS])],
                [BITNESS, stripQuotes(uach[CH_HEADER_BITNESS])]
            ]);
        } else {
            for (var prop in uach) {
                if(this.hasOwnProperty(prop) && typeof uach[prop] !== UNDEF_TYPE) this[prop] = uach[prop];
            }
        }
    }

    function UAItem (itemType, ua, rgxMap, uaCH) {

        this.get = function (prop) {
            if (!prop) return this.data;
            return this.data.hasOwnProperty(prop) ? this.data[prop] : undefined;
        };

        this.set = function (prop, val) {
            this.data[prop] = val;
            return this;
        };

        this.setCH = function (ch) {
            this.uaCH = ch;
            return this;
        };

        this.detectFeature = function () {
            if (NAVIGATOR && NAVIGATOR.userAgent == this.ua) {
                switch (this.itemType) {
                    case UA_BROWSER:
                        // Brave-specific detection
                        if (NAVIGATOR.brave && typeof NAVIGATOR.brave.isBrave == FUNC_TYPE) {
                            this.set(NAME, 'Brave');
                        }
                        break;
                    case UA_DEVICE:
                        // Chrome-specific detection: check for 'mobile' value of navigator.userAgentData
                        if (!this.get(TYPE) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[MOBILE]) {
                            this.set(TYPE, MOBILE);
                        }
                        // iPadOS-specific detection: identified as Mac, but has some iOS-only properties
                        if (this.get(MODEL) == 'Macintosh' && NAVIGATOR && typeof NAVIGATOR.standalone !== UNDEF_TYPE && NAVIGATOR.maxTouchPoints && NAVIGATOR.maxTouchPoints > 2) {
                            this.set(MODEL, 'iPad')
                                .set(TYPE, TABLET);
                        }
                        break;
                    case UA_OS:
                        // Chrome-specific detection: check for 'platform' value of navigator.userAgentData
                        if (!this.get(NAME) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[PLATFORM]) {
                            this.set(NAME, NAVIGATOR_UADATA[PLATFORM]);
                        }
                        break;
                    case UA_RESULT:
                        var data = this.data;
                        var detect = function (itemType) {
                            return data[itemType]
                                    .getItem()
                                    .detectFeature()
                                    .get();
                        };
                        this.set(UA_BROWSER, detect(UA_BROWSER))
                            .set(UA_CPU, detect(UA_CPU))
                            .set(UA_DEVICE, detect(UA_DEVICE))
                            .set(UA_ENGINE, detect(UA_ENGINE))
                            .set(UA_OS, detect(UA_OS));
                }
            }
            return this;
        };

        this.parseUA = function () {
            if (this.itemType != UA_RESULT) {
                rgxMapper.call(this.data, this.ua, this.rgxMap);
            }
            if (this.itemType == UA_BROWSER) {
                this.set(MAJOR, majorize(this.get(VERSION)));
            }
            return this;
        };

        this.parseCH = function () {
            var uaCH = this.uaCH,
                rgxMap = this.rgxMap;
    
            switch (this.itemType) {
                case UA_BROWSER:
                case UA_ENGINE:
                    var brands = uaCH[FULLVERLIST] || uaCH[BRANDS], prevName;
                    if (brands) {
                        for (var i=0; i<brands.length; i++) {
                            var brandName = brands[i].brand || brands[i],
                                brandVersion = brands[i].version;
                            if (this.itemType == UA_BROWSER && 
                                !/not.a.brand/i.test(brandName) && 
                                (!prevName || 
                                    (/Chrom/.test(prevName) && brandName != CHROMIUM) || 
                                    (prevName == EDGE && /WebView2/.test(brandName))
                                )) {
                                    brandName = strMapper(brandName, browserHintsMap);
                                    prevName = this.get(NAME);
                                    if (!(prevName && !/Chrom/.test(prevName) && /Chrom/.test(brandName))) {
                                        this.set(NAME, brandName)
                                            .set(VERSION, brandVersion)
                                            .set(MAJOR, majorize(brandVersion));
                                    }
                                    prevName = brandName;
                            }
                            if (this.itemType == UA_ENGINE && brandName == CHROMIUM) {
                                this.set(VERSION, brandVersion);
                            }
                        }
                    }
                    break;
                case UA_CPU:
                    var archName = uaCH[ARCHITECTURE];
                    if (archName) {
                        if (archName && uaCH[BITNESS] == '64') archName += '64';
                        rgxMapper.call(this.data, archName + ';', rgxMap);
                    }
                    break;
                case UA_DEVICE:
                    if (uaCH[MOBILE]) {
                        this.set(TYPE, MOBILE);
                    }
                    if (uaCH[MODEL]) {
                        this.set(MODEL, uaCH[MODEL]);
                        if (!this.get(TYPE) || !this.get(VENDOR)) {
                            var reParse = {};
                            rgxMapper.call(reParse, 'droid 9; ' + uaCH[MODEL] + ')', rgxMap);
                            if (!this.get(TYPE) && !!reParse.type) {
                                this.set(TYPE, reParse.type);
                            }
                            if (!this.get(VENDOR) && !!reParse.vendor) {
                                this.set(VENDOR, reParse.vendor);
                            }
                        }
                    }
                    if (uaCH[FORMFACTORS]) {
                        var ff;
                        if (typeof uaCH[FORMFACTORS] !== 'string') {
                            var idx = 0;
                            while (!ff && idx < uaCH[FORMFACTORS].length) {
                                ff = strMapper(uaCH[FORMFACTORS][idx++], formFactorsMap);
                            }
                        } else {
                            ff = strMapper(uaCH[FORMFACTORS], formFactorsMap);
                        }
                        this.set(TYPE, ff);
                    }
                    break;
                case UA_OS:
                    var osName = uaCH[PLATFORM];
                    if(osName) {
                        var osVersion = uaCH[PLATFORMVER];
                        if (osName == WINDOWS) osVersion = (parseInt(majorize(osVersion), 10) >= 13 ? '11' : '10');
                        this.set(NAME, osName)
                            .set(VERSION, osVersion);
                    }
                    // Xbox-Specific Detection
                    if (this.get(NAME) == WINDOWS && uaCH[MODEL] == 'Xbox') {
                        this.set(NAME, 'Xbox')
                            .set(VERSION, undefined);
                    }           
                    break;
                case UA_RESULT:
                    var data = this.data;
                    var parse = function (itemType) {
                        return data[itemType]
                                .getItem()
                                .setCH(uaCH)
                                .parseCH()
                                .get();
                    };
                    this.set(UA_BROWSER, parse(UA_BROWSER))
                        .set(UA_CPU, parse(UA_CPU))
                        .set(UA_DEVICE, parse(UA_DEVICE))
                        .set(UA_ENGINE, parse(UA_ENGINE))
                        .set(UA_OS, parse(UA_OS));
            }
            return this;
        };

        setProps.call(this, [
            ['itemType', itemType],
            ['ua', ua],
            ['uaCH', uaCH],
            ['rgxMap', rgxMap],
            ['data', createIData(this, itemType)]
        ]);

        return this;
    }

    function UAParser (ua, extensions, headers) {

        if (typeof ua === OBJ_TYPE) {
            if (isExtensions(ua, true)) {
                if (typeof extensions === OBJ_TYPE) {
                    headers = extensions;               // case UAParser(extensions, headers)           
                }
                extensions = ua;                        // case UAParser(extensions)
            } else {
                headers = ua;                           // case UAParser(headers)
                extensions = undefined;
            }
            ua = undefined;
        } else if (typeof ua === STR_TYPE && !isExtensions(extensions, true)) {
            headers = extensions;                       // case UAParser(ua, headers)
            extensions = undefined;
        }

        if (headers) {
            if (typeof headers.append === FUNC_TYPE) {
                // Convert Headers object into a plain object
                var kv = {};
                headers.forEach(function (v, k) { kv[String(k).toLowerCase()] = v; });
                headers = kv;
            } else {
                // Normalize headers field name into lowercase
                var normalized = {};
                for (var header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        normalized[String(header).toLowerCase()] = headers[header];
                    }
                }
                headers = normalized;
            }
        }
        
        if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions, headers).getResult();
        }

        var userAgent = typeof ua === STR_TYPE ? ua :                                       // Passed user-agent string
                                (headers && headers[USER_AGENT] ? headers[USER_AGENT] :     // User-Agent from passed headers
                                ((NAVIGATOR && NAVIGATOR.userAgent) ? NAVIGATOR.userAgent : // navigator.userAgent
                                    EMPTY)),                                                // empty string

            httpUACH = new UACHData(headers, true),
            regexMap = extensions ? 
                        extend(defaultRegexes, extensions) : 
                        defaultRegexes,

            createItemFunc = function (itemType) {
                if (itemType == UA_RESULT) {
                    return function () {
                        return new UAItem(itemType, userAgent, regexMap, httpUACH)
                                    .set('ua', userAgent)
                                    .set(UA_BROWSER, this.getBrowser())
                                    .set(UA_CPU, this.getCPU())
                                    .set(UA_DEVICE, this.getDevice())
                                    .set(UA_ENGINE, this.getEngine())
                                    .set(UA_OS, this.getOS())
                                    .get();
                    };
                } else {
                    return function () {
                        return new UAItem(itemType, userAgent, regexMap[itemType], httpUACH)
                                    .parseUA()
                                    .get();
                    };
                }
            };
            
        // public methods
        setProps.call(this, [
            ['getBrowser', createItemFunc(UA_BROWSER)],
            ['getCPU', createItemFunc(UA_CPU)],
            ['getDevice', createItemFunc(UA_DEVICE)],
            ['getEngine', createItemFunc(UA_ENGINE)],
            ['getOS', createItemFunc(UA_OS)],
            ['getResult', createItemFunc(UA_RESULT)],
            ['getUA', function () { return userAgent; }],
            ['setUA', function (ua) {
                if (isString(ua))
                    userAgent = ua.length > UA_MAX_LENGTH ? trim(ua, UA_MAX_LENGTH) : ua;
                return this;
            }]
        ])
        .setUA(userAgent);

        return this;
    }

    UAParser.VERSION = LIBVERSION;
    UAParser.BROWSER =  enumerize([NAME, VERSION, MAJOR, TYPE]);
    UAParser.CPU = enumerize([ARCHITECTURE]);
    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);

    ///////////
    // Export
    //////////

    // check js environment
    if (typeof exports !== UNDEF_TYPE) {
        // nodejs env
        if ("object" !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
    } else {
        // requirejs env (optional)
        if ("function" === FUNC_TYPE && __webpack_require__.amdO) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
                return UAParser;
            }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (isWindow) {
            // browser env
            window.UAParser = UAParser;
        }
    }

    // jQuery/Zepto specific (optional)
    // Note:
    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
    //   and we should catch that.
    var $ = isWindow && (window.jQuery || window.Zepto);
    if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function () {
            return parser.getUA();
        };
        $.ua.set = function (ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for (var prop in result) {
                $.ua[prop] = result[prop];
            }
        };
    }

})(typeof window === 'object' ? window : this);


/***/ }),

/***/ 2155:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        for (var i = data.sigBytes - 1; i >= 0; i--) {
	            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	                data.sigBytes = i + 1;
	                break;
	            }
	        }
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));

/***/ }),

/***/ 2169:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        var keystream;

	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));

/***/ }),

/***/ 2183:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Chrome111 = void 0;
const sdpTransform = __webpack_require__(7363);
const enhancedEvents_1 = __webpack_require__(3953);
const Logger_1 = __webpack_require__(2994);
const ortc = __webpack_require__(8046);
const errors_1 = __webpack_require__(4893);
const scalabilityModes_1 = __webpack_require__(3303);
const sdpCommonUtils = __webpack_require__(5544);
const sdpUnifiedPlanUtils = __webpack_require__(5938);
const ortcUtils = __webpack_require__(4256);
const RemoteSdp_1 = __webpack_require__(1305);
const logger = new Logger_1.Logger('Chrome111');
const NAME = 'Chrome111';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Chrome111 extends enhancedEvents_1.EnhancedEventEmitter {
    // Closed flag.
    _closed = false;
    // Handler direction.
    _direction;
    // Remote SDP handler.
    _remoteSdp;
    // Callback to request sending extended RTP capabilities on demand.
    _getSendExtendedRtpCapabilities;
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _forcedLocalDtlsRole;
    // RTCPeerConnection instance.
    _pc;
    // Map of RTCTransceivers indexed by MID.
    _mapMidTransceiver = new Map();
    // Local stream for sending.
    _sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _transportReady = false;
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return {
            name: NAME,
            factory: (options) => new Chrome111(options),
            getNativeRtpCapabilities: async () => {
                logger.debug('getNativeRtpCapabilities()');
                let pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                });
                try {
                    pc.addTransceiver('audio');
                    // Create video transceiver with scalability mode in order to retrieve
                    // Dependency Descriptor header extension.
                    pc.addTransceiver('video', {
                        sendEncodings: [{ scalabilityMode: 'L3T3' }],
                    });
                    const offer = await pc.createOffer();
                    try {
                        pc.close();
                    }
                    catch (error) { }
                    pc = undefined;
                    const sdpObject = sdpTransform.parse(offer.sdp);
                    const nativeRtpCapabilities = Chrome111.getLocalRtpCapabilities(sdpObject);
                    return nativeRtpCapabilities;
                }
                catch (error) {
                    try {
                        pc?.close();
                    }
                    catch (error2) { }
                    pc = undefined;
                    throw error;
                }
            },
            getNativeSctpCapabilities: async () => {
                logger.debug('getNativeSctpCapabilities()');
                return {
                    numStreams: SCTP_NUM_STREAMS,
                };
            },
        };
    }
    static getLocalRtpCapabilities(localSdpObject) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
            sdpObject: localSdpObject,
        });
        // Need to validate and normalize native RTP capabilities.
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        // libwebrtc supports NACK for OPUS but doesn't announce it.
        ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
        return nativeRtpCapabilities;
    }
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities, }) {
        super();
        logger.debug('constructor()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        });
        this._pc.addEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.addEventListener('icecandidateerror', this.onIceCandidateError);
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', this.onConnectionStateChange);
        }
        else {
            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
            this._pc.addEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        }
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        try {
            this._pc.close();
        }
        catch (error) { }
        this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
        this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
        this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        this.emit('@close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            // Set rid and verify scalabilityMode in each encoding.
            // NOTE: Even if WebRTC allows different scalabilityMode (different number
            // of temporal layers) per simulcast stream, we need that those are the
            // same in all them, so let's pick up the highest value.
            // NOTE: If scalabilityMode is not given, Chrome will use L1T3.
            let maxTemporalLayers = 1;
            for (const encoding of encodings) {
                const temporalLayers = encoding.scalabilityMode
                    ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers
                    : 3;
                if (temporalLayers > maxTemporalLayers) {
                    maxTemporalLayers = temporalLayers;
                }
            }
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
                encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
            });
        }
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
            this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const nativeRtpCapabilities = Chrome111.getLocalRtpCapabilities(localSdpObject);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        // Generic sending RTP parameters.
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        // Generic sending RTP parameters suitable for the SDP remote answer.
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = {
            type: 'answer',
            sdp: sdpTransform.write(localSdpObject),
        };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            else {
                // Store in the map.
                this._mapMidTransceiver.set(localId, transceiver);
                results.push({
                    localId,
                    track: transceiver.receiver.track,
                    rtpReceiver: transceiver.receiver,
                });
            }
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    onIceGatheringStateChange = () => {
        this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
    };
    onIceCandidateError = (event) => {
        this.emit('@icecandidateerror', event);
    };
    onConnectionStateChange = () => {
        this.emit('@connectionstatechange', this._pc.connectionState);
    };
    onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
            case 'checking': {
                this.emit('@connectionstatechange', 'connecting');
                break;
            }
            case 'connected':
            case 'completed': {
                this.emit('@connectionstatechange', 'connected');
                break;
            }
            case 'failed': {
                this.emit('@connectionstatechange', 'failed');
                break;
            }
            case 'disconnected': {
                this.emit('@connectionstatechange', 'disconnected');
                break;
            }
            case 'closed': {
                this.emit('@connectionstatechange', 'closed');
                break;
            }
        }
    };
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Chrome111 = Chrome111;


/***/ }),

/***/ 2211:
/***/ ((module) => {

"use strict";
/*
 * random-string
 * https://github.com/valiton/node-random-string
 *
 * Copyright (c) 2013 Valiton GmbH, Bastian 'hereandnow' Behrens
 * Licensed under the MIT license.
 */



var numbers = '0123456789',
    letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
    specials = '!$%^&*()_+|~-=`{}[]:;<>?,./';


function _defaults (opts) {
  opts || (opts = {});
  return {
    length: opts.length || 8,
    numeric: typeof opts.numeric === 'boolean' ? opts.numeric : true,
    letters: typeof opts.letters === 'boolean' ? opts.letters : true,
    special: typeof opts.special === 'boolean' ? opts.special : false,
    exclude: Array.isArray(opts.exclude)       ? opts.exclude : []
  };
}

function _buildChars (opts) {
  var chars = '';
  if (opts.numeric) { chars += numbers; }
  if (opts.letters) { chars += letters; }
  if (opts.special) { chars += specials; }
  for (var i = 0; i <= opts.exclude.length; i++){
    chars = chars.replace(opts.exclude[i], "");
  }
  return chars;
}

module.exports = function randomString(opts) {
  opts = _defaults(opts);
  var i, rn,
      rnd = '',
      len = opts.length,
      exclude = opts.exclude,
      randomChars = _buildChars(opts);
  for (i = 1; i <= len; i++) {
    rnd += randomChars.substring(rn = Math.floor(Math.random() * randomChars.length), rn + 1);
  }
  return rnd;
};



/***/ }),

/***/ 2215:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
;(function (factory) {
	var registeredInModuleLoader;
	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		registeredInModuleLoader = true;
	}
	if (true) {
		module.exports = factory();
		registeredInModuleLoader = true;
	}
	if (!registeredInModuleLoader) {
		var OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function decode (s) {
		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
	}

	function init (converter) {
		function api() {}

		function set (key, value, attributes) {
			if (typeof document === 'undefined') {
				return;
			}

			attributes = extend({
				path: '/'
			}, api.defaults, attributes);

			if (typeof attributes.expires === 'number') {
				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
			}

			// We're using "expires" because "max-age" is not supported by IE
			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

			try {
				var result = JSON.stringify(value);
				if (/^[\{\[]/.test(result)) {
					value = result;
				}
			} catch (e) {}

			value = converter.write ?
				converter.write(value, key) :
				encodeURIComponent(String(value))
					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

			key = encodeURIComponent(String(key))
				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
				.replace(/[\(\)]/g, escape);

			var stringifiedAttributes = '';
			for (var attributeName in attributes) {
				if (!attributes[attributeName]) {
					continue;
				}
				stringifiedAttributes += '; ' + attributeName;
				if (attributes[attributeName] === true) {
					continue;
				}

				// Considers RFC 6265 section 5.2:
				// ...
				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
				//     character:
				// Consume the characters of the unparsed-attributes up to,
				// not including, the first %x3B (";") character.
				// ...
				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
			}

			return (document.cookie = key + '=' + value + stringifiedAttributes);
		}

		function get (key, json) {
			if (typeof document === 'undefined') {
				return;
			}

			var jar = {};
			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all.
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var cookie = parts.slice(1).join('=');

				if (!json && cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					var name = decode(parts[0]);
					cookie = (converter.read || converter)(cookie, name) ||
						decode(cookie);

					if (json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					jar[name] = cookie;

					if (key === name) {
						break;
					}
				} catch (e) {}
			}

			return key ? jar[key] : jar;
		}

		api.set = set;
		api.get = function (key) {
			return get(key, false /* read as raw */);
		};
		api.getJSON = function (key) {
			return get(key, true /* read as json */);
		};
		api.remove = function (key, attributes) {
			set(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.defaults = {};

		api.withConverter = init;

		return api;
	}

	return init(function () {});
}));


/***/ }),

/***/ 2284:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}


/***/ }),

/***/ 2292:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Firefox120 = void 0;
const sdpTransform = __webpack_require__(7363);
const enhancedEvents_1 = __webpack_require__(3953);
const Logger_1 = __webpack_require__(2994);
const errors_1 = __webpack_require__(4893);
const ortc = __webpack_require__(8046);
const scalabilityModes_1 = __webpack_require__(3303);
const sdpCommonUtils = __webpack_require__(5544);
const sdpUnifiedPlanUtils = __webpack_require__(5938);
const RemoteSdp_1 = __webpack_require__(1305);
const logger = new Logger_1.Logger('Firefox120');
const NAME = 'Firefox120';
const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
class Firefox120 extends enhancedEvents_1.EnhancedEventEmitter {
    // Closed flag.
    _closed = false;
    // Handler direction.
    _direction;
    // Remote SDP handler.
    _remoteSdp;
    // Callback to request sending extended RTP capabilities on demand.
    _getSendExtendedRtpCapabilities;
    // RTCPeerConnection instance.
    _pc;
    // Map of RTCTransceivers indexed by MID.
    _mapMidTransceiver = new Map();
    // Local stream for sending.
    _sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _transportReady = false;
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return {
            name: NAME,
            factory: (options) => new Firefox120(options),
            getNativeRtpCapabilities: async () => {
                logger.debug('getNativeRtpCapabilities()');
                let pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                });
                // NOTE: We need to add a real video track to get the RID extension mapping,
                // otherwiser Firefox doesn't include it in the SDP.
                const canvas = document.createElement('canvas');
                // NOTE: Otherwise Firefox fails in next line.
                canvas.getContext('2d');
                const fakeStream = canvas.captureStream();
                const fakeVideoTrack = fakeStream.getVideoTracks()[0];
                try {
                    pc.addTransceiver('audio', { direction: 'sendrecv' });
                    pc.addTransceiver(fakeVideoTrack, {
                        direction: 'sendrecv',
                        sendEncodings: [
                            { rid: 'r0', maxBitrate: 100000 },
                            { rid: 'r1', maxBitrate: 500000 },
                        ],
                    });
                    const offer = await pc.createOffer();
                    try {
                        canvas.remove();
                    }
                    catch (error) { }
                    try {
                        fakeVideoTrack.stop();
                    }
                    catch (error) { }
                    try {
                        pc.close();
                    }
                    catch (error) { }
                    pc = undefined;
                    const sdpObject = sdpTransform.parse(offer.sdp);
                    const nativeRtpCapabilities = Firefox120.getLocalRtpCapabilities(sdpObject);
                    return nativeRtpCapabilities;
                }
                catch (error) {
                    try {
                        canvas.remove();
                    }
                    catch (error2) { }
                    try {
                        fakeVideoTrack.stop();
                    }
                    catch (error2) { }
                    try {
                        pc?.close();
                    }
                    catch (error2) { }
                    pc = undefined;
                    throw error;
                }
            },
            getNativeSctpCapabilities: async () => {
                logger.debug('getNativeSctpCapabilities()');
                return {
                    numStreams: SCTP_NUM_STREAMS,
                };
            },
        };
    }
    static getLocalRtpCapabilities(localSdpObject) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
            sdpObject: localSdpObject,
        });
        // Need to validate and normalize native RTP capabilities.
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        return nativeRtpCapabilities;
    }
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities, }) {
        super();
        logger.debug('constructor()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        });
        this._pc.addEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.addEventListener('icecandidateerror', this.onIceCandidateError);
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', this.onConnectionStateChange);
        }
        else {
            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
            this._pc.addEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        }
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        try {
            this._pc.close();
        }
        catch (error) { }
        this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
        this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
        this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        this.emit('@close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        // NOTE: Firefox does not implement pc.setConfiguration().
        throw new errors_1.UnsupportedError('not supported');
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
            });
        }
        // NOTE: Firefox fails sometimes to properly anticipate the closed media
        // section that it should use, so don't reuse closed media sections.
        //   https://github.com/versatica/mediasoup-client/issues/104
        //
        // const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
            sendEncodings: encodings,
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
            this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const nativeRtpCapabilities = Firefox120.getLocalRtpCapabilities(localSdpObject);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        // Generic sending RTP parameters.
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        // Generic sending RTP parameters suitable for the SDP remote answer.
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        // In Firefox use DTLS role client even if we are the "offerer" since
        // Firefox does not respect ICE-Lite.
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings by parsing the SDP offer if no encodings are given.
        if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
        }
        // Set RTP encodings by parsing the SDP offer and complete them with given
        // one if just a single encoding has been given.
        else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                offerMediaObject,
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
        }
        // Otherwise if more than 1 encoding are given use them verbatim.
        else {
            sendingRtpParameters.encodings = encodings;
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        // NOTE: Cannot use stop() the transceiver due to the the note above in
        // send() method.
        // try
        // {
        // 	transceiver.stop();
        // }
        // catch (error)
        // {}
        this._pc.removeTrack(transceiver.sender);
        // NOTE: Cannot use closeMediaSection() due to the the note above in send()
        // method.
        // this._remoteSdp.closeMediaSection(transceiver.mid);
        this._remoteSdp.disableMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated transceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
            answer = {
                type: 'answer',
                sdp: sdpTransform.write(localSdpObject),
            };
        }
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({ localDtlsRole: 'client', localSdpObject });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    onIceGatheringStateChange = () => {
        this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
    };
    onIceCandidateError = (event) => {
        this.emit('@icecandidateerror', event);
    };
    onConnectionStateChange = () => {
        this.emit('@connectionstatechange', this._pc.connectionState);
    };
    onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
            case 'checking': {
                this.emit('@connectionstatechange', 'connecting');
                break;
            }
            case 'connected':
            case 'completed': {
                this.emit('@connectionstatechange', 'connected');
                break;
            }
            case 'failed': {
                this.emit('@connectionstatechange', 'failed');
                break;
            }
            case 'disconnected': {
                this.emit('@connectionstatechange', 'disconnected');
                break;
            }
            case 'closed': {
                this.emit('@connectionstatechange', 'closed');
                break;
            }
        }
    };
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Firefox120 = Firefox120;


/***/ }),

/***/ 2614:
/***/ ((__unused_webpack_module, exports) => {

var IDX=256, HEX=[], BUFFER;
while (IDX--) HEX[IDX] = (IDX + 256).toString(16).substring(1);

function v4() {
	var i=0, num, out='';

	if (!BUFFER || ((IDX + 16) > 256)) {
		BUFFER = Array(i=256);
		while (i--) BUFFER[i] = 256 * Math.random() | 0;
		i = IDX = 0;
	}

	for (; i < 16; i++) {
		num = BUFFER[IDX + i];
		if (i==6) out += HEX[num & 15 | 64];
		else if (i==8) out += HEX[num & 63 | 128];
		else out += HEX[num];

		if (i & 1 && i > 1 && i < 11) out += '-';
	}

	IDX++;
	return out;
}

exports.v4 = v4;

/***/ }),

/***/ 2696:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));

/***/ }),

/***/ 2731:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FakeHandler = void 0;
const fake_mediastreamtrack_1 = __webpack_require__(5328);
const enhancedEvents_1 = __webpack_require__(3953);
const Logger_1 = __webpack_require__(2994);
const utils = __webpack_require__(1765);
const ortc = __webpack_require__(8046);
const errors_1 = __webpack_require__(4893);
const FakeEventTarget_1 = __webpack_require__(3051);
const logger = new Logger_1.Logger('FakeHandler');
const NAME = 'FakeHandler';
class FakeHandler extends enhancedEvents_1.EnhancedEventEmitter {
    // Closed flag.
    _closed = false;
    // Fake parameters source of RTP and SCTP parameters and capabilities.
    _fakeParameters;
    // Callback to request sending extended RTP capabilities on demand.
    _getSendExtendedRtpCapabilities;
    // Local RTCP CNAME.
    _cname = `CNAME-${utils.generateRandomNumber()}`;
    // Got transport local and remote parameters.
    _transportReady = false;
    // Next localId.
    _nextLocalId = 1;
    // Sending and receiving tracks indexed by localId.
    _tracks = new Map();
    // DataChannel id value counter. It must be incremented for each new DataChannel.
    _nextSctpStreamId = 0;
    /**
     * Creates a factory function.
     */
    static createFactory(fakeParameters) {
        return {
            name: NAME,
            factory: (options) => new FakeHandler(options, fakeParameters),
            getNativeRtpCapabilities: async () => {
                logger.debug('getNativeRtpCapabilities()');
                return FakeHandler.getLocalRtpCapabilities(fakeParameters);
            },
            getNativeSctpCapabilities: async () => {
                logger.debug('getNativeSctpCapabilities()');
                return fakeParameters.generateNativeSctpCapabilities();
            },
        };
    }
    static getLocalRtpCapabilities(fakeParameters) {
        const nativeRtpCapabilities = fakeParameters.generateNativeRtpCapabilities();
        // Need to validate and normalize native RTP capabilities.
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        return nativeRtpCapabilities;
    }
    constructor({ 
    // direction,
    // iceParameters,
    // iceCandidates,
    // dtlsParameters,
    // sctpParameters,
    // iceServers,
    // iceTransportPolicy,
    // additionalSettings,
    getSendExtendedRtpCapabilities, }, fakeParameters) {
        super();
        logger.debug('constructor()');
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        this._fakeParameters = fakeParameters;
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
    }
    // NOTE: Custom method for simulation purposes.
    setIceGatheringState(iceGatheringState) {
        this.emit('@icegatheringstatechange', iceGatheringState);
    }
    // NOTE: Custom method for simulation purposes.
    setConnectionState(connectionState) {
        this.emit('@connectionstatechange', connectionState);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
    }
    async getTransportStats() {
        this.assertNotClosed();
        return new Map(); // NOTE: Whatever.
    }
    async send(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    { track, encodings, codecOptions, codec }) {
        this.assertNotClosed();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'server' });
        }
        const nativeRtpCapabilities = FakeHandler.getLocalRtpCapabilities(this._fakeParameters);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        // Generic sending RTP parameters.
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const useRtx = sendingRtpParameters.codecs.some(_codec => /.+\/rtx$/i.test(_codec.mimeType));
        sendingRtpParameters.mid = `mid-${utils.generateRandomNumber()}`;
        if (!encodings) {
            encodings = [{}];
        }
        for (const encoding of encodings) {
            encoding.ssrc = utils.generateRandomNumber();
            if (useRtx) {
                encoding.rtx = { ssrc: utils.generateRandomNumber() };
            }
        }
        sendingRtpParameters.encodings = encodings;
        // Fill RTCRtpParameters.rtcp.
        sendingRtpParameters.rtcp = {
            cname: this._cname,
            reducedSize: true,
            mux: true,
        };
        const localId = this._nextLocalId++;
        this._tracks.set(localId, track);
        return { localId: String(localId), rtpParameters: sendingRtpParameters };
    }
    async stopSending(localId) {
        logger.debug('stopSending() [localId:%s]', localId);
        if (this._closed) {
            return;
        }
        if (!this._tracks.has(Number(localId))) {
            throw new Error('local track not found');
        }
        this._tracks.delete(Number(localId));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
        this.assertNotClosed();
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
        this.assertNotClosed();
        // Unimplemented.
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        this._tracks.delete(Number(localId));
        this._tracks.set(Number(localId), track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
        this.assertNotClosed();
        return new Map(); // NOTE: Whatever.
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'server' });
        }
        logger.debug('sendDataChannel()');
        const dataChannel = new FakeRTCDataChannel({
            id: this._nextSctpStreamId++,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol,
        });
        const sctpStreamParameters = {
            streamId: this._nextSctpStreamId,
            ordered: ordered,
            maxPacketLifeTime: maxPacketLifeTime,
            maxRetransmits: maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        const results = [];
        for (const options of optionsList) {
            const { trackId, kind } = options;
            if (!this._transportReady) {
                await this.setupTransport({ localDtlsRole: 'client' });
            }
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = this._nextLocalId++;
            const track = new fake_mediastreamtrack_1.FakeMediaStreamTrack({ kind });
            this._tracks.set(localId, track);
            results.push({ localId: String(localId), track });
        }
        return results;
    }
    async stopReceiving(localIds) {
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            this._tracks.delete(Number(localId));
        }
    }
    async pauseReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        this.assertNotClosed();
        // Unimplemented.
    }
    async resumeReceiving(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localIds) {
        this.assertNotClosed();
        // Unimplemented.
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
        this.assertNotClosed();
        return new Map(); //
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: 'client' });
        }
        logger.debug('receiveDataChannel()');
        const dataChannel = new FakeRTCDataChannel({
            id: sctpStreamParameters.streamId,
            ordered: sctpStreamParameters.ordered,
            maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime,
            maxRetransmits: sctpStreamParameters.maxRetransmits,
            label,
            protocol,
        });
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    localSdpObject, }) {
        const dtlsParameters = utils.clone(this._fakeParameters.generateLocalDtlsParameters());
        // Set our DTLS role.
        if (localDtlsRole) {
            dtlsParameters.role = localDtlsRole;
        }
        // Assume we are connecting now.
        this.emit('@connectionstatechange', 'connecting');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => this.emit('@connect', { dtlsParameters }, resolve, reject));
        this._transportReady = true;
    }
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
}
exports.FakeHandler = FakeHandler;
/**
 * @remarks
 * - We use a custom FakeEventTarget class because Hermes JS engine in
 *   React-Native doesn't implement EventListener.
 */
class FakeRTCDataChannel extends FakeEventTarget_1.FakeEventTarget {
    // Members for RTCDataChannel standard public getters/setters.
    _id;
    _negotiated = true; // mediasoup just uses negotiated DataChannels.
    _ordered;
    _maxPacketLifeTime;
    _maxRetransmits;
    _label;
    _protocol;
    _readyState = 'connecting';
    _bufferedAmount = 0;
    _bufferedAmountLowThreshold = 0;
    _binaryType = 'arraybuffer';
    // Events.
    _onopen = null;
    _onclosing = null;
    _onclose = null;
    _onmessage = null;
    _onbufferedamountlow = null;
    _onerror = null;
    constructor({ id, ordered = true, maxPacketLifeTime = null, maxRetransmits = null, label = '', protocol = '', }) {
        super();
        logger.debug(`constructor() [id:${id}, ordered:${ordered}, maxPacketLifeTime:${maxPacketLifeTime}, maxRetransmits:${maxRetransmits}, label:${label}, protocol:${protocol}`);
        this._id = id;
        this._ordered = ordered;
        this._maxPacketLifeTime = maxPacketLifeTime;
        this._maxRetransmits = maxRetransmits;
        this._label = label;
        this._protocol = protocol;
    }
    get id() {
        return this._id;
    }
    get negotiated() {
        return this._negotiated;
    }
    get ordered() {
        return this._ordered;
    }
    get maxPacketLifeTime() {
        return this._maxPacketLifeTime;
    }
    get maxRetransmits() {
        return this._maxRetransmits;
    }
    get label() {
        return this._label;
    }
    get protocol() {
        return this._protocol;
    }
    get readyState() {
        return this._readyState;
    }
    get bufferedAmount() {
        return this._bufferedAmount;
    }
    get bufferedAmountLowThreshold() {
        return this._bufferedAmountLowThreshold;
    }
    set bufferedAmountLowThreshold(value) {
        this._bufferedAmountLowThreshold = value;
    }
    get binaryType() {
        return this._binaryType;
    }
    set binaryType(binaryType) {
        this._binaryType = binaryType;
    }
    get onopen() {
        return this._onopen;
    }
    set onopen(handler) {
        if (this._onopen) {
            this.removeEventListener('open', this._onopen);
        }
        this._onopen = handler;
        if (handler) {
            this.addEventListener('open', handler);
        }
    }
    get onclosing() {
        return this._onclosing;
    }
    set onclosing(handler) {
        if (this._onclosing) {
            this.removeEventListener('closing', this._onclosing);
        }
        this._onclosing = handler;
        if (handler) {
            this.addEventListener('closing', handler);
        }
    }
    get onclose() {
        return this._onclose;
    }
    set onclose(handler) {
        if (this._onclose) {
            this.removeEventListener('close', this._onclose);
        }
        this._onclose = handler;
        if (handler) {
            this.addEventListener('close', handler);
        }
    }
    get onmessage() {
        return this._onmessage;
    }
    set onmessage(handler) {
        if (this._onmessage) {
            this.removeEventListener('message', this._onmessage);
        }
        this._onmessage = handler;
        if (handler) {
            this.addEventListener('message', handler);
        }
    }
    get onbufferedamountlow() {
        return this._onbufferedamountlow;
    }
    set onbufferedamountlow(handler) {
        if (this._onbufferedamountlow) {
            this.removeEventListener('bufferedamountlow', this._onbufferedamountlow);
        }
        this._onbufferedamountlow = handler;
        if (handler) {
            this.addEventListener('bufferedamountlow', handler);
        }
    }
    get onerror() {
        return this._onerror;
    }
    set onerror(handler) {
        if (this._onerror) {
            this.removeEventListener('error', this._onerror);
        }
        this._onerror = handler;
        if (handler) {
            this.addEventListener('error', handler);
        }
    }
    addEventListener(type, listener, options) {
        super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
    }
    close() {
        if (['closing', 'closed'].includes(this._readyState)) {
            return;
        }
        this._readyState = 'closed';
    }
    /**
     * We extend the definition of send() to allow Node Buffer. However
     * ArrayBufferView and Blob do not exist in Node.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    send(data) {
        if (this._readyState !== 'open') {
            throw new errors_1.InvalidStateError('not open');
        }
    }
}


/***/ }),

/***/ 2901:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _createClass)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(816);

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}


/***/ }),

/***/ 2994:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const debug_1 = __webpack_require__(7833);
const APP_NAME = 'mediasoup-client';
class Logger {
    _debug;
    _warn;
    _error;
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;


/***/ }),

/***/ 3009:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),

/***/ 3029:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _classCallCheck)
/* harmony export */ });
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}


/***/ }),

/***/ 3051:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FakeEventTarget = void 0;
class FakeEventTarget {
    listeners = {};
    addEventListener(type, callback, options) {
        if (!callback) {
            return;
        }
        this.listeners[type] ??= [];
        this.listeners[type].push({
            callback: typeof callback === 'function' ? callback : callback.handleEvent,
            once: typeof options === 'object' && options.once === true,
        });
    }
    removeEventListener(type, callback, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        if (!this.listeners[type]) {
            return;
        }
        if (!callback) {
            return;
        }
        this.listeners[type] = this.listeners[type].filter(listener => listener.callback !==
            (typeof callback === 'function' ? callback : callback.handleEvent));
    }
    dispatchEvent(event) {
        if (!event || typeof event.type !== 'string') {
            throw new Error('invalid event object');
        }
        const entries = this.listeners[event.type];
        if (!entries) {
            return true;
        }
        for (const listener of [...entries]) {
            try {
                listener.callback.call(this, event);
            }
            catch (error) {
                // Avoid that the error breaks the iteration.
                setTimeout(() => {
                    throw error;
                }, 0);
            }
            if (listener.once) {
                this.removeEventListener(event.type, listener.callback);
            }
        }
        return !event.defaultPrevented;
    }
}
exports.FakeEventTarget = FakeEventTarget;


/***/ }),

/***/ 3128:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    const N = 16;

	    //Origin pbox and sbox, derived from PI
	    const ORIG_P = [
	        0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
	        0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
	        0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
	        0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,
	        0x9216D5D9, 0x8979FB1B
	    ];

	    const ORIG_S = [
	        [   0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,
	            0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,
	            0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,
	            0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,
	            0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,
	            0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,
	            0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,
	            0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,
	            0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,
	            0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,
	            0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,
	            0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,
	            0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,
	            0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,
	            0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,
	            0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,
	            0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,
	            0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,
	            0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,
	            0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,
	            0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,
	            0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,
	            0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,
	            0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,
	            0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,
	            0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,
	            0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,
	            0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,
	            0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,
	            0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,
	            0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,
	            0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,
	            0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,
	            0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,
	            0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,
	            0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,
	            0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,
	            0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,
	            0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,
	            0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,
	            0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,
	            0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,
	            0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,
	            0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,
	            0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,
	            0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,
	            0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,
	            0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,
	            0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,
	            0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,
	            0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,
	            0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,
	            0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,
	            0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,
	            0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,
	            0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,
	            0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,
	            0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,
	            0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,
	            0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,
	            0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,
	            0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,
	            0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,
	            0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A   ],
	        [   0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,
	            0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,
	            0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,
	            0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,
	            0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,
	            0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,
	            0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,
	            0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,
	            0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,
	            0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,
	            0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,
	            0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,
	            0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,
	            0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,
	            0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,
	            0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,
	            0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,
	            0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,
	            0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,
	            0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,
	            0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,
	            0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,
	            0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,
	            0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,
	            0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,
	            0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,
	            0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,
	            0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,
	            0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,
	            0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,
	            0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,
	            0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,
	            0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,
	            0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,
	            0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,
	            0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,
	            0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,
	            0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,
	            0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,
	            0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,
	            0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,
	            0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,
	            0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,
	            0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,
	            0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,
	            0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,
	            0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,
	            0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,
	            0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,
	            0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,
	            0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,
	            0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,
	            0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,
	            0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,
	            0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,
	            0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,
	            0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,
	            0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,
	            0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,
	            0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,
	            0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,
	            0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,
	            0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,
	            0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7   ],
	        [   0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,
	            0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,
	            0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,
	            0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,
	            0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,
	            0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,
	            0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,
	            0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,
	            0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,
	            0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,
	            0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,
	            0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,
	            0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,
	            0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,
	            0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,
	            0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,
	            0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,
	            0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,
	            0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,
	            0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,
	            0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,
	            0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,
	            0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,
	            0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,
	            0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,
	            0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,
	            0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,
	            0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,
	            0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,
	            0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,
	            0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,
	            0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,
	            0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,
	            0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,
	            0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,
	            0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,
	            0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,
	            0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,
	            0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,
	            0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,
	            0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,
	            0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,
	            0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,
	            0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,
	            0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,
	            0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,
	            0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,
	            0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,
	            0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,
	            0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,
	            0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,
	            0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,
	            0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,
	            0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,
	            0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,
	            0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,
	            0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,
	            0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,
	            0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,
	            0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,
	            0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,
	            0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,
	            0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,
	            0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0  ],
	        [   0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,
	            0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,
	            0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,
	            0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,
	            0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,
	            0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,
	            0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,
	            0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,
	            0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,
	            0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,
	            0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,
	            0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,
	            0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,
	            0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,
	            0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,
	            0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,
	            0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,
	            0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,
	            0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,
	            0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,
	            0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,
	            0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,
	            0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,
	            0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,
	            0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,
	            0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,
	            0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,
	            0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,
	            0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,
	            0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,
	            0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,
	            0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,
	            0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,
	            0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,
	            0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,
	            0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,
	            0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,
	            0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,
	            0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,
	            0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,
	            0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,
	            0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,
	            0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,
	            0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,
	            0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,
	            0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,
	            0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,
	            0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,
	            0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,
	            0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,
	            0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,
	            0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,
	            0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,
	            0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,
	            0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,
	            0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,
	            0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,
	            0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,
	            0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,
	            0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,
	            0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,
	            0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,
	            0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,
	            0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6  ]
	    ];

	    var BLOWFISH_CTX = {
	        pbox: [],
	        sbox: []
	    }

	    function F(ctx, x){
	        let a = (x >> 24) & 0xFF;
	        let b = (x >> 16) & 0xFF;
	        let c = (x >> 8) & 0xFF;
	        let d = x & 0xFF;

	        let y = ctx.sbox[0][a] + ctx.sbox[1][b];
	        y = y ^ ctx.sbox[2][c];
	        y = y + ctx.sbox[3][d];

	        return y;
	    }

	    function BlowFish_Encrypt(ctx, left, right){
	        let Xl = left;
	        let Xr = right;
	        let temp;

	        for(let i = 0; i < N; ++i){
	            Xl = Xl ^ ctx.pbox[i];
	            Xr = F(ctx, Xl) ^ Xr;

	            temp = Xl;
	            Xl = Xr;
	            Xr = temp;
	        }

	        temp = Xl;
	        Xl = Xr;
	        Xr = temp;

	        Xr = Xr ^ ctx.pbox[N];
	        Xl = Xl ^ ctx.pbox[N + 1];

	        return {left: Xl, right: Xr};
	    }

	    function BlowFish_Decrypt(ctx, left, right){
	        let Xl = left;
	        let Xr = right;
	        let temp;

	        for(let i = N + 1; i > 1; --i){
	            Xl = Xl ^ ctx.pbox[i];
	            Xr = F(ctx, Xl) ^ Xr;

	            temp = Xl;
	            Xl = Xr;
	            Xr = temp;
	        }

	        temp = Xl;
	        Xl = Xr;
	        Xr = temp;

	        Xr = Xr ^ ctx.pbox[1];
	        Xl = Xl ^ ctx.pbox[0];

	        return {left: Xl, right: Xr};
	    }

	    /**
	     * Initialization ctx's pbox and sbox.
	     *
	     * @param {Object} ctx The object has pbox and sbox.
	     * @param {Array} key An array of 32-bit words.
	     * @param {int} keysize The length of the key.
	     *
	     * @example
	     *
	     *     BlowFishInit(BLOWFISH_CTX, key, 128/32);
	     */
	    function BlowFishInit(ctx, key, keysize)
	    {
	        for(let Row = 0; Row < 4; Row++)
	        {
	            ctx.sbox[Row] = [];
	            for(let Col = 0; Col < 256; Col++)
	            {
	                ctx.sbox[Row][Col] = ORIG_S[Row][Col];
	            }
	        }

	        let keyIndex = 0;
	        for(let index = 0; index < N + 2; index++)
	        {
	            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
	            keyIndex++;
	            if(keyIndex >= keysize)
	            {
	                keyIndex = 0;
	            }
	        }

	        let Data1 = 0;
	        let Data2 = 0;
	        let res = 0;
	        for(let i = 0; i < N + 2; i += 2)
	        {
	            res = BlowFish_Encrypt(ctx, Data1, Data2);
	            Data1 = res.left;
	            Data2 = res.right;
	            ctx.pbox[i] = Data1;
	            ctx.pbox[i + 1] = Data2;
	        }

	        for(let i = 0; i < 4; i++)
	        {
	            for(let j = 0; j < 256; j += 2)
	            {
	                res = BlowFish_Encrypt(ctx, Data1, Data2);
	                Data1 = res.left;
	                Data2 = res.right;
	                ctx.sbox[i][j] = Data1;
	                ctx.sbox[i][j + 1] = Data2;
	            }
	        }

	        return true;
	    }

	    /**
	     * Blowfish block cipher algorithm.
	     */
	    var Blowfish = C_algo.Blowfish = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            //Initialization pbox and sbox
	            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
	        },

	        encryptBlock: function (M, offset) {
	            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
	            M[offset] = res.left;
	            M[offset + 1] = res.right;
	        },

	        decryptBlock: function (M, offset) {
	            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
	            M[offset] = res.left;
	            M[offset + 1] = res.right;
	        },

	        blockSize: 64/32,

	        keySize: 128/32,

	        ivSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Blowfish.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Blowfish.decrypt(ciphertext, key, cfg);
	     */
	    C.Blowfish = BlockCipher._createHelper(Blowfish);
	}());


	return CryptoJS.Blowfish;

}));

/***/ }),

/***/ 3145:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _arrayLikeToArray)
/* harmony export */ });
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}


/***/ }),

/***/ 3200:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
exports.parseProfileLevelId = parseProfileLevelId;
exports.profileLevelIdToString = profileLevelIdToString;
exports.profileToString = profileToString;
exports.levelToString = levelToString;
exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
exports.isSameProfile = isSameProfile;
exports.isSameProfileAndLevel = isSameProfileAndLevel;
exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
exports.supportedLevel = supportedLevel;
const Logger_1 = __webpack_require__(3582);
const logger = new Logger_1.Logger();
/**
 * Supported profiles.
 */
var Profile;
(function (Profile) {
    Profile[Profile["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
    Profile[Profile["Baseline"] = 2] = "Baseline";
    Profile[Profile["Main"] = 3] = "Main";
    Profile[Profile["ConstrainedHigh"] = 4] = "ConstrainedHigh";
    Profile[Profile["High"] = 5] = "High";
    Profile[Profile["PredictiveHigh444"] = 6] = "PredictiveHigh444";
})(Profile || (exports.Profile = Profile = {}));
/**
 * Supported levels.
 */
var Level;
(function (Level) {
    Level[Level["L1_b"] = 0] = "L1_b";
    Level[Level["L1"] = 10] = "L1";
    Level[Level["L1_1"] = 11] = "L1_1";
    Level[Level["L1_2"] = 12] = "L1_2";
    Level[Level["L1_3"] = 13] = "L1_3";
    Level[Level["L2"] = 20] = "L2";
    Level[Level["L2_1"] = 21] = "L2_1";
    Level[Level["L2_2"] = 22] = "L2_2";
    Level[Level["L3"] = 30] = "L3";
    Level[Level["L3_1"] = 31] = "L3_1";
    Level[Level["L3_2"] = 32] = "L3_2";
    Level[Level["L4"] = 40] = "L4";
    Level[Level["L4_1"] = 41] = "L4_1";
    Level[Level["L4_2"] = 42] = "L4_2";
    Level[Level["L5"] = 50] = "L5";
    Level[Level["L5_1"] = 51] = "L5_1";
    Level[Level["L5_2"] = 52] = "L5_2";
})(Level || (exports.Level = Level = {}));
/**
 * Represents a parsed h264 profile-level-id value.
 */
class ProfileLevelId {
    constructor(profile, level) {
        this.profile = profile;
        this.level = level;
    }
}
exports.ProfileLevelId = ProfileLevelId;
// Default ProfileLevelId.
//
// TODO: The default should really be profile Baseline and level 1 according to
// the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
// break backwards compatibility with older versions of WebRTC where external
// codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
// instead. This workaround will only be done in an interim period to allow
// external clients to update their code.
//
// http://crbug/webrtc/6337.
const DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
/**
 * Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to
 * be either 0 or 1.
 */
class BitPattern {
    constructor(str) {
        this.mask = ~byteMaskString('x', str);
        this.masked_value = byteMaskString('1', str);
    }
    isMatch(value) {
        return this.masked_value === (value & this.mask);
    }
}
/**
 * Class for converting between profile_idc/profile_iop to Profile.
 */
class ProfilePattern {
    constructor(profile_idc, profile_iop, profile) {
        this.profile_idc = profile_idc;
        this.profile_iop = profile_iop;
        this.profile = profile;
    }
}
// This is from https://tools.ietf.org/html/rfc6184#section-8.1.
const ProfilePatterns = [
    new ProfilePattern(0x42, new BitPattern('x1xx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x4d, new BitPattern('1xxx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x58, new BitPattern('11xx0000'), Profile.ConstrainedBaseline),
    new ProfilePattern(0x42, new BitPattern('x0xx0000'), Profile.Baseline),
    new ProfilePattern(0x58, new BitPattern('10xx0000'), Profile.Baseline),
    new ProfilePattern(0x4d, new BitPattern('0x0x0000'), Profile.Main),
    new ProfilePattern(0x64, new BitPattern('00000000'), Profile.High),
    new ProfilePattern(0x64, new BitPattern('00001100'), Profile.ConstrainedHigh),
    new ProfilePattern(0xf4, new BitPattern('00000000'), Profile.PredictiveHigh444),
];
// This is from ITU-T H.264 (02/2016) Table A-1 – Level limits.
const LevelConstraints = [
    {
        max_macroblocks_per_second: 1485,
        max_macroblock_frame_size: 99,
        level: Level.L1,
    },
    {
        max_macroblocks_per_second: 1485,
        max_macroblock_frame_size: 99,
        level: Level.L1_b,
    },
    {
        max_macroblocks_per_second: 3000,
        max_macroblock_frame_size: 396,
        level: Level.L1_1,
    },
    {
        max_macroblocks_per_second: 6000,
        max_macroblock_frame_size: 396,
        level: Level.L1_2,
    },
    {
        max_macroblocks_per_second: 11880,
        max_macroblock_frame_size: 396,
        level: Level.L1_3,
    },
    {
        max_macroblocks_per_second: 11880,
        max_macroblock_frame_size: 396,
        level: Level.L2,
    },
    {
        max_macroblocks_per_second: 19800,
        max_macroblock_frame_size: 792,
        level: Level.L2_1,
    },
    {
        max_macroblocks_per_second: 20250,
        max_macroblock_frame_size: 1620,
        level: Level.L2_2,
    },
    {
        max_macroblocks_per_second: 40500,
        max_macroblock_frame_size: 1620,
        level: Level.L3,
    },
    {
        max_macroblocks_per_second: 108000,
        max_macroblock_frame_size: 3600,
        level: Level.L3_1,
    },
    {
        max_macroblocks_per_second: 216000,
        max_macroblock_frame_size: 5120,
        level: Level.L3_2,
    },
    {
        max_macroblocks_per_second: 245760,
        max_macroblock_frame_size: 8192,
        level: Level.L4,
    },
    {
        max_macroblocks_per_second: 245760,
        max_macroblock_frame_size: 8192,
        level: Level.L4_1,
    },
    {
        max_macroblocks_per_second: 522240,
        max_macroblock_frame_size: 8704,
        level: Level.L4_2,
    },
    {
        max_macroblocks_per_second: 589824,
        max_macroblock_frame_size: 22080,
        level: Level.L5,
    },
    {
        max_macroblocks_per_second: 983040,
        max_macroblock_frame_size: 36864,
        level: Level.L5_1,
    },
    {
        max_macroblocks_per_second: 2073600,
        max_macroblock_frame_size: 36864,
        level: Level.L5_2,
    },
];
/**
 * Parse profile level id that is represented as a string of 3 hex bytes.
 * Nothing will be returned if the string is not a recognized H264 profile
 * level id.
 */
function parseProfileLevelId(str) {
    // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
    // flag specifies if level 1b or level 1.1 is used.
    const ConstraintSet3Flag = 0x10;
    // The string should consist of 3 bytes in hexadecimal format.
    if (typeof str !== 'string' || str.length !== 6) {
        return undefined;
    }
    const profile_level_id_numeric = parseInt(str, 16);
    if (profile_level_id_numeric === 0) {
        return undefined;
    }
    // Separate into three bytes.
    const level_idc = (profile_level_id_numeric & 0xff);
    const profile_iop = (profile_level_id_numeric >> 8) & 0xff;
    const profile_idc = (profile_level_id_numeric >> 16) & 0xff;
    // Parse level based on level_idc and constraint set 3 flag.
    let level;
    switch (level_idc) {
        case Level.L1_1: {
            level =
                (profile_iop & ConstraintSet3Flag) !== 0 ? Level.L1_b : Level.L1_1;
            break;
        }
        case Level.L1:
        case Level.L1_2:
        case Level.L1_3:
        case Level.L2:
        case Level.L2_1:
        case Level.L2_2:
        case Level.L3:
        case Level.L3_1:
        case Level.L3_2:
        case Level.L4:
        case Level.L4_1:
        case Level.L4_2:
        case Level.L5:
        case Level.L5_1:
        case Level.L5_2: {
            level = level_idc;
            break;
        }
        // Unrecognized level_idc.
        default: {
            logger.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
            return undefined;
        }
    }
    // Parse profile_idc/profile_iop into a Profile enum.
    for (const pattern of ProfilePatterns) {
        if (profile_idc === pattern.profile_idc &&
            pattern.profile_iop.isMatch(profile_iop)) {
            logger.debug(`parseProfileLevelId() | result [str:${str}, profile:${pattern.profile}, level:${level}]`);
            return new ProfileLevelId(pattern.profile, level);
        }
    }
    logger.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
    return undefined;
}
/**
 * Returns canonical string representation as three hex bytes of the profile
 * level id, or returns nothing for invalid profile level ids.
 */
function profileLevelIdToString(profile_level_id) {
    // Handle special case level == 1b.
    if (profile_level_id.level == Level.L1_b) {
        switch (profile_level_id.profile) {
            case Profile.ConstrainedBaseline: {
                return '42f00b';
            }
            case Profile.Baseline: {
                return '42100b';
            }
            case Profile.Main: {
                return '4d100b';
            }
            // Level 1_b is not allowed for other profiles.
            default: {
                logger.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
                return undefined;
            }
        }
    }
    let profile_idc_iop_string;
    switch (profile_level_id.profile) {
        case Profile.ConstrainedBaseline: {
            profile_idc_iop_string = '42e0';
            break;
        }
        case Profile.Baseline: {
            profile_idc_iop_string = '4200';
            break;
        }
        case Profile.Main: {
            profile_idc_iop_string = '4d00';
            break;
        }
        case Profile.ConstrainedHigh: {
            profile_idc_iop_string = '640c';
            break;
        }
        case Profile.High: {
            profile_idc_iop_string = '6400';
            break;
        }
        case Profile.PredictiveHigh444: {
            profile_idc_iop_string = 'f400';
            break;
        }
        default: {
            logger.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
            return undefined;
        }
    }
    let levelStr = profile_level_id.level.toString(16);
    if (levelStr.length === 1) {
        levelStr = `0${levelStr}`;
    }
    return `${profile_idc_iop_string}${levelStr}`;
}
/**
 * Returns a human friendly name for the given profile.
 */
function profileToString(profile) {
    switch (profile) {
        case Profile.ConstrainedBaseline: {
            return 'ConstrainedBaseline';
        }
        case Profile.Baseline: {
            return 'Baseline';
        }
        case Profile.Main: {
            return 'Main';
        }
        case Profile.ConstrainedHigh: {
            return 'ConstrainedHigh';
        }
        case Profile.High: {
            return 'High';
        }
        case Profile.PredictiveHigh444: {
            return 'PredictiveHigh444';
        }
        default: {
            logger.warn(`profileToString() | unrecognized profile ${profile}`);
            return undefined;
        }
    }
}
/**
 * Returns a human friendly name for the given level.
 */
function levelToString(level) {
    switch (level) {
        case Level.L1_b: {
            return '1b';
        }
        case Level.L1: {
            return '1';
        }
        case Level.L1_1: {
            return '1.1';
        }
        case Level.L1_2: {
            return '1.2';
        }
        case Level.L1_3: {
            return '1.3';
        }
        case Level.L2: {
            return '2';
        }
        case Level.L2_1: {
            return '2.1';
        }
        case Level.L2_2: {
            return '2.2';
        }
        case Level.L3: {
            return '3';
        }
        case Level.L3_1: {
            return '3.1';
        }
        case Level.L3_2: {
            return '3.2';
        }
        case Level.L4: {
            return '4';
        }
        case Level.L4_1: {
            return '4.1';
        }
        case Level.L4_2: {
            return '4.2';
        }
        case Level.L5: {
            return '5';
        }
        case Level.L5_1: {
            return '5.1';
        }
        case Level.L5_2: {
            return '5.2';
        }
        default: {
            logger.warn(`levelToString() | unrecognized level ${level}`);
            return undefined;
        }
    }
}
/**
 * Parse profile level id that is represented as a string of 3 hex bytes
 * contained in an SDP key-value map. A default profile level id will be
 * returned if the profile-level-id key is missing. Nothing will be returned
 * if the key is present but the string is invalid.
 */
function parseSdpProfileLevelId(params = {}) {
    const profile_level_id = params['profile-level-id'];
    return profile_level_id
        ? parseProfileLevelId(profile_level_id)
        : DefaultProfileLevelId;
}
/**
 * Returns true if the codec parameters have the same H264 profile, i.e. the
 * same H264 profile (Baseline, High, etc).
 */
function isSameProfile(params1 = {}, params2 = {}) {
    const profile_level_id_1 = parseSdpProfileLevelId(params1);
    const profile_level_id_2 = parseSdpProfileLevelId(params2);
    // Compare H264 profiles, but not levels.
    return Boolean(profile_level_id_1 &&
        profile_level_id_2 &&
        profile_level_id_1.profile === profile_level_id_2.profile);
}
/**
 * Returns true if the codec parameters have the same H264 profile, i.e. the
 * same H264 profile (Baseline, High, etc) and same level.
 */
function isSameProfileAndLevel(params1 = {}, params2 = {}) {
    const profile_level_id_1 = parseSdpProfileLevelId(params1);
    const profile_level_id_2 = parseSdpProfileLevelId(params2);
    // Compare H264 profiles, but not levels.
    return Boolean(profile_level_id_1 &&
        profile_level_id_2 &&
        profile_level_id_1.profile === profile_level_id_2.profile &&
        profile_level_id_1.level == profile_level_id_2.level);
}
/**
 * Generate codec parameters that will be used as answer in an SDP negotiation
 * based on local supported parameters and remote offered parameters. Both
 * local_supported_params and remote_offered_params represent sendrecv media
 * descriptions, i.e they are a mix of both encode and decode capabilities. In
 * theory, when the profile in local_supported_params represent a strict
 * superset of the profile in remote_offered_params, we could limit the profile
 * in the answer to the profile in remote_offered_params.
 *
 * However, to simplify the code, each supported H264 profile should be listed
 * explicitly in the list of local supported codecs, even if they are redundant.
 * Then each local codec in the list should be tested one at a time against the
 * remote codec, and only when the profiles are equal should this function be
 * called. Therefore, this function does not need to handle profile intersection,
 * and the profile of local_supported_params and remote_offered_params must be
 * equal before calling this function. The parameters that are used when
 * negotiating are the level part of profile-level-id and
 * level-asymmetry-allowed.
 */
function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
    // If both local and remote params do not contain profile-level-id, they are
    // both using the default profile. In this case, don't return anything.
    if (!local_supported_params['profile-level-id'] &&
        !remote_offered_params['profile-level-id']) {
        logger.warn('generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params');
        return undefined;
    }
    // Parse profile-level-ids.
    const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
    const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
    // The local and remote codec must have valid and equal H264 Profiles.
    if (!local_profile_level_id) {
        throw new TypeError('invalid local_profile_level_id');
    }
    if (!remote_profile_level_id) {
        throw new TypeError('invalid remote_profile_level_id');
    }
    if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
        throw new TypeError('H264 Profile mismatch');
    }
    // Parse level information.
    const level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) &&
        isLevelAsymmetryAllowed(remote_offered_params);
    const local_level = local_profile_level_id.level;
    const remote_level = remote_profile_level_id.level;
    const min_level = minLevel(local_level, remote_level);
    // Determine answer level. When level asymmetry is not allowed, level upgrade
    // is not allowed, i.e., the level in the answer must be equal to or lower
    // than the level in the offer.
    const answer_level = level_asymmetry_allowed ? local_level : min_level;
    logger.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
    // Return the resulting profile-level-id for the answer parameters.
    return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
}
/**
 * Given that a decoder supports up to a given frame size (in pixels) at up to
 * a given number of frames per second, return the highest H264 level where it
 * can guarantee that it will be able to support all valid encoded streams that
 * are within that level.
 */
function supportedLevel(max_frame_pixel_count, max_fps) {
    const PixelsPerMacroblock = 16 * 16;
    for (let i = LevelConstraints.length - 1; i >= 0; --i) {
        const level_constraint = LevelConstraints[i];
        if (level_constraint.max_macroblock_frame_size * PixelsPerMacroblock <=
            max_frame_pixel_count &&
            level_constraint.max_macroblocks_per_second <=
                max_fps * level_constraint.max_macroblock_frame_size) {
            logger.debug(`supportedLevel() | result [max_frame_pixel_count:${max_frame_pixel_count}, max_fps:${max_fps}, level:${level_constraint.level}]`);
            return level_constraint.level;
        }
    }
    // No level supported.
    logger.warn(`supportedLevel() | no level supported [max_frame_pixel_count:${max_frame_pixel_count}, max_fps:${max_fps}]`);
    return undefined;
}
/**
 * Convert a string of 8 characters into a byte where the positions containing
 * character c will have their bit set. For example, c = 'x', str = "x1xx0000"
 * will return 0b10110000.
 */
function byteMaskString(c, str) {
    return ((Number(str[0] === c) << 7) |
        (Number(str[1] === c) << 6) |
        (Number(str[2] === c) << 5) |
        (Number(str[3] === c) << 4) |
        (Number(str[4] === c) << 3) |
        (Number(str[5] === c) << 2) |
        (Number(str[6] === c) << 1) |
        (Number(str[7] === c) << 0));
}
// Compare H264 levels and handle the level 1b case.
function isLessLevel(a, b) {
    if (a === Level.L1_b) {
        return b !== Level.L1 && b !== Level.L1_b;
    }
    if (b === Level.L1_b) {
        return a !== Level.L1;
    }
    return a < b;
}
function minLevel(a, b) {
    return isLessLevel(a, b) ? a : b;
}
function isLevelAsymmetryAllowed(params = {}) {
    const level_asymmetry_allowed = params['level-asymmetry-allowed'];
    return (level_asymmetry_allowed === true ||
        level_asymmetry_allowed === 1 ||
        level_asymmetry_allowed === '1');
}


/***/ }),

/***/ 3240:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));

/***/ }),

/***/ 3303:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = parse;
const ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})');
function parse(scalabilityMode) {
    const match = ScalabilityModeRegex.exec(scalabilityMode ?? '');
    if (match) {
        return {
            spatialLayers: Number(match[1]),
            temporalLayers: Number(match[2]),
        };
    }
    else {
        return {
            spatialLayers: 1,
            temporalLayers: 1,
        };
    }
}


/***/ }),

/***/ 3471:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
const sdpTransform = __webpack_require__(7363);
const utils = __webpack_require__(1765);
class MediaSection {
    // SDP media object.
    _mediaObject;
    constructor({ iceParameters, iceCandidates, dtlsParameters, }) {
        this._mediaObject = {
            type: '',
            port: 0,
            protocol: '',
            payloads: '',
            rtp: [],
            fmtp: [],
        };
        if (iceParameters) {
            this.setIceParameters(iceParameters);
        }
        if (iceCandidates) {
            this._mediaObject.candidates = [];
            for (const candidate of iceCandidates) {
                const candidateObject = {
                    foundation: candidate.foundation,
                    // mediasoup does mandates rtcp-mux so candidates component is always
                    // RTP (1).
                    component: 1,
                    // Be ready for new candidate.address field in mediasoup server side
                    // field and keep backward compatibility with deprecated candidate.ip.
                    ip: candidate.address ?? candidate.ip,
                    port: candidate.port,
                    priority: candidate.priority,
                    transport: candidate.protocol,
                    type: candidate.type,
                };
                if (candidate.tcpType) {
                    candidateObject.tcptype = candidate.tcpType;
                }
                this._mediaObject.candidates.push(candidateObject);
            }
            this._mediaObject.endOfCandidates = 'end-of-candidates';
            this._mediaObject.iceOptions = 'renomination';
        }
        if (dtlsParameters) {
            this.setDtlsRole(dtlsParameters.role);
        }
    }
    get mid() {
        return String(this._mediaObject.mid);
    }
    get closed() {
        return this._mediaObject.port === 0;
    }
    getObject() {
        return this._mediaObject;
    }
    setIceParameters(iceParameters) {
        this._mediaObject.iceUfrag = iceParameters.usernameFragment;
        this._mediaObject.icePwd = iceParameters.password;
    }
    pause() {
        this._mediaObject.direction = 'inactive';
    }
    disable() {
        this.pause();
        delete this._mediaObject.ext;
        delete this._mediaObject.ssrcs;
        delete this._mediaObject.ssrcGroups;
        delete this._mediaObject.simulcast;
        delete this._mediaObject.simulcast_03;
        delete this._mediaObject.rids;
        delete this._mediaObject.extmapAllowMixed;
    }
    close() {
        this.disable();
        this._mediaObject.port = 0;
    }
}
exports.MediaSection = MediaSection;
class AnswerMediaSection extends MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, }) {
        super({ iceParameters, iceCandidates, dtlsParameters });
        this._mediaObject.mid = String(offerMediaObject.mid);
        this._mediaObject.type = offerMediaObject.type;
        this._mediaObject.protocol = offerMediaObject.protocol;
        if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
            this._mediaObject.port = 7;
        }
        else {
            this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion,
            };
            this._mediaObject.port = plainRtpParameters.port;
        }
        switch (offerMediaObject.type) {
            case 'audio':
            case 'video': {
                this._mediaObject.direction = 'recvonly';
                this._mediaObject.rtp = [];
                this._mediaObject.rtcpFb = [];
                this._mediaObject.fmtp = [];
                for (const codec of answerRtpParameters.codecs) {
                    const rtp = {
                        payload: codec.payloadType,
                        codec: getCodecName(codec),
                        rate: codec.clockRate,
                    };
                    if (codec.channels > 1) {
                        rtp.encoding = codec.channels;
                    }
                    this._mediaObject.rtp.push(rtp);
                    const codecParameters = utils.clone(codec.parameters) ?? {};
                    let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];
                    if (codecOptions) {
                        const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate, } = codecOptions;
                        const offerCodec = offerRtpParameters.codecs.find((c) => c.payloadType === codec.payloadType);
                        switch (codec.mimeType.toLowerCase()) {
                            case 'audio/opus':
                            case 'audio/multiopus': {
                                if (opusStereo !== undefined) {
                                    offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;
                                    codecParameters['stereo'] = opusStereo ? 1 : 0;
                                }
                                if (opusFec !== undefined) {
                                    offerCodec.parameters['useinbandfec'] = opusFec ? 1 : 0;
                                    codecParameters['useinbandfec'] = opusFec ? 1 : 0;
                                }
                                if (opusDtx !== undefined) {
                                    offerCodec.parameters['usedtx'] = opusDtx ? 1 : 0;
                                    codecParameters['usedtx'] = opusDtx ? 1 : 0;
                                }
                                if (opusMaxPlaybackRate !== undefined) {
                                    codecParameters['maxplaybackrate'] = opusMaxPlaybackRate;
                                }
                                if (opusMaxAverageBitrate !== undefined) {
                                    codecParameters['maxaveragebitrate'] = opusMaxAverageBitrate;
                                }
                                if (opusPtime !== undefined) {
                                    offerCodec.parameters['ptime'] = opusPtime;
                                    codecParameters['ptime'] = opusPtime;
                                }
                                // If opusNack is not set, we must remove NACK support for OPUS.
                                // Otherwise it would be enabled for those handlers that artificially
                                // announce it in their RTP capabilities.
                                if (!opusNack) {
                                    offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter(fb => fb.type !== 'nack' || fb.parameter);
                                    codecRtcpFeedback = codecRtcpFeedback.filter(fb => fb.type !== 'nack' || fb.parameter);
                                }
                                break;
                            }
                            case 'video/vp8':
                            case 'video/vp9':
                            case 'video/h264':
                            case 'video/h265':
                            case 'video/av1': {
                                if (videoGoogleStartBitrate !== undefined) {
                                    codecParameters['x-google-start-bitrate'] =
                                        videoGoogleStartBitrate;
                                }
                                if (videoGoogleMaxBitrate !== undefined) {
                                    codecParameters['x-google-max-bitrate'] =
                                        videoGoogleMaxBitrate;
                                }
                                if (videoGoogleMinBitrate !== undefined) {
                                    codecParameters['x-google-min-bitrate'] =
                                        videoGoogleMinBitrate;
                                }
                                break;
                            }
                        }
                    }
                    const fmtp = {
                        payload: codec.payloadType,
                        config: '',
                    };
                    for (const key of Object.keys(codecParameters)) {
                        if (fmtp.config) {
                            fmtp.config += ';';
                        }
                        fmtp.config += `${key}=${codecParameters[key]}`;
                    }
                    if (fmtp.config) {
                        this._mediaObject.fmtp.push(fmtp);
                    }
                    for (const fb of codecRtcpFeedback) {
                        this._mediaObject.rtcpFb.push({
                            payload: codec.payloadType,
                            type: fb.type,
                            subtype: fb.parameter,
                        });
                    }
                }
                this._mediaObject.payloads = answerRtpParameters.codecs
                    .map((codec) => codec.payloadType)
                    .join(' ');
                this._mediaObject.ext = [];
                for (const ext of answerRtpParameters.headerExtensions) {
                    // Don't add a header extension if not present in the offer.
                    const found = (offerMediaObject.ext ?? []).some((localExt) => localExt.uri === ext.uri);
                    if (!found) {
                        continue;
                    }
                    this._mediaObject.ext.push({
                        uri: ext.uri,
                        value: ext.id,
                    });
                }
                // Allow both 1 byte and 2 bytes length header extensions since
                // mediasoup can receive both at any time.
                if (offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {
                    this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
                }
                // Simulcast.
                if (offerMediaObject.simulcast) {
                    this._mediaObject.simulcast = {
                        dir1: 'recv',
                        list1: offerMediaObject.simulcast.list1,
                    };
                    this._mediaObject.rids = [];
                    for (const rid of offerMediaObject.rids ?? []) {
                        if (rid.direction !== 'send') {
                            continue;
                        }
                        this._mediaObject.rids.push({
                            id: rid.id,
                            direction: 'recv',
                        });
                    }
                }
                // Simulcast (draft version 03).
                else if (offerMediaObject.simulcast_03) {
                    this._mediaObject.simulcast_03 = {
                        value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv'),
                    };
                    this._mediaObject.rids = [];
                    for (const rid of offerMediaObject.rids ?? []) {
                        if (rid.direction !== 'send') {
                            continue;
                        }
                        this._mediaObject.rids.push({
                            id: rid.id,
                            direction: 'recv',
                        });
                    }
                }
                this._mediaObject.rtcpMux = 'rtcp-mux';
                this._mediaObject.rtcpRsize = 'rtcp-rsize';
                break;
            }
            case 'application': {
                // New spec.
                if (typeof offerMediaObject.sctpPort === 'number') {
                    this._mediaObject.payloads = 'webrtc-datachannel';
                    this._mediaObject.sctpPort = sctpParameters.port;
                    this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                }
                // Old spec.
                else if (offerMediaObject.sctpmap) {
                    this._mediaObject.payloads = String(sctpParameters.port);
                    this._mediaObject.sctpmap = {
                        app: 'webrtc-datachannel',
                        sctpmapNumber: sctpParameters.port,
                        maxMessageSize: sctpParameters.maxMessageSize,
                    };
                }
                break;
            }
        }
    }
    setDtlsRole(role) {
        switch (role) {
            case 'client': {
                this._mediaObject.setup = 'active';
                break;
            }
            case 'server': {
                this._mediaObject.setup = 'passive';
                break;
            }
            case 'auto': {
                this._mediaObject.setup = 'actpass';
                break;
            }
        }
    }
    resume() {
        this._mediaObject.direction = 'recvonly';
    }
    muxSimulcastStreams(encodings) {
        if (!this._mediaObject.simulcast?.list1) {
            return;
        }
        const layers = {};
        for (const encoding of encodings) {
            if (encoding.rid) {
                layers[encoding.rid] = encoding;
            }
        }
        const raw = this._mediaObject.simulcast.list1;
        const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
        for (const simulcastStream of simulcastStreams) {
            for (const simulcastFormat of simulcastStream) {
                simulcastFormat.paused = !layers[simulcastFormat.scid]?.active;
            }
        }
        this._mediaObject.simulcast.list1 = simulcastStreams
            .map(simulcastFormats => simulcastFormats.map(f => `${f.paused ? '~' : ''}${f.scid}`).join(','))
            .join(';');
    }
}
exports.AnswerMediaSection = AnswerMediaSection;
class OfferMediaSection extends MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, mid, kind, offerRtpParameters, streamId, trackId, }) {
        super({ iceParameters, iceCandidates, dtlsParameters });
        this._mediaObject.mid = String(mid);
        this._mediaObject.type = kind;
        if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
            if (!sctpParameters) {
                this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';
            }
            else {
                this._mediaObject.protocol = 'UDP/DTLS/SCTP';
            }
            this._mediaObject.port = 7;
        }
        else {
            this._mediaObject.connection = {
                ip: plainRtpParameters.ip,
                version: plainRtpParameters.ipVersion,
            };
            this._mediaObject.protocol = 'RTP/AVP';
            this._mediaObject.port = plainRtpParameters.port;
        }
        // Allow both 1 byte and 2 bytes length header extensions since
        // mediasoup can send both at any time.
        this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
        switch (kind) {
            case 'audio':
            case 'video': {
                this._mediaObject.direction = 'sendonly';
                this._mediaObject.rtp = [];
                this._mediaObject.rtcpFb = [];
                this._mediaObject.fmtp = [];
                this._mediaObject.msid = `${streamId ?? '-'} ${trackId}`;
                for (const codec of offerRtpParameters.codecs) {
                    const rtp = {
                        payload: codec.payloadType,
                        codec: getCodecName(codec),
                        rate: codec.clockRate,
                    };
                    if (codec.channels > 1) {
                        rtp.encoding = codec.channels;
                    }
                    this._mediaObject.rtp.push(rtp);
                    const fmtp = {
                        payload: codec.payloadType,
                        config: '',
                    };
                    for (const key of Object.keys(codec.parameters ?? {})) {
                        if (fmtp.config) {
                            fmtp.config += ';';
                        }
                        fmtp.config += `${key}=${codec.parameters[key]}`;
                    }
                    if (fmtp.config) {
                        this._mediaObject.fmtp.push(fmtp);
                    }
                    for (const fb of codec.rtcpFeedback) {
                        this._mediaObject.rtcpFb.push({
                            payload: codec.payloadType,
                            type: fb.type,
                            subtype: fb.parameter,
                        });
                    }
                }
                this._mediaObject.payloads = offerRtpParameters.codecs
                    .map((codec) => codec.payloadType)
                    .join(' ');
                this._mediaObject.ext = [];
                for (const ext of offerRtpParameters.headerExtensions) {
                    this._mediaObject.ext.push({
                        uri: ext.uri,
                        value: ext.id,
                    });
                }
                this._mediaObject.rtcpMux = 'rtcp-mux';
                this._mediaObject.rtcpRsize = 'rtcp-rsize';
                const encoding = offerRtpParameters.encodings[0];
                const ssrc = encoding.ssrc;
                const rtxSsrc = encoding.rtx?.ssrc;
                this._mediaObject.ssrcs = [];
                this._mediaObject.ssrcGroups = [];
                if (ssrc && offerRtpParameters.rtcp.cname) {
                    this._mediaObject.ssrcs.push({
                        id: ssrc,
                        attribute: 'cname',
                        value: offerRtpParameters.rtcp.cname,
                    });
                }
                if (rtxSsrc) {
                    if (offerRtpParameters.rtcp.cname) {
                        this._mediaObject.ssrcs.push({
                            id: rtxSsrc,
                            attribute: 'cname',
                            value: offerRtpParameters.rtcp.cname,
                        });
                    }
                    // Associate original and retransmission SSRCs.
                    if (ssrc) {
                        this._mediaObject.ssrcGroups.push({
                            semantics: 'FID',
                            ssrcs: `${ssrc} ${rtxSsrc}`,
                        });
                    }
                }
                break;
            }
            case 'application': {
                this._mediaObject.payloads = 'webrtc-datachannel';
                this._mediaObject.sctpPort = sctpParameters.port;
                this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                break;
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setDtlsRole(role) {
        // Always 'actpass'.
        this._mediaObject.setup = 'actpass';
    }
    resume() {
        this._mediaObject.direction = 'sendonly';
    }
}
exports.OfferMediaSection = OfferMediaSection;
function getCodecName(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    return mimeTypeMatch[2];
}


/***/ }),

/***/ 3518:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Consumer = void 0;
const Logger_1 = __webpack_require__(2994);
const enhancedEvents_1 = __webpack_require__(3953);
const errors_1 = __webpack_require__(4893);
const logger = new Logger_1.Logger('Consumer');
class Consumer extends enhancedEvents_1.EnhancedEventEmitter {
    // Id.
    _id;
    // Local id.
    _localId;
    // Associated Producer id.
    _producerId;
    // Closed flag.
    _closed = false;
    // Associated RTCRtpReceiver.
    _rtpReceiver;
    // Remote track.
    _track;
    // RTP parameters.
    _rtpParameters;
    // Paused flag.
    _paused;
    // App custom data.
    _appData;
    // Observer instance.
    _observer = new enhancedEvents_1.EnhancedEventEmitter();
    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData, }) {
        super();
        logger.debug('constructor()');
        this._id = id;
        this._localId = localId;
        this._producerId = producerId;
        this._rtpReceiver = rtpReceiver;
        this._track = track;
        this._rtpParameters = rtpParameters;
        this._paused = !track.enabled;
        this._appData = appData ?? {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        this.handleTrack();
    }
    /**
     * Consumer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
        return this._localId;
    }
    /**
     * Associated Producer id.
     */
    get producerId() {
        return this._producerId;
    }
    /**
     * Whether the Consumer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this._track.kind;
    }
    /**
     * Associated RTCRtpReceiver.
     */
    get rtpReceiver() {
        return this._rtpReceiver;
    }
    /**
     * The associated track.
     */
    get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Consumer is paused.
     */
    get paused() {
        return this._paused;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Consumer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this.destroyTrack();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
        this._observer.close();
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this.destroyTrack();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */
    async getStats() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        return new Promise((resolve, reject) => {
            this.safeEmit('@getstats', resolve, reject);
        });
    }
    /**
     * Pauses receiving media.
     */
    pause() {
        logger.debug('pause()');
        if (this._closed) {
            logger.error('pause() | Consumer closed');
            return;
        }
        if (this._paused) {
            logger.debug('pause() | Consumer is already paused');
            return;
        }
        this._paused = true;
        this._track.enabled = false;
        this.emit('@pause');
        // Emit observer event.
        this._observer.safeEmit('pause');
    }
    /**
     * Resumes receiving media.
     */
    resume() {
        logger.debug('resume()');
        if (this._closed) {
            logger.error('resume() | Consumer closed');
            return;
        }
        if (!this._paused) {
            logger.debug('resume() | Consumer is already resumed');
            return;
        }
        this._paused = false;
        this._track.enabled = true;
        this.emit('@resume');
        // Emit observer event.
        this._observer.safeEmit('resume');
    }
    onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit('trackended');
        // Emit observer event.
        this._observer.safeEmit('trackended');
    }
    handleTrack() {
        this._track.addEventListener('ended', this.onTrackEnded);
    }
    destroyTrack() {
        try {
            this._track.removeEventListener('ended', this.onTrackEnded);
            this._track.stop();
        }
        catch (error) { }
    }
}
exports.Consumer = Consumer;


/***/ }),

/***/ 3582:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const debug_1 = __importDefault(__webpack_require__(7833));
const APP_NAME = 'h264-profile-level-id';
class Logger {
    constructor(prefix) {
        if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;


/***/ }),

/***/ 3662:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _setPrototypeOf)
/* harmony export */ });
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}


/***/ }),

/***/ 3738:
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 3785:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clone = clone;
/**
 * Clones the given value.
 */
function clone(value) {
    if (value === undefined) {
        return undefined;
    }
    else if (Number.isNaN(value)) {
        return NaN;
    }
    else if (typeof structuredClone === 'function') {
        // Available in Node >= 18.
        return structuredClone(value);
    }
    else {
        return JSON.parse(JSON.stringify(value));
    }
}


/***/ }),

/***/ 3797:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));

/***/ }),

/***/ 3804:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var grammar = __webpack_require__(5602);

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
    case '%%':
      return '%';
    case '%s':
      return String(arg);
    case '%d':
      return Number(arg);
    case '%v':
      return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // 'v=0' must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = ' '; // 's= ' must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = '';
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session && session[obj.name] != null) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session && session[obj.push] != null) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine && mLine[obj.name] != null) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine && mLine[obj.push] != null) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};


/***/ }),

/***/ 3953:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnhancedEventEmitter = void 0;
const events_alias_1 = __webpack_require__(5528);
const Logger_1 = __webpack_require__(2994);
const enhancedEventEmitterLogger = new Logger_1.Logger('EnhancedEventEmitter');
class EnhancedEventEmitter extends events_alias_1.EventEmitter {
    constructor() {
        super();
        this.setMaxListeners(Infinity);
    }
    /**
     * Empties all stored event listeners.
     */
    close() {
        super.removeAllListeners();
    }
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * Special addition to the EventEmitter API.
     */
    safeEmit(eventName, ...args) {
        try {
            return super.emit(eventName, ...args);
        }
        catch (error) {
            enhancedEventEmitterLogger.error('safeEmit() | event listener threw an error [eventName:%s]:%o', eventName, error);
            try {
                super.emit('listenererror', eventName, error);
            }
            catch (error2) {
                // Ignore it.
            }
            return Boolean(super.listenerCount(eventName));
        }
    }
    on(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    off(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    addListener(eventName, listener) {
        super.on(eventName, listener);
        return this;
    }
    prependListener(eventName, listener) {
        super.prependListener(eventName, listener);
        return this;
    }
    once(eventName, listener) {
        super.once(eventName, listener);
        return this;
    }
    prependOnceListener(eventName, listener) {
        super.prependOnceListener(eventName, listener);
        return this;
    }
    removeListener(eventName, listener) {
        super.off(eventName, listener);
        return this;
    }
    removeAllListeners(eventName) {
        super.removeAllListeners(eventName);
        return this;
    }
    listenerCount(eventName) {
        return super.listenerCount(eventName);
    }
    listeners(eventName) {
        return super.listeners(eventName);
    }
    rawListeners(eventName) {
        return super.rawListeners(eventName);
    }
}
exports.EnhancedEventEmitter = EnhancedEventEmitter;


/***/ }),

/***/ 3954:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _getPrototypeOf)
/* harmony export */ });
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}


/***/ }),

/***/ 4253:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
/**
 * Custom Error derived class used to reject pending tasks once stop() method
 * has been called.
 */
class AwaitQueueStoppedError extends Error {
    constructor(message) {
        super(message ?? 'queue stopped');
        this.name = 'AwaitQueueStoppedError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AwaitQueueStoppedError);
        }
    }
}
exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
/**
 * Custom Error derived class used to reject pending tasks once removeTask()
 * method has been called.
 */
class AwaitQueueRemovedTaskError extends Error {
    constructor(message) {
        super(message ?? 'queue task removed');
        this.name = 'AwaitQueueRemovedTaskError';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, AwaitQueueRemovedTaskError);
        }
    }
}
exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;


/***/ }),

/***/ 4256:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addNackSupportForOpus = addNackSupportForOpus;
/**
 * This function adds RTCP NACK support for OPUS codec in given capabilities.
 */
function addNackSupportForOpus(rtpCapabilities) {
    for (const codec of rtpCapabilities.codecs ?? []) {
        if ((codec.mimeType.toLowerCase() === 'audio/opus' ||
            codec.mimeType.toLowerCase() === 'audio/multiopus') &&
            !codec.rtcpFeedback?.some(fb => fb.type === 'nack' && !fb.parameter)) {
            if (!codec.rtcpFeedback) {
                codec.rtcpFeedback = [];
            }
            codec.rtcpFeedback.push({ type: 'nack' });
        }
    }
}


/***/ }),

/***/ 4373:
/***/ ((module) => {

function _regeneratorKeys(e) {
  var n = Object(e),
    r = [];
  for (var t in n) r.unshift(t);
  return function e() {
    for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = !1, e;
    return e.done = !0, e;
  };
}
module.exports = _regeneratorKeys, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 4467:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _defineProperty)
/* harmony export */ });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(816);

function _defineProperty(e, r, t) {
  return (r = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}


/***/ }),

/***/ 4633:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var OverloadYield = __webpack_require__(5172);
var regenerator = __webpack_require__(6993);
var regeneratorAsync = __webpack_require__(5869);
var regeneratorAsyncGen = __webpack_require__(887);
var regeneratorAsyncIterator = __webpack_require__(1791);
var regeneratorKeys = __webpack_require__(4373);
var regeneratorValues = __webpack_require__(579);
function _regeneratorRuntime() {
  "use strict";

  var r = regenerator(),
    e = r.m(_regeneratorRuntime),
    t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
  function n(r) {
    var e = "function" == typeof r && r.constructor;
    return !!e && (e === t || "GeneratorFunction" === (e.displayName || e.name));
  }
  var o = {
    "throw": 1,
    "return": 2,
    "break": 3,
    "continue": 3
  };
  function a(r) {
    var e, t;
    return function (n) {
      e || (e = {
        stop: function stop() {
          return t(n.a, 2);
        },
        "catch": function _catch() {
          return n.v;
        },
        abrupt: function abrupt(r, e) {
          return t(n.a, o[r], e);
        },
        delegateYield: function delegateYield(r, o, a) {
          return e.resultName = o, t(n.d, regeneratorValues(r), a);
        },
        finish: function finish(r) {
          return t(n.f, r);
        }
      }, t = function t(r, _t, o) {
        n.p = e.prev, n.n = e.next;
        try {
          return r(_t, o);
        } finally {
          e.next = n.n;
        }
      }), e.resultName && (e[e.resultName] = n.v, e.resultName = void 0), e.sent = n.v, e.next = n.n;
      try {
        return r.call(this, e);
      } finally {
        n.p = e.prev, n.n = e.next;
      }
    };
  }
  return (module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return {
      wrap: function wrap(e, t, n, o) {
        return r.w(a(e), t, n, o && o.reverse());
      },
      isGeneratorFunction: n,
      mark: r.m,
      awrap: function awrap(r, e) {
        return new OverloadYield(r, e);
      },
      AsyncIterator: regeneratorAsyncIterator,
      async: function async(r, e, t, o, u) {
        return (n(e) ? regeneratorAsyncGen : regeneratorAsync)(a(r), e, t, o, u);
      },
      keys: regeneratorKeys,
      values: regeneratorValues
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 4636:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ 4725:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64url encoding strategy.
	     */
	    var Base64url = C_enc.Base64url = {
	        /**
	         * Converts a word array to a Base64url string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @param {boolean} urlSafe Whether to use url safe
	         *
	         * @return {string} The Base64url string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
	         */
	        stringify: function (wordArray, urlSafe) {
	            if (urlSafe === undefined) {
	                urlSafe = true
	            }
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = urlSafe ? this._safe_map : this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64url string to a word array.
	         *
	         * @param {string} base64Str The Base64url string.
	         *
	         * @param {boolean} urlSafe Whether to use url safe
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
	         */
	        parse: function (base64Str, urlSafe) {
	            if (urlSafe === undefined) {
	                urlSafe = true
	            }

	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = urlSafe ? this._safe_map : this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                reverseMap = this._reverseMap = [];
	                for (var j = 0; j < map.length; j++) {
	                    reverseMap[map.charCodeAt(j)] = j;
	                }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
	        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	        var words = [];
	        var nBytes = 0;
	        for (var i = 0; i < base64StrLength; i++) {
	            if (i % 4) {
	                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	                var bitsCombined = bits1 | bits2;
	                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	                nBytes++;
	            }
	        }
	        return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64url;

}));

/***/ }),

/***/ 4756:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(4633)();
module.exports = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ 4893:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidStateError = exports.UnsupportedError = void 0;
/**
 * Error indicating not support for something.
 */
class UnsupportedError extends Error {
    constructor(message) {
        super(message);
        this.name = 'UnsupportedError';
        if (Error.hasOwnProperty('captureStackTrace')) {
            Error.captureStackTrace(this, UnsupportedError);
        }
        else {
            this.stack = new Error(message).stack;
        }
    }
}
exports.UnsupportedError = UnsupportedError;
/**
 * Error produced when calling a method in an invalid state.
 */
class InvalidStateError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InvalidStateError';
        if (Error.hasOwnProperty('captureStackTrace')) {
            // Just in V8.
            Error.captureStackTrace(this, InvalidStateError);
        }
        else {
            this.stack = new Error(message).stack;
        }
    }
}
exports.InvalidStateError = InvalidStateError;


/***/ }),

/***/ 4905:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));

/***/ }),

/***/ 4973:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Zu: () => (/* binding */ getNavigatorDisplayMediaDevices),
/* harmony export */   lp: () => (/* binding */ getNavigatorMediaDevices)
/* harmony export */ });
/* unused harmony exports getAspectRatio, presetsForResolution */
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(467);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4756);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9027);


/**
 * Get media devices from the constraints defined
 * @returns
 */


var getNavigatorMediaDevices = /*#__PURE__*/function () {
  var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(constraints) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function (_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (navigator.mediaDevices === undefined) {
            navigator.mediaDevices = {};
          }

          // Some browsers partially implement mediaDevices. We can't just assign an object
          // with getUserMedia as it would overwrite existing properties.
          // Here, we will just add the getUserMedia property if it's missing.
          if (navigator.mediaDevices.getUserMedia === undefined) {
            navigator.mediaDevices.getUserMedia = function (constraints) {
              // First get ahold of the legacy getUserMedia, if present
              var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

              // Some browsers just don't implement it - return a rejected promise with an error
              // to keep a consistent interface
              if (!getUserMedia) {
                return Promise.reject(new Error("getUserMedia is not implemented in this browser"));
              }

              // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise
              return new Promise(function (resolve, reject) {
                getUserMedia.call(navigator, constraints, resolve, reject);
              });
            };
          }
          _context.next = 1;
          return navigator.mediaDevices.getUserMedia(constraints);
        case 1:
          return _context.abrupt("return", _context.sent);
        case 2:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getNavigatorMediaDevices(_x) {
    return _ref.apply(this, arguments);
  };
}();

/**
 *
 * Get display media devices
 * @returns
 */
var getNavigatorDisplayMediaDevices = /*#__PURE__*/function () {
  var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(constraints) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function (_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (navigator.mediaDevices === undefined) {
            navigator.mediaDevices = {};
          }

          // Some browsers partially implement mediaDevices. We can't just assign an object
          // with getUserMedia as it would overwrite existing properties.
          // Here, we will just add the getUserMedia property if it's missing.
          if (navigator.mediaDevices.getDisplayMedia === undefined) {
            navigator.mediaDevices.getDisplayMedia = function (constraints) {
              // First get ahold of the legacy getUserMedia, if present
              var getDisplayMedia = navigator.webkitGetDisplayMedia || navigator.mozGetDisplayMedia;

              // Some browsers just don't implement it - return a rejected promise with an error
              // to keep a consistent interface
              if (!getDisplayMedia) {
                return Promise.reject(new Error("getDisplayMedia is not implemented in this browser"));
              }

              // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise
              return new Promise(function (resolve, reject) {
                getDisplayMedia.call(navigator, constraints, resolve, reject);
              });
            };
          }
          _context2.next = 1;
          return navigator.mediaDevices.getDisplayMedia(constraints);
        case 1:
          return _context2.abrupt("return", _context2.sent);
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function getNavigatorDisplayMediaDevices(_x2) {
    return _ref2.apply(this, arguments);
  };
}();
function getAspectRatio(width, height) {
  var aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {
    return config.aspectRatios.oneSixNine;
  }
  return config.aspectRatios.fourThree;
}
function presetsForResolution(isScreenShare, width, height) {
  if (isScreenShare) {
    return presetsScreenShare;
  }
  var aspect = width > height ? width / height : height / width;
  if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {
    return presets169;
  }
  return presets43;
}

/***/ }),

/***/ 5020:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = __webpack_require__(5602);
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var paramReducer = function (acc, expr) {
  var s = expr.split(/=(.+)/, 2);
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  } else if (s.length === 1 && expr.length > 1) {
    acc[s[0]] = undefined;
  }
  return acc;
};

exports.parseParams = function (str) {
  return str.split(/;\s?/).reduce(paramReducer, {});
};

// For backward compatibility - alias will be removed in 3.0.0
exports.parseFmtpConfig = exports.parseParams;

exports.parsePayloads = function (str) {
  return str.toString().split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

exports.parseImageAttributes = function (str) {
  return str.split(' ').map(function (item) {
    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  });
};

exports.parseSimulcastStreamList = function (str) {
  return str.split(';').map(function (stream) {
    return stream.split(',').map(function (format) {
      var scid, paused = false;

      if (format[0] !== '~') {
        scid = toIntIfInt(format);
      } else {
        scid = toIntIfInt(format.substring(1, format.length));
        paused = true;
      }

      return {
        scid: scid,
        paused: paused
      };
    });
  });
};


/***/ }),

/***/ 5071:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ hlsEvents)
/* harmony export */ });
var hlsEvents = {
  HLS_STARTING: "HLS_STARTING",
  HLS_STARTED: "HLS_STARTED",
  HLS_PLAYABLE: "HLS_PLAYABLE",
  HLS_STOPPING: "HLS_STOPPING",
  HLS_STOPPED: "HLS_STOPPED"
};

/***/ }),

/***/ 5172:
/***/ ((module) => {

function _OverloadYield(e, d) {
  this.v = e, this.k = d;
}
module.exports = _OverloadYield, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 5248:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
__webpack_unused_export__ = generateRouterRtpCapabilities;
__webpack_unused_export__ = generateNativeRtpCapabilities;
__webpack_unused_export__ = generateNativeSctpCapabilities;
__webpack_unused_export__ = generateLocalDtlsParameters;
__webpack_unused_export__ = generateTransportRemoteParameters;
__webpack_unused_export__ = generateProducerRemoteParameters;
__webpack_unused_export__ = generateConsumerRemoteParameters;
__webpack_unused_export__ = generateDataProducerRemoteParameters;
__webpack_unused_export__ = generateDataConsumerRemoteParameters;
const utils = __webpack_require__(1765);
function generateFakeUuid() {
    return String(utils.generateRandomNumber());
}
function generateRouterRtpCapabilities() {
    return utils.deepFreeze({
        codecs: [
            {
                mimeType: 'audio/opus',
                kind: 'audio',
                preferredPayloadType: 100,
                clockRate: 48000,
                channels: 2,
                rtcpFeedback: [{ type: 'transport-cc' }],
                parameters: {
                    useinbandfec: 1,
                    foo: 'bar',
                },
            },
            {
                mimeType: 'video/VP8',
                kind: 'video',
                preferredPayloadType: 101,
                clockRate: 90000,
                rtcpFeedback: [
                    { type: 'nack' },
                    { type: 'nack', parameter: 'pli' },
                    { type: 'ccm', parameter: 'fir' },
                    { type: 'goog-remb' },
                    { type: 'transport-cc' },
                ],
                parameters: {
                    'x-google-start-bitrate': 1500,
                },
            },
            {
                mimeType: 'video/rtx',
                kind: 'video',
                preferredPayloadType: 102,
                clockRate: 90000,
                rtcpFeedback: [],
                parameters: {
                    apt: 101,
                },
            },
            {
                mimeType: 'video/H264',
                kind: 'video',
                preferredPayloadType: 103,
                clockRate: 90000,
                rtcpFeedback: [
                    { type: 'nack' },
                    { type: 'nack', parameter: 'pli' },
                    { type: 'ccm', parameter: 'fir' },
                    { type: 'goog-remb' },
                    { type: 'transport-cc' },
                ],
                parameters: {
                    'level-asymmetry-allowed': 1,
                    'packetization-mode': 1,
                    'profile-level-id': '42e01f',
                },
            },
            {
                mimeType: 'video/rtx',
                kind: 'video',
                preferredPayloadType: 104,
                clockRate: 90000,
                rtcpFeedback: [],
                parameters: {
                    apt: 103,
                },
            },
            {
                mimeType: 'video/VP9',
                kind: 'video',
                preferredPayloadType: 105,
                clockRate: 90000,
                rtcpFeedback: [
                    { type: 'nack' },
                    { type: 'nack', parameter: 'pli' },
                    { type: 'ccm', parameter: 'fir' },
                    { type: 'goog-remb' },
                    { type: 'transport-cc' },
                ],
                parameters: {
                    'profile-id': 0,
                    'x-google-start-bitrate': 1500,
                },
            },
            {
                mimeType: 'video/rtx',
                kind: 'video',
                preferredPayloadType: 106,
                clockRate: 90000,
                rtcpFeedback: [],
                parameters: {
                    apt: 105,
                },
            },
        ],
        headerExtensions: [
            {
                kind: 'audio',
                uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
                preferredId: 1,
                preferredEncrypt: false,
                direction: 'sendrecv',
            },
            {
                kind: 'video',
                uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
                preferredId: 1,
                preferredEncrypt: false,
                direction: 'sendrecv',
            },
            {
                kind: 'video',
                uri: 'urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id',
                preferredId: 2,
                preferredEncrypt: false,
                direction: 'recvonly',
            },
            {
                kind: 'video',
                uri: 'urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id',
                preferredId: 3,
                preferredEncrypt: false,
                direction: 'recvonly',
            },
            {
                kind: 'audio',
                uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
                preferredId: 4,
                preferredEncrypt: false,
                direction: 'sendrecv',
            },
            {
                kind: 'video',
                uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
                preferredId: 4,
                preferredEncrypt: false,
                direction: 'sendrecv',
            },
            {
                kind: 'audio',
                uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
                preferredId: 5,
                preferredEncrypt: false,
                direction: 'recvonly',
            },
            {
                kind: 'video',
                uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
                preferredId: 5,
                preferredEncrypt: false,
                direction: 'sendrecv',
            },
            {
                kind: 'audio',
                uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
                preferredId: 10,
                preferredEncrypt: false,
                direction: 'sendrecv',
            },
            {
                kind: 'video',
                uri: 'urn:3gpp:video-orientation',
                preferredId: 11,
                preferredEncrypt: false,
                direction: 'sendrecv',
            },
            {
                kind: 'video',
                uri: 'urn:ietf:params:rtp-hdrext:toffset',
                preferredId: 12,
                preferredEncrypt: false,
                direction: 'sendrecv',
            },
        ],
    });
}
// NOTE: We don't freeze these RTP capabilities because we do need to normalize
// them as we do in real browser handlers (this is an object supposed to be
// generated internally so it's ok).
function generateNativeRtpCapabilities() {
    return {
        codecs: [
            {
                mimeType: 'audio/opus',
                kind: 'audio',
                preferredPayloadType: 111,
                clockRate: 48000,
                channels: 2,
                rtcpFeedback: [{ type: 'transport-cc' }],
                parameters: {
                    minptime: 10,
                    useinbandfec: 1,
                },
            },
            {
                mimeType: 'audio/ISAC',
                kind: 'audio',
                preferredPayloadType: 103,
                clockRate: 16000,
                channels: 1,
                rtcpFeedback: [{ type: 'transport-cc' }],
                parameters: {},
            },
            {
                mimeType: 'audio/CN',
                kind: 'audio',
                preferredPayloadType: 106,
                clockRate: 32000,
                channels: 1,
                rtcpFeedback: [{ type: 'transport-cc' }],
                parameters: {},
            },
            {
                mimeType: 'audio/foo',
                kind: 'audio',
                preferredPayloadType: 107,
                clockRate: 90000,
                channels: 4,
                rtcpFeedback: [{ type: 'foo-qwe-qwe' }],
                parameters: {
                    foo: 'lalala',
                },
            },
            {
                mimeType: 'video/BAZCODEC',
                kind: 'video',
                preferredPayloadType: 100,
                clockRate: 90000,
                rtcpFeedback: [
                    { type: 'foo' },
                    { type: 'transport-cc' },
                    { type: 'ccm', parameter: 'fir' },
                    { type: 'nack' },
                    { type: 'nack', parameter: 'pli' },
                ],
                parameters: {
                    baz: '1234abcd',
                },
            },
            {
                mimeType: 'video/rtx',
                kind: 'video',
                preferredPayloadType: 101,
                clockRate: 90000,
                rtcpFeedback: [],
                parameters: {
                    apt: 100,
                },
            },
            {
                mimeType: 'video/VP8',
                kind: 'video',
                preferredPayloadType: 96,
                clockRate: 90000,
                rtcpFeedback: [
                    { type: 'goog-remb' },
                    { type: 'transport-cc' },
                    { type: 'ccm', parameter: 'fir' },
                    { type: 'nack' },
                    { type: 'nack', parameter: 'pli' },
                ],
                parameters: {
                    baz: '1234abcd',
                },
            },
            {
                mimeType: 'video/rtx',
                kind: 'video',
                preferredPayloadType: 97,
                clockRate: 90000,
                rtcpFeedback: [],
                parameters: {
                    apt: 96,
                },
            },
            {
                mimeType: 'video/VP9',
                kind: 'video',
                preferredPayloadType: 98,
                clockRate: 90000,
                rtcpFeedback: [
                    { type: 'goog-remb' },
                    { type: 'transport-cc' },
                    { type: 'ccm', parameter: 'fir' },
                    { type: 'nack' },
                    { type: 'nack', parameter: 'pli' },
                ],
                parameters: {
                    'profile-id': 0,
                },
            },
            {
                mimeType: 'video/rtx',
                kind: 'video',
                preferredPayloadType: 99,
                clockRate: 90000,
                rtcpFeedback: [],
                parameters: {
                    apt: 98,
                },
            },
        ],
        headerExtensions: [
            {
                kind: 'audio',
                uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
                preferredId: 1,
            },
            {
                kind: 'video',
                uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
                preferredId: 1,
            },
            {
                kind: 'video',
                uri: 'urn:ietf:params:rtp-hdrext:toffset',
                preferredId: 2,
            },
            {
                kind: 'video',
                uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
                preferredId: 3,
            },
            {
                kind: 'video',
                uri: 'urn:3gpp:video-orientation',
                preferredId: 4,
            },
            {
                kind: 'video',
                uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
                preferredId: 5,
            },
            {
                kind: 'video',
                uri: 'http://www.webrtc.org/experiments/rtp-hdrext/playout-delay',
                preferredId: 6,
            },
            {
                kind: 'video',
                // @ts-expect-error --- ON purpose.
                uri: 'http://www.webrtc.org/experiments/rtp-hdrext/video-content-type',
                preferredId: 7,
            },
            {
                kind: 'video',
                // @ts-expect-error --- ON purpose.
                uri: 'http://www.webrtc.org/experiments/rtp-hdrext/video-timing',
                preferredId: 8,
            },
            {
                kind: 'audio',
                uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
                preferredId: 10,
            },
        ],
    };
}
function generateNativeSctpCapabilities() {
    return utils.deepFreeze({
        numStreams: { OS: 2048, MIS: 2048 },
    });
}
function generateLocalDtlsParameters() {
    return utils.deepFreeze({
        fingerprints: [
            {
                algorithm: 'sha-256',
                value: '82:5A:68:3D:36:C3:0A:DE:AF:E7:32:43:D2:88:83:57:AC:2D:65:E5:80:C4:B6:FB:AF:1A:A0:21:9F:6D:0C:AD',
            },
        ],
        role: 'auto',
    });
}
function generateTransportRemoteParameters() {
    return {
        id: generateFakeUuid(),
        iceParameters: utils.deepFreeze({
            iceLite: true,
            password: 'yku5ej8nvfaor28lvtrabcx0wkrpkztz',
            usernameFragment: 'h3hk1iz6qqlnqlne',
        }),
        iceCandidates: utils.deepFreeze([
            {
                foundation: 'udpcandidate',
                address: '9.9.9.9',
                ip: '9.9.9.9',
                port: 40533,
                priority: 1078862079,
                protocol: 'udp',
                type: 'host',
                tcpType: 'passive',
            },
            {
                foundation: 'udpcandidate',
                address: '9.9.9.9',
                ip: '9:9:9:9:9:9',
                port: 41333,
                priority: 1078862089,
                protocol: 'udp',
                type: 'host',
                tcpType: 'passive',
            },
        ]),
        dtlsParameters: utils.deepFreeze({
            fingerprints: [
                {
                    algorithm: 'sha-256',
                    value: 'A9:F4:E0:D2:74:D3:0F:D9:CA:A5:2F:9F:7F:47:FA:F0:C4:72:DD:73:49:D0:3B:14:90:20:51:30:1B:90:8E:71',
                },
                {
                    algorithm: 'sha-384',
                    value: '03:D9:0B:87:13:98:F6:6D:BC:FC:92:2E:39:D4:E1:97:32:61:30:56:84:70:81:6E:D1:82:97:EA:D9:C1:21:0F:6B:C5:E7:7F:E1:97:0C:17:97:6E:CF:B3:EF:2E:74:B0',
                },
                {
                    algorithm: 'sha-512',
                    value: '84:27:A4:28:A4:73:AF:43:02:2A:44:68:FF:2F:29:5C:3B:11:9A:60:F4:A8:F0:F5:AC:A0:E3:49:3E:B1:34:53:A9:85:CE:51:9B:ED:87:5E:B8:F4:8E:3D:FA:20:51:B8:96:EE:DA:56:DC:2F:5C:62:79:15:23:E0:21:82:2B:2C',
                },
            ],
            role: 'auto',
        }),
        sctpParameters: utils.deepFreeze({
            port: 5000,
            OS: 2048,
            MIS: 2048,
            maxMessageSize: 2000000,
        }),
    };
}
function generateProducerRemoteParameters() {
    return utils.deepFreeze({
        id: generateFakeUuid(),
    });
}
function generateConsumerRemoteParameters({ id, codecMimeType, } = {}) {
    switch (codecMimeType) {
        case 'audio/opus': {
            return {
                id: id ?? generateFakeUuid(),
                producerId: generateFakeUuid(),
                kind: 'audio',
                rtpParameters: utils.deepFreeze({
                    codecs: [
                        {
                            mimeType: 'audio/opus',
                            payloadType: 100,
                            clockRate: 48000,
                            channels: 2,
                            rtcpFeedback: [{ type: 'transport-cc' }],
                            parameters: {
                                useinbandfec: 1,
                                foo: 'bar',
                            },
                        },
                    ],
                    encodings: [
                        {
                            ssrc: 46687003,
                        },
                    ],
                    headerExtensions: [
                        {
                            uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
                            id: 1,
                        },
                        {
                            uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
                            id: 5,
                        },
                        {
                            uri: 'urn:ietf:params:rtp-hdrext:ssrc-audio-level',
                            id: 10,
                        },
                    ],
                    rtcp: {
                        cname: 'wB4Ql4lrsxYLjzuN',
                        reducedSize: true,
                        mux: true,
                    },
                }),
            };
        }
        case 'audio/ISAC': {
            return {
                id: id ?? generateFakeUuid(),
                producerId: generateFakeUuid(),
                kind: 'audio',
                rtpParameters: utils.deepFreeze({
                    codecs: [
                        {
                            mimeType: 'audio/ISAC',
                            payloadType: 111,
                            clockRate: 16000,
                            channels: 1,
                            rtcpFeedback: [{ type: 'transport-cc' }],
                            parameters: {},
                        },
                    ],
                    encodings: [
                        {
                            ssrc: 46687004,
                        },
                    ],
                    headerExtensions: [
                        {
                            uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
                            id: 1,
                        },
                        {
                            uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
                            id: 5,
                        },
                    ],
                    rtcp: {
                        cname: 'wB4Ql4lrsxYLjzuN',
                        reducedSize: true,
                        mux: true,
                    },
                }),
            };
        }
        case 'video/VP8': {
            return {
                id: id ?? generateFakeUuid(),
                producerId: generateFakeUuid(),
                kind: 'video',
                rtpParameters: utils.deepFreeze({
                    codecs: [
                        {
                            mimeType: 'video/VP8',
                            payloadType: 101,
                            clockRate: 90000,
                            rtcpFeedback: [
                                { type: 'nack' },
                                { type: 'nack', parameter: 'pli' },
                                { type: 'ccm', parameter: 'fir' },
                                { type: 'goog-remb' },
                                { type: 'transport-cc' },
                            ],
                            parameters: {
                                'x-google-start-bitrate': 1500,
                            },
                        },
                        {
                            mimeType: 'video/rtx',
                            payloadType: 102,
                            clockRate: 90000,
                            rtcpFeedback: [],
                            parameters: {
                                apt: 101,
                            },
                        },
                    ],
                    encodings: [
                        {
                            ssrc: 99991111,
                            rtx: {
                                ssrc: 99991112,
                            },
                        },
                    ],
                    headerExtensions: [
                        {
                            uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
                            id: 1,
                        },
                        {
                            uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
                            id: 4,
                        },
                        {
                            uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
                            id: 5,
                        },
                        {
                            uri: 'urn:3gpp:video-orientation',
                            id: 11,
                        },
                        {
                            uri: 'urn:ietf:params:rtp-hdrext:toffset',
                            id: 12,
                        },
                    ],
                    rtcp: {
                        cname: 'wB4Ql4lrsxYLjzuN',
                        reducedSize: true,
                        mux: true,
                    },
                }),
            };
        }
        case 'video/H264': {
            return {
                id: id ?? generateFakeUuid(),
                producerId: generateFakeUuid(),
                kind: 'video',
                rtpParameters: utils.deepFreeze({
                    codecs: [
                        {
                            mimeType: 'video/H264',
                            payloadType: 103,
                            clockRate: 90000,
                            rtcpFeedback: [
                                { type: 'nack' },
                                { type: 'nack', parameter: 'pli' },
                                { type: 'ccm', parameter: 'fir' },
                                { type: 'goog-remb' },
                                { type: 'transport-cc' },
                            ],
                            parameters: {
                                'level-asymmetry-allowed': 1,
                                'packetization-mode': 1,
                                'profile-level-id': '42e01f',
                            },
                        },
                        {
                            mimeType: 'video/rtx',
                            payloadType: 104,
                            clockRate: 90000,
                            rtcpFeedback: [],
                            parameters: {
                                apt: 103,
                            },
                        },
                    ],
                    encodings: [
                        {
                            ssrc: 99991113,
                            rtx: {
                                ssrc: 99991114,
                            },
                        },
                    ],
                    headerExtensions: [
                        {
                            uri: 'urn:ietf:params:rtp-hdrext:sdes:mid',
                            id: 1,
                        },
                        {
                            uri: 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time',
                            id: 4,
                        },
                        {
                            uri: 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01',
                            id: 5,
                        },
                        {
                            uri: 'urn:3gpp:video-orientation',
                            id: 11,
                        },
                        {
                            uri: 'urn:ietf:params:rtp-hdrext:toffset',
                            id: 12,
                        },
                    ],
                    rtcp: {
                        cname: 'wB4Ql4lrsxYLjzuN',
                        reducedSize: true,
                        mux: true,
                    },
                }),
            };
        }
        default: {
            throw new TypeError(`unknown codecMimeType '${codecMimeType}'`);
        }
    }
}
function generateDataProducerRemoteParameters() {
    return utils.deepFreeze({
        id: generateFakeUuid(),
    });
}
function generateDataConsumerRemoteParameters({ id, } = {}) {
    return {
        id: id ?? generateFakeUuid(),
        dataProducerId: generateFakeUuid(),
        sctpStreamParameters: utils.deepFreeze({
            streamId: 666,
            maxPacketLifeTime: 5000,
            maxRetransmits: undefined,
        }),
    };
}


/***/ }),

/***/ 5328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FakeMediaStreamTrack = void 0;
const uuid_1 = __webpack_require__(2614);
const FakeEventTarget_1 = __webpack_require__(5935);
const FakeEvent_1 = __webpack_require__(878);
const utils_1 = __webpack_require__(3785);
class FakeMediaStreamTrack extends FakeEventTarget_1.FakeEventTarget {
    #id;
    #kind;
    #label;
    #readyState;
    #enabled;
    #muted;
    #contentHint;
    #capabilities;
    #constraints;
    #settings;
    #data;
    // Events.
    #onmute = null;
    #onunmute = null;
    #onended = null;
    // Custom events.
    #onenabledchange = null;
    #onstopped = null;
    constructor({ kind, id, label, contentHint, enabled, muted, readyState, capabilities, constraints, settings, data, }) {
        super();
        this.#id = id ?? (0, uuid_1.v4)();
        this.#kind = kind;
        this.#label = label ?? '';
        this.#contentHint = contentHint ?? '';
        this.#enabled = enabled ?? true;
        this.#muted = muted ?? false;
        this.#readyState = readyState ?? 'live';
        this.#capabilities = capabilities ?? {};
        this.#constraints = constraints ?? {};
        this.#settings = settings ?? {};
        this.#data = data ?? {};
    }
    get id() {
        return this.#id;
    }
    get kind() {
        return this.#kind;
    }
    get label() {
        return this.#label;
    }
    get contentHint() {
        return this.#contentHint;
    }
    set contentHint(contentHint) {
        this.#contentHint = contentHint;
    }
    get enabled() {
        return this.#enabled;
    }
    /**
     * Changes `enabled` member value and fires a custom "enabledchange" event.
     */
    set enabled(enabled) {
        const changed = this.#enabled !== enabled;
        this.#enabled = enabled;
        if (changed) {
            this.dispatchEvent(new FakeEvent_1.FakeEvent('enabledchange'));
        }
    }
    get muted() {
        return this.#muted;
    }
    get readyState() {
        return this.#readyState;
    }
    /**
     * Application custom data getter.
     */
    get data() {
        return this.#data;
    }
    /**
     * Application custom data setter.
     */
    set data(data) {
        this.#data = data;
    }
    get onmute() {
        return this.#onmute;
    }
    set onmute(handler) {
        if (this.#onmute) {
            this.removeEventListener('mute', this.#onmute);
        }
        this.#onmute = handler;
        if (handler) {
            this.addEventListener('mute', handler);
        }
    }
    get onunmute() {
        return this.#onunmute;
    }
    set onunmute(handler) {
        if (this.#onunmute) {
            this.removeEventListener('unmute', this.#onunmute);
        }
        this.#onunmute = handler;
        if (handler) {
            this.addEventListener('unmute', handler);
        }
    }
    get onended() {
        return this.#onended;
    }
    set onended(handler) {
        if (this.#onended) {
            this.removeEventListener('ended', this.#onended);
        }
        this.#onended = handler;
        if (handler) {
            this.addEventListener('ended', handler);
        }
    }
    get onenabledchange() {
        return this.#onenabledchange;
    }
    set onenabledchange(handler) {
        if (this.#onenabledchange) {
            this.removeEventListener('enabledchange', this.#onenabledchange);
        }
        this.#onenabledchange = handler;
        if (handler) {
            this.addEventListener('enabledchange', handler);
        }
    }
    get onstopped() {
        return this.#onstopped;
    }
    set onstopped(handler) {
        if (this.#onstopped) {
            this.removeEventListener('stopped', this.#onstopped);
        }
        this.#onstopped = handler;
        if (handler) {
            this.addEventListener('stopped', handler);
        }
    }
    addEventListener(type, listener, options) {
        super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
    }
    /**
     * Changes `readyState` member to "ended" and fires a custom "stopped" event
     * (if not already stopped).
     */
    stop() {
        if (this.#readyState === 'ended') {
            return;
        }
        this.#readyState = 'ended';
        this.dispatchEvent(new FakeEvent_1.FakeEvent('stopped'));
    }
    /**
     * Clones current track into another FakeMediaStreamTrack. `id` and `data`
     * can be optionally given.
     */
    clone({ id, data, } = {}) {
        return new FakeMediaStreamTrack({
            id: id ?? (0, uuid_1.v4)(),
            kind: this.#kind,
            label: this.#label,
            contentHint: this.#contentHint,
            enabled: this.#enabled,
            muted: this.#muted,
            readyState: this.#readyState,
            capabilities: (0, utils_1.clone)(this.#capabilities),
            constraints: (0, utils_1.clone)(this.#constraints),
            settings: (0, utils_1.clone)(this.#settings),
            data: data ?? (0, utils_1.clone)(this.#data),
        });
    }
    getCapabilities() {
        return this.#capabilities;
    }
    getConstraints() {
        return this.#constraints;
    }
    async applyConstraints(constraints = {}) {
        this.#constraints = constraints;
        // To make it be "more" async so ESLint doesn't complain.
        return Promise.resolve();
    }
    getSettings() {
        return this.#settings;
    }
    /**
     * Simulates a remotely triggered stop. It fires a custom "stopped" event and
     * the standard "ended" event (if the track was not already stopped).
     */
    remoteStop() {
        if (this.#readyState === 'ended') {
            return;
        }
        this.#readyState = 'ended';
        this.dispatchEvent(new FakeEvent_1.FakeEvent('stopped'));
        this.dispatchEvent(new FakeEvent_1.FakeEvent('ended'));
    }
    /**
     * Simulates a remotely triggered mute. It fires a "mute" event (if the track
     * was not already muted).
     */
    remoteMute() {
        if (this.#muted) {
            return;
        }
        this.#muted = true;
        this.dispatchEvent(new FakeEvent_1.FakeEvent('mute'));
    }
    /**
     * Simulates a remotely triggered unmute. It fires an "unmute" event (if the
     * track was muted).
     */
    remoteUnmute() {
        if (!this.#muted) {
            return;
        }
        this.#muted = false;
        this.dispatchEvent(new FakeEvent_1.FakeEvent('unmute'));
    }
}
exports.FakeMediaStreamTrack = FakeMediaStreamTrack;


/***/ }),

/***/ 5414:
/***/ ((module) => {

!function(t,e){if(true)module.exports=e();else // removed by dead control flow
{ var o, a; }}(self,(function(){return(()=>{var t={43:function(t,e,a){var o,s;!function(r,l){"use strict";o=function(){var t=function(){},e="undefined",a=typeof window!==e&&typeof window.navigator!==e&&/Trident\/|MSIE /.test(window.navigator.userAgent),o=["trace","debug","info","warn","error"];function s(t,e){var a=t[e];if("function"==typeof a.bind)return a.bind(t);try{return Function.prototype.bind.call(a,t)}catch(e){return function(){return Function.prototype.apply.apply(a,[t,arguments])}}}function r(){console.log&&(console.log.apply?console.log.apply(console,arguments):Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}function l(o){return"debug"===o&&(o="log"),typeof console!==e&&("trace"===o&&a?r:void 0!==console[o]?s(console,o):void 0!==console.log?s(console,"log"):t)}function c(e,a){for(var s=0;s<o.length;s++){var r=o[s];this[r]=s<e?t:this.methodFactory(r,e,a)}this.log=this.debug}function n(t,a,o){return function(){typeof console!==e&&(c.call(this,a,o),this[t].apply(this,arguments))}}function i(t,e,a){return l(t)||n.apply(this,arguments)}function _(t,a,s){var r,l=this,n="loglevel";function _(){var t;if(typeof window!==e&&n){try{t=window.localStorage[n]}catch(t){}if(typeof t===e)try{var a=window.document.cookie,o=a.indexOf(encodeURIComponent(n)+"=");-1!==o&&(t=/^([^;]+)/.exec(a.slice(o))[1])}catch(t){}return void 0===l.levels[t]&&(t=void 0),t}}"string"==typeof t?n+=":"+t:"symbol"==typeof t&&(n=void 0),l.name=t,l.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},l.methodFactory=s||i,l.getLevel=function(){return r},l.setLevel=function(a,s){if("string"==typeof a&&void 0!==l.levels[a.toUpperCase()]&&(a=l.levels[a.toUpperCase()]),!("number"==typeof a&&a>=0&&a<=l.levels.SILENT))throw"log.setLevel() called with invalid level: "+a;if(r=a,!1!==s&&function(t){var a=(o[t]||"silent").toUpperCase();if(typeof window!==e&&n){try{return void(window.localStorage[n]=a)}catch(t){}try{window.document.cookie=encodeURIComponent(n)+"="+a+";"}catch(t){}}}(a),c.call(l,a,t),typeof console===e&&a<l.levels.SILENT)return"No console available for logging"},l.setDefaultLevel=function(t){_()||l.setLevel(t,!1)},l.enableAll=function(t){l.setLevel(l.levels.TRACE,t)},l.disableAll=function(t){l.setLevel(l.levels.SILENT,t)};var d=_();null==d&&(d=null==a?"WARN":a),l.setLevel(d,!1)}var d=new _,u={};d.getLogger=function(t){if("symbol"!=typeof t&&"string"!=typeof t||""===t)throw new TypeError("You must supply a name when creating a logger.");var e=u[t];return e||(e=u[t]=new _(t,d.getLevel(),d.methodFactory)),e};var p=typeof window!==e?window.log:void 0;return d.noConflict=function(){return typeof window!==e&&window.log===d&&(window.log=p),d},d.getLoggers=function(){return u},d.default=d,d},void 0===(s=o.call(e,a,e,t))||(t.exports=s)}()}},e={};function a(o){var s=e[o];if(void 0!==s)return s.exports;var r=e[o]={exports:{}};return t[o].call(r.exports,r,r.exports,a),r.exports}a.d=(t,e)=>{for(var o in e)a.o(e,o)&&!a.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},a.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),a.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var o={};return(()=>{"use strict";a.r(o),a.d(o,{VideoSDKMetrics:()=>st});const t="inbound",e="outbound",s={codec_id_in:"",codec_in:{mime_type:null,clock_rate:null,sdp_fmtp_line:null},delta_jitter_ms_in:0,delta_rtt_ms_out:null,percent_packets_lost_in:0,delta_packets_in:0,delta_packets_lost_in:0,total_packets_in:0,total_packets_lost_in:0,total_KBytes_in:0,delta_KBytes_in:0,delta_kbs_in:0,timestamp_in:null,ssrc:"",total_concealment_events:0,delta_concealment_events:0,total_inserted_samples_for_decelaration:0,delta_inserted_samples_for_decelaration:0,total_removed_samples_for_accelaration:0,delta_removed_samples_for_accelaration:0,direction:t},r={codec_id_out:"",codec_out:{mime_type:null,clock_rate:null,sdp_fmtp_line:null},delta_jitter_ms_out:0,delta_rtt_ms_out:null,percent_packets_lost_out:0,delta_packets_out:0,delta_packets_lost_out:0,total_packets_out:0,total_packets_lost_out:0,total_KBytes_out:0,delta_KBytes_out:0,delta_kbs_out:0,timestamp_out:null,ssrc:"",direction:e},l={codec_id_in:"",size_in:{width:null,height:null,framerate:null},codec_in:{mime_type:null,clock_rate:null},delta_jitter_ms_in:0,percent_packets_lost_in:0,delta_packets_in:0,delta_packets_lost_in:0,total_packets_in:0,total_packets_lost_in:0,total_KBytes_in:0,delta_KBytes_in:0,delta_kbs_in:0,ssrc:"",direction:t},c={codec_id_out:"",size_out:{width:null,height:null,framerate:null},codec_out:{mime_type:null,clock_rate:null},delta_jitter_ms_out:0,delta_rtt_ms_out:null,percent_packets_lost_out:0,delta_packets_out:0,delta_packets_lost_out:0,total_packets_out:0,total_packets_lost_out:0,total_KBytes_out:0,delta_KBytes_out:0,delta_kbs_out:0,limitation_out:{reason:null,durations:null,resolutionChanges:0},timestamp_out:null,ssrc:"",direction:e},n="inbound-rtp",i="bytesReceived",_="bytesSent",d="currentRoundTripTime",u="roundTripTime",p="fractionLost",m="frameHeight",y="frameWidth",v="qualityLimitationReason",k="qualityLimitationDurations",f="qualityLimitationResolutionChanges",b="jitter",h="packetsLost",g="packetsReceived",w="packetsSent",O="responsesReceived",S="selected",I="totalRoundTripTime",j="roundTripTimeMeasurements",P="framesDecoded",R="framesEncoded",L="totalDecodeTime",T="totalEncodeTime",C="pliCount",B="nackCount",K="audio",E="video",N={0:"ETHERNET",2:"CELLULAR_5G",3:"WIFI",5:"CELLULAR_4G",10:"CELLULAR"},$="audio",z="video",D="network",F="data";var A=a(43);const x=()=>`${(new Date).toISOString()} | metrics`,M=(t,e,a)=>`${t} | ${e} | ${a}`;A.setDefaultLevel(A.levels.TRACE);const U=(t,e,a)=>{a?A.debug(M(x(),t,e),a):A.debug(M(x(),t,e))},q=(t,e)=>{A.warn(M(x(),t,e))},W=(t,e)=>{A.error(M(x(),t,e))},G="extractor   ",H=(e,a,o)=>{if(!a)return null;const n={};let i=a.audio[e];i||(i=o===t?{...s}:{...r}),n.audio=i;let _=a.video[e];return _||(_=o===t?{...l}:{...c}),n.video=_,n},V=(t,e,a,o)=>{let s=!1;const r=o[e].total_rtt_ms_out,l=o[e].total_rtt_measure_out,c=a?a[e].total_rtt_ms_out:0,n=a?a[e].total_rtt_measure_out:0,i={rtt:null,totalRTT:r,totalRTTMeasurements:l};if(t.timestamp===o[e].timestamp_out)return i;if(!Object.prototype.hasOwnProperty.call(t,u))return i;if(Object.prototype.hasOwnProperty.call(t,j)&&(s=!0,0===Number(t.roundTripTimeMeasurements)||Number(t.roundTripTimeMeasurements)-n===l))return i;const _=Number(1e3)*Number(t.roundTripTime);let d=r+_,p=l+1;return s&&(d=Number(1e3)*Number(t.totalRoundTripTime)-c,p=Number(t.roundTripTimeMeasurements)-n),{rtt:_,totalRTT:d,totalRTTMeasurements:p}},J=(t,e,a)=>t.timestamp===a[e].timestamp_out?null:Object.prototype.hasOwnProperty.call(t,b)?Number(1e3)*(Number(t.jitter)||0):null,Y=(t,e,a,o)=>{if(!Object.prototype.hasOwnProperty.call(t,w)||!Object.prototype.hasOwnProperty.call(t,_))return{packetsSent:a[e].total_packets_out,packetsLost:a[e].total_packets_lost_out,bytesSent:a[e].total_KBytes_out};const s=Number(t.packetsSent)||0-(o?o[e].total_packets_out:0),r=s-a[e].total_packets_out,l=Number(t.bytesSent)/1024-(o?o[e].total_KBytes_out:0),c=l-a[e].total_KBytes_out,n=t.timestamp||Date.now(),i=o?o.timestamp:null;let d=a.timestamp;!d&&i&&(d=i);const u=d?n-d:0;return{packetsSent:s,deltaPacketsSent:r,KBytesSent:l,deltaKBytesSent:c,kbsSent:u>0?.008*c*1024/u*1e3:0}},Q=(t,e,a,o)=>{let s=a[e].total_packets_lost_out,r=0,l=0;return Object.prototype.hasOwnProperty.call(t,h)&&(s=Number(t.packetsLost)||0-(o?o[e].total_packets_lost_out:0),r=s-a[e].total_packets_lost_out),Object.prototype.hasOwnProperty.call(t,p)&&(l=Number(100*t.fractionLost)),{packetsLost:s,deltaPacketsLost:r,fractionLost:l}},X=(t,e,a,o)=>{if(!Object.prototype.hasOwnProperty.call(t,g)||!Object.prototype.hasOwnProperty.call(t,h)||!Object.prototype.hasOwnProperty.call(t,i))return{percent_packets_lost:a[e].percent_packets_lost_in,packetsReceived:a[e].total_packets_in,packetsLost:a[e].total_packets_lost_in,bytesReceived:a[e].total_KBytes_in};const s=(Number(t.packetsReceived)||0)-(o?o[e].total_packets_in:0),r=(Number(t.packetsLost)||0)-(o?o[e].total_packets_lost_in:0),l=r-a[e].total_packets_lost_in,c=s-a[e].total_packets_in,n=s!==a[e].total_packets_in?100*l/(l+c):0,_=Number(t.bytesReceived)/1024-(o?o[e].total_KBytes_in:0),d=_-a[e].total_KBytes_in,u=t.timestamp||Date.now(),p=o?o.timestamp:null;let m=a.timestamp;!m&&p&&(m=p);const y=m?u-m:0;return{percentPacketsLost:n,packetsReceived:s,deltaPacketsReceived:c,packetsLost:r,deltaPacketsLost:l,KBytesReceived:_,deltaKBytesReceived:d,kbsReceived:y>0?.008*d*1024/y*1e3:0}},Z=t=>"relay"!==t.candidateType?"":t.relayProtocol||"",tt=t=>Object.prototype.hasOwnProperty.call(t,m)&&Object.prototype.hasOwnProperty.call(t,y)?{width:t.frameWidth||null,height:t.frameHeight||null,framerate:t.framesPerSecond}:{width:null,height:null,framerate:null};class et{constructor(t,e){this._callbacks={onStatsCollected:null},this._id=`collector-${e}`,this._moduleName=this._id,this._probeId=e,this._config=t,this._state="idle",this._statsReports=[]}registerCallback(t,e,a){t in this._callbacks?(this._callbacks[t]={callback:e,context:a},U(this._moduleName,`registered callback '${t}'`)):W(this._moduleName,`can't register callback for '${t}' - not found`)}unregisterCallback(t){t in this._callbacks?(this._callbacks[t]=null,delete this._callbacks[t],U(this._moduleName,`unregistered callback '${t}'`)):W(this._moduleName,`can't unregister callback for '${t}' - not found`)}analyze(a,o){const i=(t=>{const e={name:"",meetingId:"",peerId:"",timestamp:null,count:0,audio:{},video:{},network:{infrastructure:3},data:{delta_kbs_bandwidth_in:0,delta_kbs_bandwidth_out:0,delta_rtt_connectivity_ms:null,total_rtt_connectivity_ms:0}};if(t){const e={...t,audio:{},video:{},data:{...t.data},network:{...t.network}};return Object.keys(t.audio).forEach((a=>{e.audio[a]={...t.audio[a]}})),Object.keys(t.video).forEach((a=>{e.video[a]={...t.video[a]}})),e}return{...e,audio:{},video:{},data:{...e.data},network:{...e.network}}})(o);i.name=this._config.name,i.meetingId=this._config.meetingId,i.peerId=this._config.peerId,i.count=o?o.count+1:1;let _=null;return a.forEach((a=>{!_&&a.timestamp&&(_=a.timestamp),((a,o,s,r)=>{if(!a)return[];switch(a.type){case"candidate-pair":let l=!1;if(a.nominated&&"succeeded"===a.state&&(l=!0,U(G,`analyze() - got stats ${a.type} for ${s}`,a),S in a&&!a.selected&&(l=!1)),l){a.localCandidateId,a.remoteCandidateId;const t=((t,e,a)=>{const o=(t.bytesReceived||0)/1024-(a?a.data.total_KBytes_in:0),s=(t.bytesSent||0)/1024-(a?a.data.total_KBytes_out:0),r=t.timestamp||Date.now(),l=o-e.data.total_KBytes_in,c=s-e.data.total_KBytes_out,n=a?a.timestamp:null;let i=e.timestamp;!i&&n&&(i=n);const _=i?r-i:0;return{total_KBytes_received:o,total_KBytes_sent:s,delta_KBytes_received:l,delta_KBytes_sent:c,kbs_speed_received:_>0?.008*l*1024/_*1e3:0,kbs_speed_sent:_>0?.008*c*1024/_*1e3:0}})(a,o,r),e=((t=>{t.availableIncomingBitrate,t.availableOutgoingBitrate})(a),((t,e,a,o)=>{if(!Object.prototype.hasOwnProperty.call(t,d))return{rtt:null,totalRTT:o.data.total_rtt_connectivity_ms,totalRTTMeasurements:o.data.total_rtt_connectivity_measure};const s=Number(1e3)*Number(t.currentRoundTripTime);let r=o.data.total_rtt_connectivity_ms+s,l=o.data.total_rtt_connectivity_measure+1;return Object.prototype.hasOwnProperty.call(t,I)&&(r=Number(1e3)*Number(t.totalRoundTripTime)-(a?a.data.total_rtt_connectivity_ms:0)),Object.prototype.hasOwnProperty.call(t,O)&&(l=Number(t.responsesReceived)-(a?a.data.total_rtt_connectivity_measure:0)),{rtt:s,totalRTT:r,totalRTTMeasurements:l}})(a,0,r,o));return[{type:F,value:{total_KBytes_in:t.total_KBytes_received}},{type:F,value:{total_KBytes_out:t.total_KBytes_sent}},{type:F,value:{delta_KBytes_in:t.delta_KBytes_received}},{type:F,value:{delta_KBytes_out:t.delta_KBytes_sent}},{type:F,value:{delta_kbs_in:t.kbs_speed_received}},{type:F,value:{delta_kbs_out:t.kbs_speed_sent}},{type:F,value:{delta_rtt_connectivity_ms:e.rtt}}]}break;case"local-candidate":if(a.id===o.network.local_candidate_id)return[{type:D,value:{infrastructure:a.networkType}},{type:D,value:{local_candidate_protocol:a.protocol||""}},{type:D,value:{local_candidate_relay_protocol:Z(a)}}];break;case n:{U(G,`analyze() - got stats ${a.type} for ${s}`,a);const e=a.ssrc,l=H(e,o,t);l&&(l.timestamp=o.timestamp);const c=H(e,r,t);if(c&&(c.timestamp=r.timestamp),a.kind===K){const t=X(a,K,l,c),o=J(a,K,l),s=a.codecId||"",r=((t,e,a,o)=>{const s=Number(t.concealmentEvents)||0,r=s-(a.audio.total_concealment_events||0),l=Number(t.insertedSamplesForDeceleration)||0,c=l-(a.audio.total_inserted_samples_for_decelaration||0),n=Number(t.removedSamplesForAcceleration)||0;return{totalConcealmentEvents:s,deltaConcealmentEvents:r,totalInsertedSamplesForDecelaration:l,deltaInsertedSamplesForDecelaration:c,totalRemovedSamplesForAccelaration:n,deltaRemovedSampleForAccelaration:n-(a.audio.total_removed_samples_for_accelaration||0)}})(a,0,l);return[{ssrc:e,type:$,value:{codec_id_in:s}},{ssrc:e,type:$,value:{total_packets_in:t.packetsReceived}},{ssrc:e,type:$,value:{delta_packets_in:t.deltaPacketsReceived}},{ssrc:e,type:$,value:{total_packets_lost_in:t.packetsLost}},{ssrc:e,type:$,value:{delta_packets_lost_in:t.deltaPacketsLost}},{ssrc:e,type:$,value:{percent_packets_lost_in:t.percentPacketsLost}},{ssrc:e,type:$,value:{total_KBytes_in:t.KBytesReceived}},{ssrc:e,type:$,value:{delta_KBytes_in:t.deltaKBytesReceived}},{ssrc:e,type:$,value:{delta_kbs_in:t.kbsReceived}},{ssrc:e,type:$,value:{delta_jitter_ms_in:o}},{ssrc:e,type:$,value:{total_concealment_events:r.totalConcealmentEvents}},{ssrc:e,type:$,value:{delta_concealment_events:r.deltaConcealmentEvents}},{ssrc:e,type:$,value:{total_inserted_samples_for_decelaration:r.totalInsertedSamplesForDecelaration}},{ssrc:e,type:$,value:{delta_inserted_samples_for_decelaration:r.deltaInsertedSamplesForDecelaration}},{ssrc:e,type:$,value:{total_removed_samples_for_accelaration:r.totalRemovedSamplesForAccelaration}},{ssrc:e,type:$,value:{delta_removed_samples_for_accelaration:r.deltaRemovedSampleForAccelaration}},{ssrc:e,type:$,value:{track_in:a.trackId}},{ssrc:e,type:$,value:{track_id_in:a.trackIdentifier}},{ssrc:e,type:$,value:{media_source_id:a.mediaSourceId}}]}if(a.kind===E){((t,e)=>{if(!Object.prototype.hasOwnProperty.call(t,P)||!Object.prototype.hasOwnProperty.call(t,L))return{delta_ms_decode_frame:e.video.delta_ms_decode_frame_in,frames_decoded:e.video.total_frames_decoded_in,total_decode_time:e.video.total_time_decoded_in};t.framesDecoded;t.totalDecodeTime,e.video.total_time_decoded_in,e.video.total_frames_decoded_in})(a,l);const t=X(a,E,l,c),o=J(a,E,l),s=(a.decoderImplementation,a.codecId||null),r=tt(a);return((t,e,a)=>{if(!Object.prototype.hasOwnProperty.call(t,C)||!Object.prototype.hasOwnProperty.call(t,B))return{pliCount:e.total_pli_sent_in,nackCount:e.total_nack_sent_in,deltaPliCount:0,deltaNackCount:0};t.pliCount,a&&a.video.total_pli_sent_in,t.nackCount,a&&a.video.total_nack_sent_in,e.video.total_pli_sent_in,e.video.total_nack_sent_in})(a,l,c),[{ssrc:e,type:z,value:{codec_id_in:s}},{ssrc:e,type:z,value:{total_packets_in:t.packetsReceived}},{ssrc:e,type:z,value:{delta_packets_in:t.deltaPacketsReceived}},{ssrc:e,type:z,value:{total_packets_lost_in:t.packetsLost}},{ssrc:e,type:z,value:{delta_packets_lost_in:t.deltaPacketsLost}},{ssrc:e,type:z,value:{percent_packets_lost_in:t.percentPacketsLost}},{ssrc:e,type:z,value:{total_KBytes_in:t.KBytesReceived}},{ssrc:e,type:z,value:{delta_KBytes_in:t.deltaKBytesReceived}},{ssrc:e,type:z,value:{delta_kbs_in:t.kbsReceived}},{ssrc:e,type:z,value:{delta_jitter_ms_in:o}},{ssrc:e,type:z,value:{size_in:r}},{ssrc:e,type:z,value:{track_in:a.trackId}},{ssrc:e,type:z,value:{track_id_in:a.trackIdentifier}},{ssrc:e,type:z,value:{media_source_id:a.mediaSourceId}},{ssrc:e,type:z,value:{pause_count:a.pauseCount}},{ssrc:e,type:z,value:{total_pauses_duration:a.totalPausesDuration}},{ssrc:e,type:z,value:{freeze_count:a.freezeCount}},{ssrc:e,type:z,value:{total_freezes_duration:a.totalFreezesDuration}}]}break}case"outbound-rtp":{U(G,`analyze() - got stats ${a.type} for ${s}`,a);const t=a.ssrc,l=H(t,o,e);l&&(l.timestamp=o.timestamp);const c=H(t,r,e);if(c&&(c.timestamp=r.timestamp),a.kind===K){const e=a.codecId||null,o=Y(a,K,l,c);return[{ssrc:t,type:$,value:{codec_id_out:e}},{ssrc:t,type:$,value:{total_packets_out:o.packetsSent}},{ssrc:t,type:$,value:{delta_packets_out:o.deltaPacketsSent}},{ssrc:t,type:$,value:{total_KBytes_out:o.KBytesSent}},{type:$,value:{delta_KBytes_out:o.deltaKBytesSent}},{ssrc:t,type:$,value:{delta_kbs_out:o.kbsSent}},{ssrc:t,type:$,value:{track_out:a.trackId}},{ssrc:t,type:$,value:{track_id_out:a.trackIdentifier}},{ssrc:t,type:$,value:{media_source_id:a.mediaSourceId}}]}if(a.kind===E){a.encoderImplementation;const e=a.codecId||null,o=(((t,e)=>{if(!Object.prototype.hasOwnProperty.call(t,R)||!Object.prototype.hasOwnProperty.call(t,T))return{delta_ms_encode_frame:e.video.delta_ms_encode_frame_out,frames_encoded:e.video.total_frames_encoded_out,total_encode_time:e.video.total_time_encoded_out};t.framesEncoded;t.totalEncodeTime,e.video.total_time_encoded_out,e.video.total_frames_encoded_out})(a,l),tt(a)),s=(t=>{const e=Object.prototype.hasOwnProperty.call(t,v)?t.qualityLimitationReason:null,a=Object.prototype.hasOwnProperty.call(t,f)?t.qualityLimitationResolutionChanges:null,o=Object.prototype.hasOwnProperty.call(t,k)?t.qualityLimitationDurations:null;return o&&Object.keys(o).forEach((t=>{o[t]>1e3&&(o[t]=Number(o[t]/1e3))})),{reason:e,durations:o,resolutionChanges:a}})(a),r=(((t,e,a)=>{if(!Object.prototype.hasOwnProperty.call(t,C)||!Object.prototype.hasOwnProperty.call(t,B))return{pliCount:e.total_pli_received_out,nackCount:e.total_nack_received_out,deltaPliCount:0,deltaNackCount:0};t.pliCount,a&&a.video.total_pli_received_out,t.nackCount,a&&a.video.total_nack_received_out,e.video.total_pli_received_out,e.video.total_nack_received_out})(a,l,c),Y(a,E,l,c));return[{ssrc:t,type:z,value:{codec_id_out:e}},{ssrc:t,type:z,value:{total_packets_out:r.packetsSent}},{ssrc:t,type:z,value:{delta_packets_out:r.deltaPacketsSent}},{ssrc:t,type:z,value:{total_KBytes_out:r.KBytesSent}},{ssrc:t,type:z,value:{delta_KBytes_out:r.deltaKBytesSent}},{ssrc:t,type:z,value:{delta_kbs_out:r.kbsSent}},{ssrc:t,type:z,value:{size_out:o}},{ssrc:t,type:z,value:{limitation_out:s}},{ssrc:t,type:z,value:{track_out:a.trackId}},{ssrc:t,type:z,value:{track_id_out:a.trackIdentifier}},{ssrc:t,type:z,value:{media_source_id:a.mediaSourceId}}]}break}case"media-source":{U(G,`analyze() - got stats ${a.type} for ${s}`,a);const t=[];return Object.keys(o.audio).forEach((e=>{const s=o.audio[e];if(s.media_source_id===a.id){var r=a.trackIdentifier;t.push({ssrc:s.ssrc,type:$,value:{track_id_out:r}})}})),Object.keys(o.video).forEach((e=>{const s=o.video[e];if(s.media_source_id===a.id){var r=a.trackIdentifier;t.push({ssrc:s.ssrc,type:z,value:{track_id_out:r}})}})),t}case"track":{U(G,`analyze() - got stats ${a.type} for ${s}`,a);const t=[];return Object.keys(o.audio).forEach((e=>{const r=o.audio[e];if(r.track_in===a.id||r.track_out===a.id){U(G,`analyze() - got stats ${a.type} for ${s}`,a);var l=a.trackIdentifier;a.id===r.track_in?t.push({ssrc:r.ssrc,type:$,value:{track_id_in:l}}):t.push({ssrc:r.ssrc,type:$,value:{track_id_out:l}})}})),Object.keys(o.video).forEach((e=>{const r=o.video[e];if(r.track_in===a.id||r.track_out===a.id){U(G,`analyze() - got stats ${a.type} for ${s}`,a);var l=a.trackIdentifier;a.id===r.track_in?t.push({ssrc:r.ssrc,type:z,value:{track_id_in:l}}):t.push({ssrc:r.ssrc,type:z,value:{track_id_out:l}})}})),t}case"codec":const c=[];return Object.keys(o.audio).forEach((t=>{const e=o.audio[t];if(e.codec_id_in===a.id||e.codec_id_out===a.id){U(G,`analyze() - got stats ${a.type} for ${s}`,a);const t=(t=>({channels:t.channels||null,clock_rate:t.clockRate||null,mime_type:t.mimeType||null,sdp_fmtp_line:t.sdpFmtpLine||null}))(a);a.id===e.codec_id_in?c.push({ssrc:e.ssrc,type:$,value:{codec_in:t}}):c.push({ssrc:e.ssrc,type:$,value:{codec_out:t}})}})),Object.keys(o.video).forEach((t=>{const e=o.video[t];if(e.codec_id_in===a.id||e.codec_id_out===a.id){U(G,`analyze() - got stats ${a.type} for ${s}`,a);const t=(t=>({clock_rate:t.clockRate||null,mime_type:t.mimeType||null}))(a);a.id===e.codec_id_in?c.push({ssrc:e.ssrc,type:z,value:{codec_in:t}}):c.push({ssrc:e.ssrc,type:z,value:{codec_out:t}})}})),c;case"remote-inbound-rtp":{U(G,`analyze() - got stats ${a.type} for ${s}`,a);const t=a.ssrc,l=H(t,o,e),c=H(t,r,e);if(a.kind===K){const e=V(a,K,c,l),o=J(a,K,l),s=Q(a,K,l,c);return[{ssrc:t,type:$,value:{delta_rtt_ms_out:e.rtt}},{ssrc:t,type:$,value:{delta_jitter_ms_out:o}},{ssrc:t,type:$,value:{timestamp_out:a.timestamp}},{ssrc:t,type:$,value:{total_packets_lost_out:s.packetsLost}},{ssrc:t,type:$,value:{delta_packets_lost_out:s.deltaPacketsLost}},{ssrc:t,type:$,value:{percent_packets_lost_out:s.fractionLost}}]}if(a.kind===E){const e=V(a,E,c,l),o=J(a,E,l),s=Q(a,E,l,c);return[{ssrc:t,type:z,value:{delta_rtt_ms_out:e.rtt}},{ssrc:t,type:z,value:{delta_jitter_ms_out:o}},{ssrc:t,type:z,value:{timestamp_out:a.timestamp}},{ssrc:t,type:z,value:{total_packets_lost_out:s.packetsLost}},{ssrc:t,type:z,value:{delta_packets_lost_out:s.deltaPacketsLost}}]}break}case"remote-outbound-rtp":{U(G,`analyze() - got stats ${a.type} for ${s}`,a);const t=a.ssrc,l=H(t,o,e),c=H(t,r,e);if(a.kind===K){const e=V(a,K,c,l);return[{ssrc:t,type:$,value:{delta_rtt_ms_in:e.rtt}},{ssrc:t,type:$,value:{timestamp_in:a.timestamp}}]}break}}return[]})(a,i,i.name,null).forEach((t=>{if(t.value&&t.type)if(t.ssrc){let _=i[t.type][t.ssrc];_||(e=t.type,o=a.type,_=e===K?o===n?{...s}:{...r}:o===n?{...l}:{...c},_.ssrc=t.ssrc,i[t.type][t.ssrc]=_),Object.keys(t.value).forEach((e=>{void 0!==t.value[e]&&(_[e]=t.value[e])}))}else Object.keys(t.value).forEach((e=>{void 0!==t.value[e]&&(i[t.type][e]=t.value[e])}));var e,o}))})),i.timestamp=_,i}async collectStats(){try{const t=await this._config.monitoringObject.getStats(),e=this.analyze(t,this._statsReports.slice().pop()||null);return this._statsReports.push(e),this.fireOnStatsCollected(e),t}catch(t){return W(this._moduleName,`got error ${t}`),null}}fireOnStatsCollected(a){if(this._callbacks.onStatsCollected){const o={};o.meetingId=a.meetingId,o.peerId=a.peerId,o.name=a.name,o.audio=[],o.video=[],Object.values(a.audio).forEach((s=>{const r={};if(r.network=N[a.network.infrastructure],r.timestamp=a.timestamp,s.direction==t){r.codec=s.codec_in.mime_type,r.jitter=s.delta_jitter_ms_in,r.bitrate=s.delta_kbs_in,r.packetsLost=s.delta_packets_lost_in,r.rtt=a.data.delta_rtt_connectivity_ms||0,r.totalPackets=s.delta_packets_in,r.concealmentEvents=s.delta_concealment_events,r.removedSampleForAccelaration=s.delta_removed_samples_for_accelaration,r.insertedSamplesForDecelaration=s.delta_inserted_samples_for_decelaration;const t=JSON.stringify(s.track_id_in).replace(/[{}"]/g,"");r.trackId=t}else s.direction==e&&(r.codec=s.codec_out.mime_type,r.jitter=s.delta_jitter_ms_out,r.bitrate=s.delta_kbs_out,r.packetsLost=s.delta_packets_lost_out,r.rtt=a.data.delta_rtt_connectivity_ms||0,r.totalPackets=s.delta_packets_out,r.trackId=s.track_id_out);s.direction&&o.audio.push(r)})),Object.values(a.video).forEach((s=>{const r={};if(r.network=N[a.network.infrastructure],r.timestamp=a.timestamp,s.direction==t){r.codec=s.codec_in.mime_type,r.jitter=s.delta_jitter_ms_in,r.bitrate=s.delta_kbs_in,r.packetsLost=s.delta_packets_lost_in,r.rtt=a.data.delta_rtt_connectivity_ms||0,r.totalPackets=s.delta_packets_in,r.size=s.size_in,r.pauseCount=s.pause_count,r.totalPausesDuration=s.total_pauses_duration,r.freezeCount=s.freeze_count,r.totalFreezesDuration=s.total_freezes_duration;const t=JSON.stringify(s.track_id_in).replace(/[{}"]/g,"");r.trackId=t}else s.direction==e&&(r.codec=s.codec_out.mime_type,r.jitter=s.delta_jitter_ms_out,r.bitrate=s.delta_kbs_out,r.packetsLost=s.delta_packets_lost_out,r.rtt=a.data.delta_rtt_connectivity_ms||0,r.totalPackets=s.delta_packets_out,r.limitation=s.limitation_out,r.size=s.size_out,r.trackId=s.track_id_out);s.direction&&o.video.push(r)})),this._callbacks.onStatsCollected.callback(o)}}}class at{constructor(t){this._id=t.name&&t.name.substr(0,12).padEnd(12," "),this._moduleName=this._id,this._config=t,this._collector=new et(this._config,this._id)}get id(){return this._id}start(){this._collectorIntervalId?q("Probe already started."):(U(this._moduleName,"Probe Started"),this._collectorIntervalId=setInterval((()=>{U(this._moduleName,"Collector collecting stats"),this._collector.collectStats()}),this._config.refreshEvery))}stop(){this._collectorIntervalId?(clearInterval(this._collectorIntervalId),U(this._moduleName,"Probe Stopped")):q("Probe not running, Please start first.")}set onStatsCollected(t){t?this._collector.registerCallback("onStatsCollected",t):this._collector.unregisterCallback("onStatsCollected")}}const ot={refreshEvery:2e3,startAfter:0,stopAfter:-1,verbose:!1,peerId:"peerId",meetingId:"meetingId",name:"name"};class st{constructor(t){var e;this._config={defaultConfig:ot,...t},this._probes=[],e=this._config.verbose||!1,A.setLevel(e?A.levels.TRACE:A.levels.INFO),U("VideoSDKMetrics","VideoSDKMetrics initialized")}get probes(){return this._probes}addNewProbe(t,e){if(!t)throw new Error("undefined monitoring object");const a={monitoringObject:t,...e,...this._config},o=new at(a);return this._probes.push(o),o}removeExistingProbe(t){if(!t)throw new Error("undefined probe");t.stop(),this._probes=this._probes.filter((e=>t.id!==e.id))}getProbe(t){for(let e of this.probes)if(e.id==t)return e}startAllProbes(){this._probes.forEach(((t,e)=>{t.start()}))}stopAllProbes(){this._probes.forEach((t=>t.stop()))}}})(),o})()}));

/***/ }),

/***/ 5458:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ _toConsumableArray)
});

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
var arrayLikeToArray = __webpack_require__(3145);
;// ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return (0,arrayLikeToArray/* default */.A)(r);
}

;// ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
var unsupportedIterableToArray = __webpack_require__(7800);
;// ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

;// ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || (0,unsupportedIterableToArray/* default */.A)(r) || _nonIterableSpread();
}


/***/ }),

/***/ 5471:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),

/***/ 5501:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _inherits)
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3662);

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(t, e);
}


/***/ }),

/***/ 5503:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),

/***/ 5528:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ 5544:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractRtpCapabilities = extractRtpCapabilities;
exports.extractDtlsParameters = extractDtlsParameters;
exports.getCname = getCname;
exports.applyCodecParameters = applyCodecParameters;
const sdpTransform = __webpack_require__(7363);
/**
 * This function extracs RTP capabilities from the given SDP.
 *
 * BUNDLE is assumed so, as per spec, all media sections in the SDP must share
 * same ids for codecs and RTP extensions.
 */
function extractRtpCapabilities({ sdpObject, }) {
    // Map of RtpCodecParameters indexed by payload type.
    const codecsMap = new Map();
    // Map of RtpHeaderExtensions indexed by preferred id.
    const headerExtensionMap = new Map();
    for (const m of sdpObject.media) {
        const kind = m.type;
        switch (kind) {
            case 'audio':
            case 'video': {
                break;
            }
            default: {
                continue;
            }
        }
        // Get codecs.
        for (const rtp of m.rtp) {
            const codec = {
                kind: kind,
                mimeType: `${kind}/${rtp.codec}`,
                preferredPayloadType: rtp.payload,
                clockRate: rtp.rate,
                channels: rtp.encoding,
                parameters: {},
                rtcpFeedback: [],
            };
            codecsMap.set(codec.preferredPayloadType, codec);
        }
        // Get codec parameters.
        for (const fmtp of m.fmtp ?? []) {
            const parameters = sdpTransform.parseParams(fmtp.config);
            const codec = codecsMap.get(fmtp.payload);
            if (!codec) {
                continue;
            }
            // Specials cases to convert parameter value to string.
            if (parameters?.hasOwnProperty('profile-level-id')) {
                parameters['profile-level-id'] = String(parameters['profile-level-id']);
            }
            codec.parameters = parameters;
        }
        // Get RTCP feedback for each codec.
        for (const fb of m.rtcpFb ?? []) {
            const feedback = {
                type: fb.type,
                parameter: fb.subtype,
            };
            if (!feedback.parameter) {
                delete feedback.parameter;
            }
            // rtcp-fb payload is not '*', so just apply it to its corresponding
            // codec.
            if (fb.payload !== '*') {
                const codec = codecsMap.get(Number(fb.payload));
                if (!codec) {
                    continue;
                }
                codec.rtcpFeedback.push(feedback);
            }
            // If rtcp-fb payload is '*' it must be applied to all codecs with same
            // kind (with some exceptions such as RTX codec).
            else {
                for (const codec of codecsMap.values()) {
                    if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) {
                        codec.rtcpFeedback.push(feedback);
                    }
                }
            }
        }
        // Get RTP header extensions.
        for (const ext of m.ext ?? []) {
            // Ignore encrypted extensions (not yet supported in mediasoup).
            if (ext['encrypt-uri']) {
                continue;
            }
            const headerExtension = {
                kind: kind,
                uri: ext.uri,
                preferredId: ext.value,
            };
            headerExtensionMap.set(headerExtension.preferredId, headerExtension);
        }
    }
    const rtpCapabilities = {
        codecs: Array.from(codecsMap.values()),
        headerExtensions: Array.from(headerExtensionMap.values()),
    };
    return rtpCapabilities;
}
function extractDtlsParameters({ sdpObject, }) {
    let setup = sdpObject.setup;
    let fingerprint = sdpObject.fingerprint;
    if (!setup || !fingerprint) {
        const mediaObject = (sdpObject.media ?? []).find((m) => m.port !== 0);
        if (mediaObject) {
            setup ??= mediaObject.setup;
            fingerprint ??= mediaObject.fingerprint;
        }
    }
    if (!setup) {
        throw new Error('no a=setup found at SDP session or media level');
    }
    else if (!fingerprint) {
        throw new Error('no a=fingerprint found at SDP session or media level');
    }
    let role;
    switch (setup) {
        case 'active': {
            role = 'client';
            break;
        }
        case 'passive': {
            role = 'server';
            break;
        }
        case 'actpass': {
            role = 'auto';
            break;
        }
    }
    const dtlsParameters = {
        role,
        fingerprints: [
            {
                algorithm: fingerprint.type,
                value: fingerprint.hash,
            },
        ],
    };
    return dtlsParameters;
}
function getCname({ offerMediaObject, }) {
    const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === 'cname');
    if (!ssrcCnameLine) {
        return '';
    }
    return ssrcCnameLine.value;
}
/**
 * Apply codec parameters in the given SDP m= section answer based on the
 * given RTP parameters of an offer.
 */
function applyCodecParameters({ offerRtpParameters, answerMediaObject, }) {
    for (const codec of offerRtpParameters.codecs) {
        const mimeType = codec.mimeType.toLowerCase();
        // Avoid parsing codec parameters for unhandled codecs.
        if (mimeType !== 'audio/opus') {
            continue;
        }
        const rtp = (answerMediaObject.rtp ?? []).find((r) => r.payload === codec.payloadType);
        if (!rtp) {
            continue;
        }
        // Just in case.
        answerMediaObject.fmtp = answerMediaObject.fmtp ?? [];
        let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);
        if (!fmtp) {
            fmtp = { payload: codec.payloadType, config: '' };
            answerMediaObject.fmtp.push(fmtp);
        }
        const parameters = sdpTransform.parseParams(fmtp.config);
        switch (mimeType) {
            case 'audio/opus': {
                const spropStereo = codec.parameters?.['sprop-stereo'];
                if (spropStereo !== undefined) {
                    parameters['stereo'] = Number(spropStereo) ? 1 : 0;
                }
                break;
            }
        }
        // Write the codec fmtp.config back.
        fmtp.config = '';
        for (const key of Object.keys(parameters)) {
            if (fmtp.config) {
                fmtp.config += ';';
            }
            fmtp.config += `${key}=${parameters[key]}`;
        }
    }
}


/***/ }),

/***/ 5546:
/***/ ((module) => {

function _regeneratorDefine(e, r, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e) {
    i = 0;
  }
  module.exports = _regeneratorDefine = function regeneratorDefine(e, r, n, t) {
    function o(r, n) {
      _regeneratorDefine(e, r, function (e) {
        return this._invoke(r, n, e);
      });
    }
    r ? i ? i(e, r, {
      value: n,
      enumerable: !t,
      configurable: !t,
      writable: !t
    }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine(e, r, n, t);
}
module.exports = _regeneratorDefine, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 5601:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transport = void 0;
const awaitqueue_1 = __webpack_require__(8876);
const Logger_1 = __webpack_require__(2994);
const enhancedEvents_1 = __webpack_require__(3953);
const errors_1 = __webpack_require__(4893);
const utils = __webpack_require__(1765);
const ortc = __webpack_require__(8046);
const Producer_1 = __webpack_require__(9792);
const Consumer_1 = __webpack_require__(3518);
const DataProducer_1 = __webpack_require__(7504);
const DataConsumer_1 = __webpack_require__(9166);
const logger = new Logger_1.Logger('Transport');
class ConsumerCreationTask {
    consumerOptions;
    promise;
    resolve;
    reject;
    constructor(consumerOptions) {
        this.consumerOptions = consumerOptions;
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
class Transport extends enhancedEvents_1.EnhancedEventEmitter {
    // Id.
    _id;
    // Closed flag.
    _closed = false;
    // Direction.
    _direction;
    // Callback for sending Transports to request sending extended RTP capabilities
    // on demand.
    _getSendExtendedRtpCapabilities;
    // Recv RTP capabilities.
    _recvRtpCapabilities;
    // Whether we can produce audio/video based on computed extended RTP
    // capabilities.
    _canProduceByKind;
    // SCTP max message size if enabled, null otherwise.
    _maxSctpMessageSize;
    // RTC handler isntance.
    _handler;
    // Transport ICE gathering state.
    _iceGatheringState = 'new';
    // Transport connection state.
    _connectionState = 'new';
    // App custom data.
    _appData;
    // Map of Producers indexed by id.
    _producers = new Map();
    // Map of Consumers indexed by id.
    _consumers = new Map();
    // Map of DataProducers indexed by id.
    _dataProducers = new Map();
    // Map of DataConsumers indexed by id.
    _dataConsumers = new Map();
    // Whether the Consumer for RTP probation has been created.
    _probatorConsumerCreated = false;
    // AwaitQueue instance to make async tasks happen sequentially.
    _awaitQueue = new awaitqueue_1.AwaitQueue();
    // Consumer creation tasks awaiting to be processed.
    _pendingConsumerTasks = [];
    // Consumer creation in progress flag.
    _consumerCreationInProgress = false;
    // Consumers pending to be paused.
    _pendingPauseConsumers = new Map();
    // Consumer pause in progress flag.
    _consumerPauseInProgress = false;
    // Consumers pending to be resumed.
    _pendingResumeConsumers = new Map();
    // Consumer resume in progress flag.
    _consumerResumeInProgress = false;
    // Consumers pending to be closed.
    _pendingCloseConsumers = new Map();
    // Consumer close in progress flag.
    _consumerCloseInProgress = false;
    // Observer instance.
    _observer = new enhancedEvents_1.EnhancedEventEmitter();
    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData, handlerFactory, getSendExtendedRtpCapabilities, recvRtpCapabilities, canProduceByKind, }) {
        super();
        logger.debug('constructor() [id:%s, direction:%s]', id, direction);
        this._id = id;
        this._direction = direction;
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        this._recvRtpCapabilities = recvRtpCapabilities;
        this._canProduceByKind = canProduceByKind;
        this._maxSctpMessageSize = sctpParameters
            ? sctpParameters.maxMessageSize
            : null;
        // Clone and sanitize additionalSettings.
        const clonedAdditionalSettings = utils.clone(additionalSettings) ?? {};
        delete clonedAdditionalSettings.iceServers;
        delete clonedAdditionalSettings.iceTransportPolicy;
        delete clonedAdditionalSettings.bundlePolicy;
        delete clonedAdditionalSettings.rtcpMuxPolicy;
        this._handler = handlerFactory.factory({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings: clonedAdditionalSettings,
            getSendExtendedRtpCapabilities: this._getSendExtendedRtpCapabilities,
        });
        this._appData = appData ?? {};
        this.handleHandler();
    }
    /**
     * Transport id.
     */
    get id() {
        return this._id;
    }
    /**
     * Whether the Transport is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Transport direction.
     */
    get direction() {
        return this._direction;
    }
    /**
     * RTC handler instance.
     */
    get handler() {
        return this._handler;
    }
    /**
     * ICE gathering state.
     */
    get iceGatheringState() {
        return this._iceGatheringState;
    }
    /**
     * Connection state.
     */
    get connectionState() {
        return this._connectionState;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Close the Transport.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        // Stop the AwaitQueue.
        this._awaitQueue.stop();
        // Close the handler.
        this._handler.close();
        // Change connection state to 'closed' since the handler may not emit
        // '@connectionstatechange' event.
        this._connectionState = 'closed';
        // Close all Producers.
        for (const producer of this._producers.values()) {
            producer.transportClosed();
        }
        this._producers.clear();
        // Close all Consumers.
        for (const consumer of this._consumers.values()) {
            consumer.transportClosed();
        }
        this._consumers.clear();
        // Close all DataProducers.
        for (const dataProducer of this._dataProducers.values()) {
            dataProducer.transportClosed();
        }
        this._dataProducers.clear();
        // Close all DataConsumers.
        for (const dataConsumer of this._dataConsumers.values()) {
            dataConsumer.transportClosed();
        }
        this._dataConsumers.clear();
        // Emit observer event.
        this._observer.safeEmit('close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
        this._observer.close();
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */
    async getStats() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        return this._handler.getTransportStats();
    }
    /**
     * Restart ICE connection.
     */
    async restartIce({ iceParameters, }) {
        logger.debug('restartIce()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (!iceParameters) {
            throw new TypeError('missing iceParameters');
        }
        // Enqueue command.
        return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), 'transport.restartIce()');
    }
    /**
     * Update ICE servers.
     */
    async updateIceServers({ iceServers, } = {}) {
        logger.debug('updateIceServers()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (!Array.isArray(iceServers)) {
            throw new TypeError('missing iceServers');
        }
        // Enqueue command.
        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');
    }
    /**
     * Create a Producer.
     */
    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, onRtpSender, appData = {}, } = {}) {
        logger.debug('produce() [track:%o]', track);
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (!track) {
            throw new TypeError('missing track');
        }
        else if (this._direction !== 'send') {
            throw new errors_1.UnsupportedError('not a sending Transport');
        }
        else if (!this._canProduceByKind[track.kind]) {
            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
        }
        else if (track.readyState === 'ended') {
            throw new errors_1.InvalidStateError('track ended');
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (this.listenerCount('produce') === 0) {
            throw new TypeError('no "produce" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Enqueue command.
        return (this._awaitQueue
            .push(async () => {
            let normalizedEncodings;
            if (encodings && !Array.isArray(encodings)) {
                throw TypeError('encodings must be an array');
            }
            else if (encodings && encodings.length === 0) {
                normalizedEncodings = undefined;
            }
            else if (encodings) {
                normalizedEncodings = encodings.map(encoding => {
                    const normalizedEncoding = {
                        active: true,
                    };
                    if (encoding.active === false) {
                        normalizedEncoding.active = false;
                    }
                    if (typeof encoding.dtx === 'boolean') {
                        normalizedEncoding.dtx = encoding.dtx;
                    }
                    if (typeof encoding.scalabilityMode === 'string') {
                        normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                    }
                    if (typeof encoding.scaleResolutionDownBy === 'number') {
                        normalizedEncoding.scaleResolutionDownBy =
                            encoding.scaleResolutionDownBy;
                    }
                    if (typeof encoding.maxBitrate === 'number') {
                        normalizedEncoding.maxBitrate = encoding.maxBitrate;
                    }
                    if (typeof encoding.maxFramerate === 'number') {
                        normalizedEncoding.maxFramerate = encoding.maxFramerate;
                    }
                    if (typeof encoding.adaptivePtime === 'boolean') {
                        normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                    }
                    if (typeof encoding.priority === 'string') {
                        normalizedEncoding.priority = encoding.priority;
                    }
                    if (typeof encoding.networkPriority === 'string') {
                        normalizedEncoding.networkPriority = encoding.networkPriority;
                    }
                    return normalizedEncoding;
                });
            }
            const { localId, rtpParameters, rtpSender } = await this._handler.send({
                track,
                encodings: normalizedEncodings,
                codecOptions,
                codec,
                onRtpSender,
            });
            try {
                // This will fill rtpParameters's missing fields with default values.
                ortc.validateAndNormalizeRtpParameters(rtpParameters);
                const { id } = await new Promise((resolve, reject) => {
                    this.safeEmit('produce', {
                        kind: track.kind,
                        rtpParameters,
                        appData,
                    }, resolve, reject);
                });
                const producer = new Producer_1.Producer({
                    id,
                    localId,
                    rtpSender,
                    track,
                    rtpParameters,
                    stopTracks,
                    disableTrackOnPause,
                    zeroRtpOnPause,
                    appData,
                });
                this._producers.set(producer.id, producer);
                this.handleProducer(producer);
                // Emit observer event.
                this._observer.safeEmit('newproducer', producer);
                return producer;
            }
            catch (error) {
                this._handler.stopSending(localId).catch(() => { });
                throw error;
            }
        }, 'transport.produce()')
            // This catch is needed to stop the given track if the command above
            // failed due to closed Transport.
            .catch((error) => {
            if (stopTracks) {
                try {
                    track.stop();
                }
                catch (error2) { }
            }
            throw error;
        }));
    }
    /**
     * Create a Consumer to consume a remote Producer.
     */
    async consume({ id, producerId, kind, rtpParameters, streamId, onRtpReceiver, appData = {}, }) {
        logger.debug('consume()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._direction !== 'recv') {
            throw new errors_1.UnsupportedError('not a receiving Transport');
        }
        else if (typeof id !== 'string') {
            throw new TypeError('missing id');
        }
        else if (typeof producerId !== 'string') {
            throw new TypeError('missing producerId');
        }
        else if (kind !== 'audio' && kind !== 'video') {
            throw new TypeError(`invalid kind '${kind}'`);
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Clone given RTP parameters to not modify input data.
        const clonedRtpParameters = utils.clone(rtpParameters);
        // Ensure the device can consume it.
        const canConsume = ortc.canReceive(clonedRtpParameters, this._recvRtpCapabilities);
        if (!canConsume) {
            throw new errors_1.UnsupportedError('cannot consume this Producer');
        }
        const consumerCreationTask = new ConsumerCreationTask({
            id,
            producerId,
            kind,
            rtpParameters: clonedRtpParameters,
            streamId,
            onRtpReceiver,
            appData,
        });
        // Store the Consumer creation task.
        this._pendingConsumerTasks.push(consumerCreationTask);
        // There is no Consumer creation in progress, create it now.
        queueMicrotask(() => {
            if (this._closed) {
                return;
            }
            if (this._consumerCreationInProgress === false) {
                this.createPendingConsumers();
            }
        });
        return consumerCreationTask.promise;
    }
    /**
     * Create a DataProducer
     */
    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = '', protocol = '', appData = {}, } = {}) {
        logger.debug('produceData()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._direction !== 'send') {
            throw new errors_1.UnsupportedError('not a sending Transport');
        }
        else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (this.listenerCount('producedata') === 0) {
            throw new TypeError('no "producedata" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        if (maxPacketLifeTime || maxRetransmits) {
            ordered = false;
        }
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
                ordered,
                maxPacketLifeTime,
                maxRetransmits,
                label,
                protocol,
            });
            // This will fill sctpStreamParameters's missing fields with default values.
            ortc.validateAndNormalizeSctpStreamParameters(sctpStreamParameters);
            const { id } = await new Promise((resolve, reject) => {
                this.safeEmit('producedata', {
                    sctpStreamParameters,
                    label,
                    protocol,
                    appData,
                }, resolve, reject);
            });
            const dataProducer = new DataProducer_1.DataProducer({
                id,
                dataChannel,
                sctpStreamParameters,
                appData,
            });
            this._dataProducers.set(dataProducer.id, dataProducer);
            this.handleDataProducer(dataProducer);
            // Emit observer event.
            this._observer.safeEmit('newdataproducer', dataProducer);
            return dataProducer;
        }, 'transport.produceData()');
    }
    /**
     * Create a DataConsumer
     */
    async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {}, }) {
        logger.debug('consumeData()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._direction !== 'recv') {
            throw new errors_1.UnsupportedError('not a receiving Transport');
        }
        else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
        }
        else if (typeof id !== 'string') {
            throw new TypeError('missing id');
        }
        else if (typeof dataProducerId !== 'string') {
            throw new TypeError('missing dataProducerId');
        }
        else if (this.listenerCount('connect') === 0 &&
            this._connectionState === 'new') {
            throw new TypeError('no "connect" listener set into this transport');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Clone given SCTP stream parameters to not modify input data.
        const clonedSctpStreamParameters = utils.clone(sctpStreamParameters);
        // This may throw.
        ortc.validateAndNormalizeSctpStreamParameters(clonedSctpStreamParameters);
        // Enqueue command.
        return this._awaitQueue.push(async () => {
            const { dataChannel } = await this._handler.receiveDataChannel({
                sctpStreamParameters: clonedSctpStreamParameters,
                label,
                protocol,
            });
            const dataConsumer = new DataConsumer_1.DataConsumer({
                id,
                dataProducerId,
                dataChannel,
                sctpStreamParameters: clonedSctpStreamParameters,
                appData,
            });
            this._dataConsumers.set(dataConsumer.id, dataConsumer);
            this.handleDataConsumer(dataConsumer);
            // Emit observer event.
            this._observer.safeEmit('newdataconsumer', dataConsumer);
            return dataConsumer;
        }, 'transport.consumeData()');
    }
    // This method is guaranteed to never throw.
    createPendingConsumers() {
        this._consumerCreationInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingConsumerTasks.length === 0) {
                logger.debug('createPendingConsumers() | there is no Consumer to be created');
                return;
            }
            const pendingConsumerTasks = [...this._pendingConsumerTasks];
            // Clear pending Consumer tasks.
            this._pendingConsumerTasks = [];
            // Video Consumer in order to create the probator.
            let videoConsumerForProbator = undefined;
            // Fill options list.
            const optionsList = [];
            for (const task of pendingConsumerTasks) {
                const { id, kind, rtpParameters, streamId, onRtpReceiver } = task.consumerOptions;
                optionsList.push({
                    trackId: id,
                    kind: kind,
                    rtpParameters,
                    streamId,
                    onRtpReceiver,
                });
            }
            try {
                const results = await this._handler.receive(optionsList);
                for (let idx = 0; idx < results.length; ++idx) {
                    const task = pendingConsumerTasks[idx];
                    const result = results[idx];
                    const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;
                    const { localId, rtpReceiver, track } = result;
                    const consumer = new Consumer_1.Consumer({
                        id: id,
                        localId,
                        producerId: producerId,
                        rtpReceiver,
                        track,
                        rtpParameters,
                        appData: appData,
                    });
                    this._consumers.set(consumer.id, consumer);
                    this.handleConsumer(consumer);
                    // If this is the first video Consumer and the Consumer for RTP probation
                    // has not yet been created, it's time to create it.
                    if (!this._probatorConsumerCreated &&
                        !videoConsumerForProbator &&
                        kind === 'video') {
                        videoConsumerForProbator = consumer;
                    }
                    // Emit observer event.
                    this._observer.safeEmit('newconsumer', consumer);
                    task.resolve(consumer);
                }
            }
            catch (error) {
                for (const task of pendingConsumerTasks) {
                    task.reject(error);
                }
            }
            // If RTP probation must be handled, do it now.
            if (videoConsumerForProbator) {
                try {
                    const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
                    await this._handler.receive([
                        {
                            trackId: 'probator',
                            kind: 'video',
                            rtpParameters: probatorRtpParameters,
                        },
                    ]);
                    logger.debug('createPendingConsumers() | Consumer for RTP probation created');
                    this._probatorConsumerCreated = true;
                }
                catch (error) {
                    logger.error('createPendingConsumers() | failed to create Consumer for RTP probation:%o', error);
                }
            }
        }, 'transport.createPendingConsumers()')
            .then(() => {
            this._consumerCreationInProgress = false;
            // There are pending Consumer tasks, enqueue their creation.
            if (this._pendingConsumerTasks.length > 0) {
                this.createPendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    pausePendingConsumers() {
        this._consumerPauseInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingPauseConsumers.size === 0) {
                logger.debug('pausePendingConsumers() | there is no Consumer to be paused');
                return;
            }
            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
            // Clear pending pause Consumer map.
            this._pendingPauseConsumers.clear();
            try {
                const localIds = pendingPauseConsumers.map(consumer => consumer.localId);
                await this._handler.pauseReceiving(localIds);
            }
            catch (error) {
                logger.error('pausePendingConsumers() | failed to pause Consumers:', error);
            }
        }, 'transport.pausePendingConsumers')
            .then(() => {
            this._consumerPauseInProgress = false;
            // There are pending Consumers to be paused, do it.
            if (this._pendingPauseConsumers.size > 0) {
                this.pausePendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    resumePendingConsumers() {
        this._consumerResumeInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingResumeConsumers.size === 0) {
                logger.debug('resumePendingConsumers() | there is no Consumer to be resumed');
                return;
            }
            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
            // Clear pending resume Consumer map.
            this._pendingResumeConsumers.clear();
            try {
                const localIds = pendingResumeConsumers.map(consumer => consumer.localId);
                await this._handler.resumeReceiving(localIds);
            }
            catch (error) {
                logger.error('resumePendingConsumers() | failed to resume Consumers:', error);
            }
        }, 'transport.resumePendingConsumers')
            .then(() => {
            this._consumerResumeInProgress = false;
            // There are pending Consumer to be resumed, do it.
            if (this._pendingResumeConsumers.size > 0) {
                this.resumePendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    closePendingConsumers() {
        this._consumerCloseInProgress = true;
        this._awaitQueue
            .push(async () => {
            if (this._pendingCloseConsumers.size === 0) {
                logger.debug('closePendingConsumers() | there is no Consumer to be closed');
                return;
            }
            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
            // Clear pending close Consumer map.
            this._pendingCloseConsumers.clear();
            try {
                await this._handler.stopReceiving(pendingCloseConsumers.map(consumer => consumer.localId));
            }
            catch (error) {
                logger.error('closePendingConsumers() | failed to close Consumers:', error);
            }
        }, 'transport.closePendingConsumers')
            .then(() => {
            this._consumerCloseInProgress = false;
            // There are pending Consumer to be resumed, do it.
            if (this._pendingCloseConsumers.size > 0) {
                this.closePendingConsumers();
            }
        })
            // NOTE: We only get here when the await queue is closed.
            .catch(() => { });
    }
    handleHandler() {
        const handler = this._handler;
        handler.on('@connect', ({ dtlsParameters }, callback, errback) => {
            if (this._closed) {
                errback(new errors_1.InvalidStateError('closed'));
                return;
            }
            this.safeEmit('connect', { dtlsParameters }, callback, errback);
        });
        handler.on('@icegatheringstatechange', (iceGatheringState) => {
            if (iceGatheringState === this._iceGatheringState) {
                return;
            }
            logger.debug('ICE gathering state changed to %s', iceGatheringState);
            this._iceGatheringState = iceGatheringState;
            if (!this._closed) {
                this.safeEmit('icegatheringstatechange', iceGatheringState);
            }
        });
        handler.on('@icecandidateerror', (event) => {
            logger.warn(`ICE candidate error [url:${event.url}, localAddress:${event.address}, localPort:${event.port}]: ${event.errorCode} "${event.errorText}"`);
            this.safeEmit('icecandidateerror', event);
        });
        handler.on('@connectionstatechange', (connectionState) => {
            if (connectionState === this._connectionState) {
                return;
            }
            logger.debug('connection state changed to %s', connectionState);
            this._connectionState = connectionState;
            if (!this._closed) {
                this.safeEmit('connectionstatechange', connectionState);
            }
        });
    }
    handleProducer(producer) {
        producer.on('@close', () => {
            this._producers.delete(producer.id);
            if (this._closed) {
                return;
            }
            this._awaitQueue
                .push(async () => await this._handler.stopSending(producer.localId), 'producer @close event')
                .catch((error) => logger.warn('producer.close() failed:%o', error));
        });
        producer.on('@pause', (callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.pauseSending(producer.localId), 'producer @pause event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@resume', (callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.resumeSending(producer.localId), 'producer @resume event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@replacetrack', (track, callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), 'producer @setmaxspatiallayer event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@setrtpencodingparameters', (params, callback, errback) => {
            this._awaitQueue
                .push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), 'producer @setrtpencodingparameters event')
                .then(callback)
                .catch(errback);
        });
        producer.on('@getstats', (callback, errback) => {
            if (this._closed) {
                return errback(new errors_1.InvalidStateError('closed'));
            }
            this._handler
                .getSenderStats(producer.localId)
                .then(callback)
                .catch(errback);
        });
    }
    handleConsumer(consumer) {
        consumer.on('@close', () => {
            this._consumers.delete(consumer.id);
            this._pendingPauseConsumers.delete(consumer.id);
            this._pendingResumeConsumers.delete(consumer.id);
            if (this._closed) {
                return;
            }
            // Store the Consumer into the close list.
            this._pendingCloseConsumers.set(consumer.id, consumer);
            // There is no Consumer close in progress, do it now.
            if (this._consumerCloseInProgress === false) {
                this.closePendingConsumers();
            }
        });
        consumer.on('@pause', () => {
            // If Consumer is pending to be resumed, remove from pending resume list.
            if (this._pendingResumeConsumers.has(consumer.id)) {
                this._pendingResumeConsumers.delete(consumer.id);
            }
            // Store the Consumer into the pending list.
            this._pendingPauseConsumers.set(consumer.id, consumer);
            // There is no Consumer pause in progress, do it now.
            queueMicrotask(() => {
                if (this._closed) {
                    return;
                }
                if (this._consumerPauseInProgress === false) {
                    this.pausePendingConsumers();
                }
            });
        });
        consumer.on('@resume', () => {
            // If Consumer is pending to be paused, remove from pending pause list.
            if (this._pendingPauseConsumers.has(consumer.id)) {
                this._pendingPauseConsumers.delete(consumer.id);
            }
            // Store the Consumer into the pending list.
            this._pendingResumeConsumers.set(consumer.id, consumer);
            // There is no Consumer resume in progress, do it now.
            queueMicrotask(() => {
                if (this._closed) {
                    return;
                }
                if (this._consumerResumeInProgress === false) {
                    this.resumePendingConsumers();
                }
            });
        });
        consumer.on('@getstats', (callback, errback) => {
            if (this._closed) {
                return errback(new errors_1.InvalidStateError('closed'));
            }
            this._handler
                .getReceiverStats(consumer.localId)
                .then(callback)
                .catch(errback);
        });
    }
    handleDataProducer(dataProducer) {
        dataProducer.on('@close', () => {
            this._dataProducers.delete(dataProducer.id);
        });
    }
    handleDataConsumer(dataConsumer) {
        dataConsumer.on('@close', () => {
            this._dataConsumers.delete(dataConsumer.id);
        });
    }
}
exports.Transport = Transport;


/***/ }),

/***/ 5602:
/***/ ((module) => {

var grammar = module.exports = {
  v: [{
    name: 'version',
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: '%s %s %d %s IP%d %s'
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: '%d %d'
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: 'connection',
    reg: /^IN IP(\d) (\S*)/,
    names: ['version', 'ip'],
    format: 'IN IP%d %s'
  }],
  b: [{
    // b=AS:4000
    push: 'bandwidth',
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ['type', 'limit'],
    format: '%s:%s'
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ['type', 'port', 'protocol', 'payloads'],
    format: '%s %d %s %s'
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding)
          ? 'rtpmap:%d %s/%s/%s'
          : o.rate
            ? 'rtpmap:%d %s/%s'
            : 'rtpmap:%d %s';
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: 'fmtp',
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ['payload', 'config'],
      format: 'fmtp:%d %s'
    },
    {
      // a=control:streamid=0
      name: 'control',
      reg: /^control:(.*)/,
      format: 'control:%s'
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null)
          ? 'rtcp:%d %s IP%d %s'
          : 'rtcp:%d';
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: 'rtcp-fb:%s trr-int %d'
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null)
          ? 'rtcp-fb:%s %s %s'
          : 'rtcp-fb:%s %s';
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: 'ext',
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
      format: function (o) {
        return (
          'extmap:%d' +
          (o.direction ? '/%s' : '%v') +
          (o['encrypt-uri'] ? ' %s' : '%v') +
          ' %s' +
          (o.config ? ' %s' : '')
        );
      }
    },
    {
      // a=extmap-allow-mixed
      name: 'extmapAllowMixed',
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null)
          ? 'crypto:%d %s %s %s'
          : 'crypto:%d %s %s';
      }
    },
    {
      // a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: 'setup:%s'
    },
    {
      // a=connection:new
      name: 'connectionType',
      reg: /^connection:(new|existing)/,
      format: 'connection:%s'
    },
    {
      // a=mid:1
      name: 'mid',
      reg: /^mid:([^\s]*)/,
      format: 'mid:%s'
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: 'msid',
      reg: /^msid:(.*)/,
      format: 'msid:%s'
    },
    {
      // a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: 'ptime:%d'
    },
    {
      // a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: 'maxptime:%d'
    },
    {
      // a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: 'icelite',
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: 'ice-ufrag:%s'
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: 'ice-pwd:%s'
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: 'fingerprint:%s %s'
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
      format: function (o) {
        var str = 'candidate:%s %d %s %d %s %d typ %s';

        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

        // NB: candidate has three optional chunks, so %void middles one if it's missing
        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

        if (o.generation != null) {
          str += ' generation %d';
        }

        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
        return str;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: 'endOfCandidates',
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: 'remote-candidates:%s'
    },
    {
      // a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: 'ice-options:%s'
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: 'ssrcs',
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ['id', 'attribute', 'value'],
      format: function (o) {
        var str = 'ssrc:%d';
        if (o.attribute != null) {
          str += ' %s';
          if (o.value != null) {
            str += ':%s';
          }
        }
        return str;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: 'ssrcGroups',
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ['semantics', 'ssrcs'],
      format: 'ssrc-group:%s %s'
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: 'msidSemantic',
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: 'msid-semantic: %s %s' // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: 'group:%s %s'
    },
    {
      // a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: 'rtcpRsize',
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: 'sctpmap',
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
      format: function (o) {
        return (o.maxMessageSize != null)
          ? 'sctpmap:%s %s %s'
          : 'sctpmap:%s %s';
      }
    },
    {
      // a=x-google-flag:conference
      name: 'xGoogleFlag',
      reg: /^x-google-flag:([^\s]*)/,
      format: 'x-google-flag:%s'
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: 'rids',
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ['id', 'direction', 'params'],
      format: function (o) {
        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: 'imageattrs',
      reg: new RegExp(
        // a=imageattr:97
        '^imageattr:(\\d+|\\*)' +
        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
        // recv [x=330,y=250]
        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
      ),
      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
      format: function (o) {
        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: 'simulcast',
      reg: new RegExp(
        // a=simulcast:
        '^simulcast:' +
        // send 1,2,3;~4,~5
        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
        // space + recv 6;~7,~8
        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
        // end
        '$'
      ),
      names: ['dir1', 'list1', 'dir2', 'list2'],
      format: function (o) {
        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: 'simulcast_03',
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ['value'],
      format: 'simulcast: %s'
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: 'framerate',
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: 'framerate:%s'
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: 'sourceFilter',
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
      format: 'source-filter: %s %s %s %s %s'
    },
    {
      // a=bundle-only
      name: 'bundleOnly',
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: 'label',
      reg: /^label:(.+)/,
      format: 'label:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: 'sctpPort',
      reg: /^sctp-port:(\d+)$/,
      format: 'sctp-port:%s'
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: 'maxMessageSize',
      reg: /^max-message-size:(\d+)$/,
      format: 'max-message-size:%s'
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push:'tsRefClocks',
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ['clksrc', 'clksrcExt'],
      format: function (o) {
        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name:'mediaClk',
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
      format: function (o) {
        var str = 'mediaclk:';
        str += (o.id != null ? 'id=%s %s' : '%v%s');
        str += (o.mediaClockValue != null ? '=%s' : '');
        str += (o.rateNumerator != null ? ' rate=%s' : '');
        str += (o.rateDenominator != null ? '/%s' : '');
        return str;
      }
    },
    {
      // a=keywds:keywords
      name: 'keywords',
      reg: /^keywds:(.+)$/,
      format: 'keywds:%s'
    },
    {
      // a=content:main
      name: 'content',
      reg: /^content:(.+)/,
      format: 'content:%s'
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: 'bfcpFloorCtrl',
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: 'floorctrl:%s'
    },
    {
      // a=confid:1
      name: 'bfcpConfId',
      reg: /^confid:(\d+)/,
      format: 'confid:%s'
    },
    {
      // a=userid:1
      name: 'bfcpUserId',
      reg: /^userid:(\d+)/,
      format: 'userid:%s'
    },
    {
      // a=floorid:1
      name: 'bfcpFloorId',
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ['id', 'mStream'],
      format: 'floorid:%s mstrm:%s'
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: 'invalid',
      names: ['value']
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = '%s';
    }
  });
});


/***/ }),

/***/ 5765:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Safari12 = void 0;
const sdpTransform = __webpack_require__(7363);
const enhancedEvents_1 = __webpack_require__(3953);
const Logger_1 = __webpack_require__(2994);
const ortc = __webpack_require__(8046);
const errors_1 = __webpack_require__(4893);
const scalabilityModes_1 = __webpack_require__(3303);
const RemoteSdp_1 = __webpack_require__(1305);
const sdpCommonUtils = __webpack_require__(5544);
const sdpUnifiedPlanUtils = __webpack_require__(5938);
const ortcUtils = __webpack_require__(4256);
const logger = new Logger_1.Logger('Safari12');
const NAME = 'Safari12';
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Safari12 extends enhancedEvents_1.EnhancedEventEmitter {
    // Closed flag.
    _closed = false;
    // Handler direction.
    _direction;
    // Remote SDP handler.
    _remoteSdp;
    // Callback to request sending extended RTP capabilities on demand.
    _getSendExtendedRtpCapabilities;
    // Initial server side DTLS role. If not 'auto', it will force the opposite
    // value in client side.
    _forcedLocalDtlsRole;
    // RTCPeerConnection instance.
    _pc;
    // Map of RTCTransceivers indexed by MID.
    _mapMidTransceiver = new Map();
    // Local stream for sending.
    _sendStream = new MediaStream();
    // Whether a DataChannel m=application section has been created.
    _hasDataChannelMediaSection = false;
    // Sending DataChannel id value counter. Incremented for each new DataChannel.
    _nextSendSctpStreamId = 0;
    // Got transport local and remote parameters.
    _transportReady = false;
    /**
     * Creates a factory function.
     */
    static createFactory() {
        return {
            name: NAME,
            factory: (options) => new Safari12(options),
            getNativeRtpCapabilities: async () => {
                logger.debug('getNativeRtpCapabilities()');
                let pc = new RTCPeerConnection({
                    iceServers: [],
                    iceTransportPolicy: 'all',
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require',
                });
                try {
                    pc.addTransceiver('audio');
                    pc.addTransceiver('video');
                    const offer = await pc.createOffer();
                    try {
                        pc.close();
                    }
                    catch (error) { }
                    pc = undefined;
                    const sdpObject = sdpTransform.parse(offer.sdp);
                    const nativeRtpCapabilities = Safari12.getLocalRtpCapabilities(sdpObject);
                    return nativeRtpCapabilities;
                }
                catch (error) {
                    try {
                        pc?.close();
                    }
                    catch (error2) { }
                    pc = undefined;
                    throw error;
                }
            },
            getNativeSctpCapabilities: async () => {
                logger.debug('getNativeSctpCapabilities()');
                return {
                    numStreams: SCTP_NUM_STREAMS,
                };
            },
        };
    }
    static getLocalRtpCapabilities(localSdpObject) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
            sdpObject: localSdpObject,
        });
        // Need to validate and normalize native RTP capabilities.
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        // libwebrtc supports NACK for OPUS but doesn't announce it.
        ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
        return nativeRtpCapabilities;
    }
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities, }) {
        super();
        logger.debug('constructor()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        if (dtlsParameters.role && dtlsParameters.role !== 'auto') {
            this._forcedLocalDtlsRole =
                dtlsParameters.role === 'server' ? 'client' : 'server';
        }
        this._pc = new RTCPeerConnection({
            iceServers: iceServers ?? [],
            iceTransportPolicy: iceTransportPolicy ?? 'all',
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            ...additionalSettings,
        });
        this._pc.addEventListener('icegatheringstatechange', () => {
            this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
        });
        this._pc.addEventListener('icecandidateerror', (event) => {
            this.emit('@icecandidateerror', event);
        });
        this._pc.addEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.addEventListener('icecandidateerror', this.onIceCandidateError);
        if (this._pc.connectionState) {
            this._pc.addEventListener('connectionstatechange', this.onConnectionStateChange);
        }
        else {
            logger.warn('run() | pc.connectionState not supported, using pc.iceConnectionState');
            this._pc.addEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        }
    }
    get name() {
        return NAME;
    }
    close() {
        logger.debug('close()');
        if (this._closed) {
            return;
        }
        this._closed = true;
        // Close RTCPeerConnection.
        try {
            this._pc.close();
        }
        catch (error) { }
        this._pc.removeEventListener('icegatheringstatechange', this.onIceGatheringStateChange);
        this._pc.removeEventListener('icecandidateerror', this.onIceCandidateError);
        this._pc.removeEventListener('connectionstatechange', this.onConnectionStateChange);
        this._pc.removeEventListener('iceconnectionstatechange', this.onIceConnectionStateChange);
        this.emit('@close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
    }
    async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug('updateIceServers()');
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug('restartIce()');
        // Provide the remote SDP handler with new remote ICE parameters.
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
            return;
        }
        if (this._direction === 'send') {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
        }
        else {
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
        }
    }
    async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
            direction: 'sendonly',
            streams: [this._sendStream],
        });
        if (onRtpSender) {
            onRtpSender(transceiver.sender);
        }
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
            this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const nativeRtpCapabilities = Safari12.getLocalRtpCapabilities(localSdpObject);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        // Generic sending RTP parameters.
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        // Generic sending RTP parameters suitable for the SDP remote answer.
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        // This may throw.
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        let offerMediaObject;
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings && encodings.length > 1) {
            logger.debug('send() | enabling legacy simulcast');
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
                offerMediaObject,
                numStreams: encodings.length,
            });
            offer = {
                type: 'offer',
                sdp: sdpTransform.write(localSdpObject),
            };
        }
        logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        // We can now get the transceiver.mid.
        const localId = transceiver.mid;
        // Set MID.
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        // Set RTCP CNAME.
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject,
        });
        // Set RTP encodings.
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
        });
        // Complete encodings with given values.
        if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                if (encodings[idx]) {
                    Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                }
            }
        }
        // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
        // each encoding.
        if (sendingRtpParameters.encodings.length > 1 &&
            (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
            for (const encoding of sendingRtpParameters.encodings) {
                if (encoding.scalabilityMode) {
                    encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                }
                else {
                    encoding.scalabilityMode = 'L1T3';
                }
            }
        }
        this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
        });
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender,
        };
    }
    async stopSending(localId) {
        this.assertSendDirection();
        if (this._closed) {
            return;
        }
        logger.debug('stopSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
            try {
                transceiver.stop();
            }
            catch (error) { }
        }
        const offer = await this._pc.createOffer();
        logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('pauseSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'inactive';
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('pauseSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('resumeSending() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        transceiver.direction = 'sendonly';
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug('resumeSending() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
            logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
        }
        else {
            logger.debug('replaceTrack() [localId:%s, no track]', localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
                encoding.active = true;
            }
            else {
                encoding.active = false;
            }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug('setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]', offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
            type: 'answer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]', answer);
        await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('sendDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // Increase next id.
        this._nextSendSctpStreamId =
            ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        // If this is the first DataChannel we need to create the SDP answer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find(m => m.type === 'application');
            if (!this._transportReady) {
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = {
                type: 'answer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits,
        };
        return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = new Map();
        for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
            const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
                mid: localId,
                kind,
                offerRtpParameters: rtpParameters,
                streamId: streamId ?? rtpParameters.rtcp.cname,
                trackId,
            });
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
            const { trackId, onRtpReceiver } = options;
            if (onRtpReceiver) {
                const localId = mapLocalId.get(trackId);
                const transceiver = this._pc
                    .getTransceivers()
                    .find((t) => t.mid === localId);
                if (!transceiver) {
                    throw new Error('transceiver not found');
                }
                onRtpReceiver(transceiver.receiver);
            }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find(m => String(m.mid) === localId);
            // May need to modify codec parameters in the answer based on codec
            // parameters in the offer.
            sdpCommonUtils.applyCodecParameters({
                offerRtpParameters: rtpParameters,
                answerMediaObject,
            });
        }
        answer = {
            type: 'answer',
            sdp: sdpTransform.write(localSdpObject),
        };
        if (!this._transportReady) {
            await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                localSdpObject,
            });
        }
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc
                .getTransceivers()
                .find((t) => t.mid === localId);
            if (!transceiver) {
                throw new Error('new RTCRtpTransceiver not found');
            }
            // Store in the map.
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver,
            });
        }
        return results;
    }
    async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
            return;
        }
        for (const localId of localIds) {
            logger.debug('stopReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
        }
    }
    async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('pauseReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'inactive';
            this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('pauseReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
            logger.debug('resumeReceiving() [localId:%s]', localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
                throw new Error('associated RTCRtpTransceiver not found');
            }
            transceiver.direction = 'recvonly';
            this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
            type: 'offer',
            sdp: this._remoteSdp.getSdp(),
        };
        logger.debug('resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('resumeReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
            throw new Error('associated RTCRtpTransceiver not found');
        }
        return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol, }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits, } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol,
        };
        logger.debug('receiveDataChannel() [options:%o]', options);
        const dataChannel = this._pc.createDataChannel(label, options);
        // If this is the first DataChannel we need to create the SDP offer with
        // m=application section.
        if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = {
                type: 'offer',
                sdp: this._remoteSdp.getSdp(),
            };
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
                const localSdpObject = sdpTransform.parse(answer.sdp);
                await this.setupTransport({
                    localDtlsRole: this._forcedLocalDtlsRole ?? 'client',
                    localSdpObject,
                });
            }
            logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject, }) {
        if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject,
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await new Promise((resolve, reject) => {
            this.safeEmit('@connect', { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
    }
    onIceGatheringStateChange = () => {
        this.emit('@icegatheringstatechange', this._pc.iceGatheringState);
    };
    onIceCandidateError = (event) => {
        this.emit('@icecandidateerror', event);
    };
    onConnectionStateChange = () => {
        this.emit('@connectionstatechange', this._pc.connectionState);
    };
    onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
            case 'checking': {
                this.emit('@connectionstatechange', 'connecting');
                break;
            }
            case 'connected':
            case 'completed': {
                this.emit('@connectionstatechange', 'connected');
                break;
            }
            case 'failed': {
                this.emit('@connectionstatechange', 'failed');
                break;
            }
            case 'disconnected': {
                this.emit('@connectionstatechange', 'disconnected');
                break;
            }
            case 'closed': {
                this.emit('@connectionstatechange', 'closed');
                break;
            }
        }
    };
    assertNotClosed() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('method called in a closed handler');
        }
    }
    assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Safari12 = Safari12;


/***/ }),

/***/ 5869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var regeneratorAsyncGen = __webpack_require__(887);
function _regeneratorAsync(n, e, r, t, o) {
  var a = regeneratorAsyncGen(n, e, r, t, o);
  return a.next().then(function (n) {
    return n.done ? n.value : a.next();
  });
}
module.exports = _regeneratorAsync, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 5935:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FakeEventTarget = void 0;
class FakeEventTarget {
    listeners = {};
    addEventListener(type, callback, options) {
        if (!callback) {
            return;
        }
        this.listeners[type] ??= [];
        this.listeners[type].push({
            callback: 
            // eslint-disable-next-line @typescript-eslint/unbound-method
            typeof callback === 'function' ? callback : callback.handleEvent,
            once: typeof options === 'object' && options.once === true,
        });
    }
    removeEventListener(type, callback, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    options) {
        if (!this.listeners[type]) {
            return;
        }
        if (!callback) {
            return;
        }
        this.listeners[type] = this.listeners[type].filter(listener => listener.callback !==
            // eslint-disable-next-line @typescript-eslint/unbound-method
            (typeof callback === 'function' ? callback : callback.handleEvent));
    }
    dispatchEvent(event) {
        if (!event || typeof event.type !== 'string') {
            throw new Error('invalid event object');
        }
        const entries = this.listeners[event.type];
        if (!entries) {
            return true;
        }
        for (const listener of [...entries]) {
            try {
                listener.callback.call(this, event);
            }
            catch (error) {
                // Avoid that the error breaks the iteration.
                setTimeout(() => {
                    throw error;
                }, 0);
            }
            if (listener.once) {
                this.removeEventListener(event.type, listener.callback);
            }
        }
        return !event.defaultPrevented;
    }
}
exports.FakeEventTarget = FakeEventTarget;


/***/ }),

/***/ 5938:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRtpEncodings = getRtpEncodings;
exports.addLegacySimulcast = addLegacySimulcast;
function getRtpEncodings({ offerMediaObject, }) {
    const ssrcs = new Set();
    for (const line of offerMediaObject.ssrcs ?? []) {
        const ssrc = line.id;
        if (ssrc) {
            ssrcs.add(ssrc);
        }
    }
    if (ssrcs.size === 0) {
        throw new Error('no a=ssrc lines found');
    }
    const ssrcToRtxSsrc = new Map();
    // First assume RTX is used.
    for (const line of offerMediaObject.ssrcGroups ?? []) {
        if (line.semantics !== 'FID') {
            continue;
        }
        const ssrcsStr = line.ssrcs.split(/\s+/);
        const ssrc = Number(ssrcsStr[0]);
        const rtxSsrc = Number(ssrcsStr[1]);
        if (ssrcs.has(ssrc)) {
            // Remove both the SSRC and RTX SSRC from the set so later we know
            // that they are already handled.
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            // Add to the map.
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
    }
    // If the set of SSRCs is not empty it means that RTX is not being used, so
    // take media SSRCs from there.
    for (const ssrc of ssrcs) {
        // Add to the map.
        ssrcToRtxSsrc.set(ssrc, undefined);
    }
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
        const encoding = { ssrc };
        if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
        }
        encodings.push(encoding);
    }
    return encodings;
}
/**
 * Adds multi-ssrc based simulcast into the given SDP media section offer.
 */
function addLegacySimulcast({ offerMediaObject, numStreams, }) {
    if (numStreams <= 1) {
        throw new TypeError('numStreams must be greater than 1');
    }
    // Get the SSRC.
    const ssrcMsidLine = (offerMediaObject.ssrcs ?? []).find(line => line.attribute === 'msid');
    if (!ssrcMsidLine) {
        throw new Error('a=ssrc line with msid information not found');
    }
    const [streamId, trackId] = ssrcMsidLine.value.split(' ');
    const firstSsrc = Number(ssrcMsidLine.id);
    let firstRtxSsrc;
    // Get the SSRC for RTX.
    (offerMediaObject.ssrcGroups ?? []).some(line => {
        if (line.semantics !== 'FID') {
            return false;
        }
        const ssrcs = line.ssrcs.split(/\s+/);
        if (Number(ssrcs[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs[1]);
            return true;
        }
        else {
            return false;
        }
    });
    const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find(line => line.attribute === 'cname');
    if (!ssrcCnameLine) {
        throw new Error('a=ssrc line with cname information not found');
    }
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for (let i = 0; i < numStreams; ++i) {
        ssrcs.push(firstSsrc + i);
        if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
        }
    }
    offerMediaObject.ssrcGroups = [];
    offerMediaObject.ssrcs = [];
    offerMediaObject.ssrcGroups.push({
        semantics: 'SIM',
        ssrcs: ssrcs.join(' '),
    });
    for (const ssrc of ssrcs) {
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: 'msid',
            value: `${streamId} ${trackId}`,
        });
    }
    for (let i = 0; i < rtxSsrcs.length; ++i) {
        const ssrc = ssrcs[i];
        const rtxSsrc = rtxSsrcs[i];
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'cname',
            value: cname,
        });
        offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: 'msid',
            value: `${streamId} ${trackId}`,
        });
        offerMediaObject.ssrcGroups.push({
            semantics: 'FID',
            ssrcs: `${ssrc} ${rtxSsrc}`,
        });
    }
}


/***/ }),

/***/ 5953:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3240));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    var tMsw;
	                    var tLsw;

	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));

/***/ }),

/***/ 6004:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Device = void 0;
exports.detectDeviceAsync = detectDeviceAsync;
exports.detectDevice = detectDevice;
const ua_parser_js_1 = __webpack_require__(2109);
const Logger_1 = __webpack_require__(2994);
const enhancedEvents_1 = __webpack_require__(3953);
const errors_1 = __webpack_require__(4893);
const utils = __webpack_require__(1765);
const ortc = __webpack_require__(8046);
const Transport_1 = __webpack_require__(5601);
const Chrome111_1 = __webpack_require__(2183);
const Chrome74_1 = __webpack_require__(11);
const Firefox120_1 = __webpack_require__(2292);
const Safari12_1 = __webpack_require__(5765);
const ReactNative106_1 = __webpack_require__(867);
const logger = new Logger_1.Logger('Device');
/**
 * Async mediasoup-client Handler detection. More powerful than
 * `detectDevice()`.
 */
async function detectDeviceAsync(userAgent) {
    logger.debug('detectDeviceAsync() [userAgent:%s]', userAgent);
    if (!userAgent && typeof navigator === 'object') {
        userAgent = navigator.userAgent;
    }
    const uaParserResult = await (0, ua_parser_js_1.UAParser)(userAgent).withFeatureCheck();
    return detectDeviceImpl(uaParserResult);
}
/**
 * Sync mediasoup-client Handler detection.
 *
 * @deprecated It only relies on navigator.userAgent. Use `detectDeviceAsync()`
 * instead.
 */
function detectDevice(userAgent) {
    logger.debug('detectDevice() [userAgent:%s]', userAgent);
    if (!userAgent && typeof navigator === 'object') {
        userAgent = navigator.userAgent;
    }
    const uaParserResult = (0, ua_parser_js_1.UAParser)(userAgent);
    return detectDeviceImpl(uaParserResult);
}
class Device {
    // RTC handler factory.
    _handlerFactory;
    // Handler name.
    _handlerName;
    // Loaded flag.
    _loaded = false;
    // Callback for sending Transports to request sending extended RTP capabilities
    // on demand.
    _getSendExtendedRtpCapabilities;
    // Local RTP capabilities for receiving media.
    _recvRtpCapabilities;
    // Whether we can produce audio/video based on remote RTP capabilities.
    _canProduceByKind = {
        audio: false,
        video: false,
    };
    // Local SCTP capabilities.
    _sctpCapabilities;
    // Observer instance.
    _observer = new enhancedEvents_1.EnhancedEventEmitter();
    /**
     * Create a new Device to connect to mediasoup server. It uses a more advanced
     * device detection.
     *
     * @throws {UnsupportedError} if device is not supported.
     */
    static async factory({ handlerName, handlerFactory, } = {}) {
        logger.debug('factory()');
        if (handlerName && handlerFactory) {
            throw new TypeError('just one of handlerName or handlerInterface can be given');
        }
        if (!handlerName && !handlerFactory) {
            handlerName = await detectDeviceAsync();
            if (!handlerName) {
                throw new errors_1.UnsupportedError('device not supported');
            }
        }
        return new Device({ handlerName, handlerFactory });
    }
    /**
     * Create a new Device to connect to mediasoup server.
     *
     * @throws {UnsupportedError} if device is not supported.
     */
    constructor({ handlerName, handlerFactory } = {}) {
        logger.debug('constructor()');
        if (handlerName && handlerFactory) {
            throw new TypeError('just one of handlerName or handlerInterface can be given');
        }
        if (handlerFactory) {
            this._handlerFactory = handlerFactory;
        }
        else {
            if (handlerName) {
                logger.debug('constructor() | handler given: %s', handlerName);
            }
            else {
                handlerName = detectDevice();
                if (handlerName) {
                    logger.debug('constructor() | detected handler: %s', handlerName);
                }
                else {
                    throw new errors_1.UnsupportedError('device not supported');
                }
            }
            switch (handlerName) {
                case 'Chrome111': {
                    this._handlerFactory = Chrome111_1.Chrome111.createFactory();
                    break;
                }
                case 'Chrome74': {
                    this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                    break;
                }
                case 'Firefox120': {
                    this._handlerFactory = Firefox120_1.Firefox120.createFactory();
                    break;
                }
                case 'Safari12': {
                    this._handlerFactory = Safari12_1.Safari12.createFactory();
                    break;
                }
                case 'ReactNative106': {
                    this._handlerFactory = ReactNative106_1.ReactNative106.createFactory();
                    break;
                }
                default: {
                    throw new TypeError(`unknown handlerName "${handlerName}"`);
                }
            }
        }
        this._handlerName = this._handlerFactory.name;
    }
    /**
     * The RTC handler name.
     */
    get handlerName() {
        return this._handlerName;
    }
    /**
     * Whether the Device is loaded.
     */
    get loaded() {
        return this._loaded;
    }
    /**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get rtpCapabilities() {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        return this._recvRtpCapabilities;
    }
    /**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get sctpCapabilities() {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        return this._sctpCapabilities;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Initialize the Device.
     */
    async load({ routerRtpCapabilities, preferLocalCodecsOrder = false, }) {
        logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);
        if (this._loaded) {
            throw new errors_1.InvalidStateError('already loaded');
        }
        // Clone given router RTP capabilities to not modify input data.
        const clonedRouterRtpCapabilities = utils.clone(routerRtpCapabilities);
        // This may throw.
        ortc.validateAndNormalizeRtpCapabilities(clonedRouterRtpCapabilities);
        const { getNativeRtpCapabilities, getNativeSctpCapabilities } = this._handlerFactory;
        const clonedNativeRtpCapabilities = utils.clone(await getNativeRtpCapabilities());
        // This may throw.
        ortc.validateAndNormalizeRtpCapabilities(clonedNativeRtpCapabilities);
        logger.debug('load() | got native RTP capabilities:%o', clonedNativeRtpCapabilities);
        this._getSendExtendedRtpCapabilities = (nativeRtpCapabilities) => {
            return utils.clone(ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, clonedRouterRtpCapabilities, preferLocalCodecsOrder));
        };
        const recvExtendedRtpCapabilities = ortc.getExtendedRtpCapabilities(clonedNativeRtpCapabilities, clonedRouterRtpCapabilities, 
        /* preferLocalCodecsOrder */ false);
        // Generate our receiving RTP capabilities for receiving media.
        this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(recvExtendedRtpCapabilities);
        // This may throw.
        ortc.validateAndNormalizeRtpCapabilities(this._recvRtpCapabilities);
        logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);
        // Check whether we can produce audio/video.
        this._canProduceByKind.audio = ortc.canSend('audio', this._recvRtpCapabilities);
        this._canProduceByKind.video = ortc.canSend('video', this._recvRtpCapabilities);
        // Generate our SCTP capabilities.
        this._sctpCapabilities = await getNativeSctpCapabilities();
        // This may throw.
        ortc.validateSctpCapabilities(this._sctpCapabilities);
        logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);
        logger.debug('load() succeeded');
        this._loaded = true;
    }
    /**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    canProduce(kind) {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        else if (kind !== 'audio' && kind !== 'video') {
            throw new TypeError(`invalid kind "${kind}"`);
        }
        return this._canProduceByKind[kind];
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData, }) {
        logger.debug('createSendTransport()');
        return this.createTransport({
            direction: 'send',
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            appData,
        });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData, }) {
        logger.debug('createRecvTransport()');
        return this.createTransport({
            direction: 'recv',
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            appData,
        });
    }
    createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData, }) {
        if (!this._loaded) {
            throw new errors_1.InvalidStateError('not loaded');
        }
        else if (typeof id !== 'string') {
            throw new TypeError('missing id');
        }
        else if (typeof iceParameters !== 'object') {
            throw new TypeError('missing iceParameters');
        }
        else if (!Array.isArray(iceCandidates)) {
            throw new TypeError('missing iceCandidates');
        }
        else if (typeof dtlsParameters !== 'object') {
            throw new TypeError('missing dtlsParameters');
        }
        else if (sctpParameters && typeof sctpParameters !== 'object') {
            throw new TypeError('wrong sctpParameters');
        }
        else if (appData && typeof appData !== 'object') {
            throw new TypeError('if given, appData must be an object');
        }
        // Create a new Transport.
        const transport = new Transport_1.Transport({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            appData,
            handlerFactory: this._handlerFactory,
            getSendExtendedRtpCapabilities: this._getSendExtendedRtpCapabilities,
            recvRtpCapabilities: this._recvRtpCapabilities,
            canProduceByKind: this._canProduceByKind,
        });
        // Emit observer event.
        this._observer.safeEmit('newtransport', transport);
        return transport;
    }
}
exports.Device = Device;
function detectDeviceImpl(uaParserResult) {
    // React-Native.
    if (typeof navigator === 'object' && navigator.product === 'ReactNative') {
        logger.debug('detectDeviceImpl() | React-Native detected');
        if (typeof RTCPeerConnection === 'undefined' ||
            typeof RTCRtpTransceiver === 'undefined') {
            logger.warn('detectDeviceImpl() | unsupported react-native-webrtc without RTCPeerConnection or RTCRtpTransceiver, forgot to call registerGlobals() on it?');
            return undefined;
        }
        return 'ReactNative106';
    }
    // Browser.
    else {
        logger.debug('detectDeviceImpl() | browser detected [userAgent:%s, parsed:%o]', uaParserResult.ua, uaParserResult);
        const browser = uaParserResult.browser;
        const browserName = browser.name?.toLowerCase();
        const browserVersion = parseInt(browser.major ?? '0');
        const engine = uaParserResult.engine;
        const engineName = engine.name?.toLowerCase();
        const os = uaParserResult.os;
        const osName = os.name?.toLowerCase();
        const osVersion = parseFloat(os.version ?? '0');
        const device = uaParserResult.device;
        const deviceModel = device.model?.toLowerCase();
        const isIOS = osName === 'ios' || deviceModel === 'ipad';
        const isChrome = browserName &&
            [
                'chrome',
                'chromium',
                'mobile chrome',
                'chrome webview',
                'chrome headless',
            ].includes(browserName);
        const isFirefox = browserName &&
            ['firefox', 'mobile firefox', 'mobile focus'].includes(browserName);
        const isSafari = browserName && ['safari', 'mobile safari'].includes(browserName);
        const isEdge = browserName && ['edge'].includes(browserName);
        // Chrome, Chromium, and Edge.
        if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {
            return 'Chrome111';
        }
        else if ((isChrome && !isIOS && browserVersion >= 74) ||
            (isEdge && !isIOS && browserVersion >= 88)) {
            return 'Chrome74';
        }
        // Firefox.
        else if (isFirefox && !isIOS && browserVersion >= 120) {
            return 'Firefox120';
        }
        // Firefox on iOS (so Safari).
        else if (isFirefox && isIOS && osVersion >= 14.3) {
            return 'Safari12';
        }
        // Safari with Unified-Plan support enabled.
        else if (isSafari &&
            browserVersion >= 12 &&
            typeof RTCRtpTransceiver !== 'undefined' &&
            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
            return 'Safari12';
        }
        // Best effort for WebKit based browsers in iOS.
        else if (engineName === 'webkit' &&
            isIOS &&
            typeof RTCRtpTransceiver !== 'undefined' &&
            RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
            return 'Safari12';
        }
        // Best effort for Chromium based browsers.
        else if (engineName === 'blink') {
            // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
            const match = uaParserResult.ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
            if (match) {
                const version = Number(match[1]);
                if (version >= 111) {
                    return 'Chrome111';
                }
                else {
                    return 'Chrome74';
                }
            }
            else {
                return 'Chrome111';
            }
        }
        // Unsupported browser.
        else {
            logger.warn('detectDeviceImpl() | browser not supported [name:%s, version:%s]', browserName, browserVersion);
            return undefined;
        }
    }
}


/***/ }),

/***/ 6298:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));

/***/ }),

/***/ 6308:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3009));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));

/***/ }),

/***/ 6372:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));

/***/ }),

/***/ 6440:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),

/***/ 6585:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 6746:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KS: () => (/* binding */ EncryptionEvent),
/* harmony export */   fo: () => (/* binding */ KeyProviderEvent)
/* harmony export */ });
/* unused harmony exports KeyHandlerEvent, CryptorEvent, CryptorMessageTypes */
// "Enums" as frozen objects
var KeyProviderEvent = Object.freeze({
  SetKey: 'setKey',
  RatchetRequest: 'ratchetRequest',
  KeyRatcheted: 'keyRatcheted'
});
var KeyHandlerEvent = Object.freeze({
  KeyRatcheted: 'keyRatcheted'
});
var EncryptionEvent = Object.freeze({
  ParticipantEncryptionStatusChanged: 'participantEncryptionStatusChanged',
  EncryptionError: 'encryptionError',
  E2EEStateChange: 'e2eeStateChange'
});
var CryptorEvent = Object.freeze({
  Error: 'cryptorError',
  Message: 'cryptorMessage'
});
var CryptorMessageTypes = Object.freeze({
  EncryptionSuccess: 'EncryptionSuccess',
  EncryptionFailed: 'EncryptionFailed',
  DecryptionSuccess: 'DecryptionSuccess',
  DecryptionFailed: 'DecryptionFailed',
  MissingKey: 'MissingKey',
  InternalError: 'InternalError',
  InvalidKey: 'InvalidKey'
});

// Documentation (optional): What callbacks are expected
// Since JS doesn't have types, you might want to document expected shapes

/**
 * @typedef {Object} KeyProviderCallbacks
 * @property {(keyInfo: KeyInfo) => void} setKey
 * @property {(participantIdentity?: string, keyIndex?: number) => void} ratchetRequest
 * @property {(material: CryptoKey, keyIndex?: number) => void} keyRatcheted
 */

/**
 * @typedef {Object} ParticipantKeyHandlerCallbacks
 * @property {(material: CryptoKey, participantIdentity: string, keyIndex?: number) => void} keyRatcheted
 */

/**
 * @typedef {Object} E2EEManagerCallbacks
 * @property {(enabled: boolean, participant: any) => void} participantEncryptionStatusChanged
 * @property {(error: Error) => void} encryptionError
 */

/**
 * @typedef {Object} CryptorCallbacks
 * @property {(error: CryptorError) => void} error
 */

/***/ }),

/***/ 6880:
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(function(){return function(e){var t={};function r(i){if(t[i])return t[i].exports;var n=t[i]={i:i,l:!1,exports:{}};return e[i].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,i){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(i,n,function(t){return e[t]}.bind(null,n));return i},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=90)}({17:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i=r(18),n=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||""},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||""},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case"NT":return"NT";case"XP":return"XP";case"NT 5.0":return"2000";case"NT 5.1":return"XP";case"NT 5.2":return"2003";case"NT 6.0":return"Vista";case"NT 6.1":return"7";case"NT 6.2":return"8";case"NT 6.3":return"8.1";case"NT 10.0":return"10";default:return}},e.getMacOSVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return"Leopard";case 6:return"Snow Leopard";case 7:return"Lion";case 8:return"Mountain Lion";case 9:return"Mavericks";case 10:return"Yosemite";case 11:return"El Capitan";case 12:return"Sierra";case 13:return"High Sierra";case 14:return"Mojave";case 15:return"Catalina";default:return}},e.getAndroidVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0},e.getVersionPrecision=function(e){return e.split(".").length},e.compareVersions=function(t,r,i){void 0===i&&(i=!1);var n=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(n,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),i=t+new Array(r+1).join(".0");return e.map(i.split("."),(function(e){return new Array(20-e.length).join("0")+e})).reverse()}));for(i&&(o=a-Math.min(n,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,i=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)i.push(t(e[r]));return i},e.find=function(e,t){var r,i;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,i=e.length;r<i;r+=1){var n=e[r];if(t(n,r))return n}},e.assign=function(e){for(var t,r,i=e,n=arguments.length,s=new Array(n>1?n-1:0),a=1;a<n;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];"object"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){i[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return i.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return i.BROWSER_MAP[e]||""},e}();t.default=n,e.exports=t.default},18:function(e,t,r){"use strict";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast","Pale Moon":"pale_moon",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};t.BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",pale_moon:"Pale Moon",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};t.PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv",bot:"bot"};t.OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};t.ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"}},90:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(91))&&i.__esModule?i:{default:i},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var o=function(){function e(){}var t,r,i;return e.getParser=function(e,t){if(void 0===t&&(t=!1),"string"!=typeof e)throw new Error("UserAgent should be a string");return new n.default(e,t)},e.parse=function(e){return new n.default(e).getResult()},t=e,i=[{key:"BROWSER_MAP",get:function(){return s.BROWSER_MAP}},{key:"ENGINE_MAP",get:function(){return s.ENGINE_MAP}},{key:"OS_MAP",get:function(){return s.OS_MAP}},{key:"PLATFORMS_MAP",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),i&&a(t,i),e}();t.default=o,e.exports=t.default},91:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i=u(r(92)),n=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(i.default,(function(t){if("function"==typeof t.test)return t.test(e);if(Array.isArray(t.test))return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(n.default,(function(t){if("function"==typeof t.test)return t.test(e);if(Array.isArray(t.test))return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||"":t||""},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||"":t||""},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if("function"==typeof t.test)return t.test(e);if(Array.isArray(t.test))return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if("function"==typeof t.test)return t.test(e);if(Array.isArray(t.test))return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},i=0,n={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];"string"==typeof a?(n[t]=a,s+=1):"object"==typeof a&&(r[t]=a,i+=1)})),i>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(n),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(n[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),i=e.toLowerCase(),n=o.default.getBrowserTypeByAlias(i);return t&&n&&(i=n.toLowerCase()),i===r},t.compareVersion=function(e){var t=[0],r=e,i=!1,n=this.getBrowserVersion();if("string"==typeof n)return">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(i=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(i=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(n,r,i))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i};var s=/version\/(\d+(\.?_?\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:"Googlebot"},r=n.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:"Opera"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe:function(e){var t={name:"Opera"},r=n.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:"Samsung Internet for Android"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:"NAVER Whale Browser"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/PaleMoon/i],describe:function(e){var t={name:"Pale Moon"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:PaleMoon)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:"MZ Browser"},r=n.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:"Focus"},r=n.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:"Swing"},r=n.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:"Opera Coast"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\/\d+(?:.?_?\d+)+/i],describe:function(e){var t={name:"Opera Touch"},r=n.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:"Yandex Browser"},r=n.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:"UC Browser"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:"Maxthon"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:"Epiphany"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:"Puffin"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:"Sleipnir"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:"K-Meleon"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:"WeChat"},r=n.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=n.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:"Internet Explorer"},r=n.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe:function(e){var t={name:"Microsoft Edge"},r=n.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:"Microsoft Edge"},r=n.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:"Vivaldi"},r=n.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:"SeaMonkey"},r=n.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:"Sailfish"},r=n.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:"Amazon Silk"},r=n.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:"PhantomJS"},r=n.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:"SlimerJS"},r=n.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t={name:"BlackBerry"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:"WebOS Browser"},r=n.default.getFirstMatch(s,e)||n.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:"Bada"},r=n.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:"Tizen"},r=n.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:"QupZilla"},r=n.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:"Firefox"},r=n.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:"Electron"},r=n.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:"Miui"},r=n.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:"Chromium"},r=n.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:"Chrome"},r=n.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:"Google Search"},r=n.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:"Android Browser"},r=n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:"PlayStation 4"},r=n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:"Safari"},r=n.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return{name:n.default.getFirstMatch(t,e),version:n.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i},s=r(18);var a=[{test:[/Roku\/DVP/],describe:function(e){var t=n.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=n.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=n.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=n.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=n.default.getSecondMatch(/(Version\/)(\d[\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=n.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=n.default.getMacOSVersionName(t),i={name:s.OS_MAP.MacOS,version:t};return r&&(i.versionName=r),i}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=n.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=n.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=n.default.getAndroidVersionName(t),i={name:s.OS_MAP.Android,version:t};return r&&(i.versionName=r),i}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=n.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t=n.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||n.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||n.default.getFirstMatch(/\bbb(\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=n.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=n.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=n.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:s.PLATFORMS_MAP.bot,vendor:"Google"}}},{test:[/huawei/i],describe:function(e){var t=n.default.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:s.PLATFORMS_MAP.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=n.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/Nokia/i],describe:function(e){var t=n.default.getFirstMatch(/Nokia\s+([0-9]+(\.[0-9]+)?)/i,e),r={type:s.PLATFORMS_MAP.mobile,vendor:"Nokia"};return t&&(r.model=t),r}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"blackberry"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test:function(e){return"bada"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"windows phone"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(".")[0]);return"android"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return"android"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"macos"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test:function(e){return"windows"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"linux"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"playstation 4"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return"roku"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var i,n=(i=r(17))&&i.__esModule?i:{default:i},s=r(18);var a=[{test:function(e){return"microsoft edge"===e.getBrowserName(!0)},describe:function(e){if(/\sedg\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=n.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=n.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=n.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=n.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=n.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));

/***/ }),

/***/ 6939:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));

/***/ }),

/***/ 6993:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var regeneratorDefine = __webpack_require__(5546);
function _regenerator() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  var e,
    t,
    r = "function" == typeof Symbol ? Symbol : {},
    n = r.iterator || "@@iterator",
    o = r.toStringTag || "@@toStringTag";
  function i(r, n, o, i) {
    var c = n && n.prototype instanceof Generator ? n : Generator,
      u = Object.create(c.prototype);
    return regeneratorDefine(u, "_invoke", function (r, n, o) {
      var i,
        c,
        u,
        f = 0,
        p = o || [],
        y = !1,
        G = {
          p: 0,
          n: 0,
          v: e,
          a: d,
          f: d.bind(e, 4),
          d: function d(t, r) {
            return i = t, c = 0, u = e, G.n = r, a;
          }
        };
      function d(r, n) {
        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
          var o,
            i = p[t],
            d = G.p,
            l = i[2];
          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
        }
        if (o || r > 1) return a;
        throw y = !0, n;
      }
      return function (o, p, l) {
        if (f > 1) throw TypeError("Generator is already running");
        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
          try {
            if (f = 2, i) {
              if (c || (o = "next"), t = i[o]) {
                if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u = t.value, c < 2 && (c = 0);
              } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
              i = e;
            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
          } catch (t) {
            i = e, c = 1, u = t;
          } finally {
            f = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r, o, i), !0), u;
  }
  var a = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  t = Object.getPrototypeOf;
  var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function () {
      return this;
    }), t),
    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
  function f(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function () {
    return this;
  }), regeneratorDefine(u, "toString", function () {
    return "[object Generator]";
  }), (module.exports = _regenerator = function _regenerator() {
    return {
      w: i,
      m: f
    };
  }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
}
module.exports = _regenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 7007:
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ 7080:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   q: () => (/* binding */ sdkErrors),
/* harmony export */   s: () => (/* binding */ errors)
/* harmony export */ });
var errors = {
  // server errors
  INVALID_API_KEY: 4001,
  INVALID_TOKEN: 4002,
  INVALID_MEETING_ID: 4003,
  INVALID_PARTICIPANT_ID: 4004,
  DUPLICATE_PARTICIPANT: 4005,
  ACCOUNT_DEACTIVATED: 4006,
  ACCOUNT_DISCONTINUED: 4007,
  INVALID_PERMISSIONS: 4008,
  MAX_PARTCIPANT_REACHED: 4009,
  MAX_SPEAKER_REACHED: 4010,
  START_RECORDING_FAILED: 4011,
  STOP_RECORDING_FAILED: 4012,
  START_LIVESTREAM_FAILED: 4013,
  STOP_LIVESTREAM_FAILED: 4014,
  INVALID_LIVESTREAM_CONFIG: 4015,
  START_HLS_FAILED: 4016,
  STOP_HLS_FAILED: 4017,
  START_TRANSCRIPTION_FAILED: 4031,
  STOP_TRANSCRIPTION_FAILED: 4032,
  // server critical errors
  RECORDING_FAILED: 5001,
  LIVESTREAM_FAILED: 5002,
  HLS_FAILED: 5003,
  TRANSCRIPTION_FAILED: 5007,
  // sdk errors
  ERROR_GET_VIDEO_MEDIA: 3011,
  ERROR_GET_AUDIO_MEDIA: 3012,
  ERROR_GET_DISPLAY_MEDIA: 3013,
  ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED: 3014,
  ERROR_GET_AUDIO_MEDIA_PERMISSION_DENIED: 3015,
  ERROR_GET_DISPLAY_MEDIA_PERMISSION_DENIED: 3016,
  ERROR_CAMERA_ACCESS_DENIED_OR_DISMISSED: 3017,
  ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED: 3018,
  ERROR_CAMERA_PERMISSION_DENIED_BY_OS: 3019,
  ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS: 3020,
  ERROR_CAMERA_NOT_FOUND: 3021,
  ERROR_MICROPHONE_NOT_FOUND: 3022,
  ERROR_CAMERA_IN_USE: 3023,
  ERROR_MICROPHONE_IN_USE: 3024,
  ERROR_CAMERA_PERMISSION_OR_AUTOPLAY_ISSUE: 3025,
  ERROR_VIDEO_SOURCE_INITIATION_FAILED: 3026,
  ERROR_WEBCAM_TRACK_ENDED: 3027,
  ERROR_MICROPHONE_TRACK_ENDED: 3028,
  ERROR_INVALID_CUSTOM_VIDEO_TRACK: 3029,
  ERROR_INVALID_CUSTOM_AUDIO_TRACK: 3030,
  ERROR_CUSTOM_VIDEO_TRACK_ENDED: 3031,
  ERROR_CUSTOM_AUDIO_TRACK_ENDED: 3032,
  ERROR_CAMERA_ACCESS_UNAVAILABLE: 3033,
  ERROR_MICROPHONE_ACCESS_UNAVAILABLE: 3034,
  ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED: 3035,
  ERROR_RN_CAMERA_ACCESS_DENIED_OR_DISMISSED: 3036,
  ERROR_RN_CAMERA_NOT_FOUND: 3037,
  ERROR_RN_MIC_ACCESS_DENIED_OR_DISMISSED: 3038,
  ERROR_RN_MIC_NOT_FOUND: 3039,
  ERROR_RN_CAMERA_ACCESS_UNAVAILABLE: 3040,
  ERROR_RN_MIC_ACCESS_UNAVAILABLE: 3041,
  ERROR_RN_CAMERA_TRACK_ENDED: 3042,
  ERROR_RN_MIC_TRACK_ENDED: 3043
};
var sdkErrors = {
  ERROR_GET_VIDEO_MEDIA: {
    code: 3011,
    message: "Your browser/Device does not support Video."
  },
  ERROR_GET_AUDIO_MEDIA: {
    code: 3012,
    message: "Your browser/Device does not support Audio."
  },
  ERROR_GET_DISPLAY_MEDIA: {
    code: 3013,
    message: "Your browser/Device does not support Screen Sharing."
  },
  ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED: {
    code: 3014,
    message: "Video capture permission denied."
  },
  ERROR_GET_AUDIO_MEDIA_PERMISSION_DENIED: {
    code: 3015,
    message: "Audio capture permission denied."
  },
  ERROR_GET_DISPLAY_MEDIA_PERMISSION_DENIED: {
    code: 3016,
    message: "Screen sharing permission denied."
  },
  ERROR_CAMERA_ACCESS_DENIED_OR_DISMISSED: {
    code: 3017,
    message: "Oops! It seems like camera access was denied or dismissed. To proceed, kindly grant access through your browser settings."
  },
  ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED: {
    code: 3018,
    message: "Oops! It seems like microphone access was denied or dismissed. To proceed, kindly grant access through your browser settings."
  },
  ERROR_CAMERA_PERMISSION_DENIED_BY_OS: {
    code: 3019,
    message: "Camera permission denied by OS system settings. Please check the system settings and grant permission for this browser."
  },
  ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS: {
    code: 3020,
    message: "Microphone permission denied by OS system settings. Please check the system settings and grant permission for this browser."
  },
  ERROR_CAMERA_NOT_FOUND: {
    code: 3021,
    message: "Please ensure your camera is connected and turned on, and that the camera driver is installed and up-to-date."
  },
  ERROR_MICROPHONE_NOT_FOUND: {
    code: 3022,
    message: "Please ensure your microphone is connected and turned on."
  },
  ERROR_CAMERA_IN_USE: {
    code: 3023,
    message: "The camera is being used by another application. Please close any programs utilizing the camera, such as video conferencing tools, screen recording software, or other browsers. Restart your browser and attempt again."
  },
  ERROR_MICROPHONE_IN_USE: {
    code: 3024,
    message: "The microphone is being used by another application. Please close any programs utilizing the microphone, such as video conferencing tools, screen recording software, or other browsers. Restart your browser and attempt again."
  },
  ERROR_CAMERA_PERMISSION_OR_AUTOPLAY_ISSUE: {
    code: 3025,
    message: "It seems like there's an issue with camera permission or video autoplay, you can check out this link for details: http://tinyurl.com/autoplay-issue"
  },
  ERROR_VIDEO_SOURCE_INITIATION_FAILED: {
    code: 3026,
    message: "Unable to initiate video source. Please verify browser settings for video permissions."
  },
  ERROR_WEBCAM_TRACK_ENDED: {
    code: 3027,
    message: "Webcam track has ended or the webcam is disconnected. Please ensure your webcam is properly connected and try restarting it."
  },
  ERROR_MICROPHONE_TRACK_ENDED: {
    code: 3028,
    message: "Microphone track has ended or the microphone is disconnected. Please check your microphone connection and try again."
  },
  ERROR_INVALID_CUSTOM_VIDEO_TRACK: {
    code: 3029,
    message: "The provided custom video track is invalid; reverting to the default video track. Please ensure that the video track meets the required specifications."
  },
  ERROR_INVALID_CUSTOM_AUDIO_TRACK: {
    code: 3030,
    message: "The provided custom audio track is invalid; reverting to the default audio track. Please ensure that the audio track meets the required specifications."
  },
  ERROR_CUSTOM_VIDEO_TRACK_ENDED: {
    code: 3031,
    message: "The provided custom video track is in an ended state. Please verify the video track's status, and try again."
  },
  ERROR_CUSTOM_AUDIO_TRACK_ENDED: {
    code: 3032,
    message: "The provided custom audio track is in an ended state. Please verify the audio track's status, and try again."
  },
  ERROR_CAMERA_ACCESS_UNAVAILABLE: {
    code: 3033,
    message: "Camera access unavailable: Please ensure your device is compatible and that you're on a secure website (https://)."
  },
  ERROR_MICROPHONE_ACCESS_UNAVAILABLE: {
    code: 3034,
    message: "Microphone access unavailable: Please ensure your device is compatible and that you're on a secure website (https://)."
  },
  ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED: {
    code: 3035,
    message: "Oops! Something went wrong. The room was in a connecting state, and during that time, an action encountered an issue. Please try again after joining a meeting."
  },
  // For React Native
  ERROR_RN_CAMERA_ACCESS_DENIED_OR_DISMISSED: {
    code: 3036,
    message: "Oops! It seems like camera access was denied or dismissed. To proceed, kindly grant access through your App settings."
  },
  ERROR_RN_CAMERA_NOT_FOUND: {
    code: 3037,
    message: "Please ensure your camera is connected and turned on"
  },
  ERROR_RN_MIC_ACCESS_DENIED_OR_DISMISSED: {
    code: 3038,
    message: "Oops! It seems like mic access was denied or dismissed. To proceed, kindly grant access through your App settings."
  },
  ERROR_RN_MIC_NOT_FOUND: {
    code: 3039,
    message: "Please ensure your mic is connected and turned on"
  },
  ERROR_RN_CAMERA_ACCESS_UNAVAILABLE: {
    code: 3040,
    message: "Camera access unavailable: Please ensure your device is compatible."
  },
  ERROR_RN_MIC_ACCESS_UNAVAILABLE: {
    code: 3041,
    message: "Microphone access unavailable: Please ensure your device is compatible."
  },
  ERROR_RN_CAMERA_TRACK_ENDED: {
    code: 3042,
    message: "Camera track has ended. Please make sure your camera is turned on or try restarting it."
  },
  ERROR_RN_MIC_TRACK_ENDED: {
    code: 3043,
    message: "Microphone track has ended or the microphone is disconnected. Please check your microphone connection and try again."
  }
};

/***/ }),

/***/ 7165:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(9506));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt, hasher) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            if (!hasher) {
	                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
	            } else {
	                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: hasher }).compute(password, salt);
	            }


	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),

/***/ 7193:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));

/***/ }),

/***/ 7363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var parser = __webpack_require__(5020);
var writer = __webpack_require__(3804);
var grammar = __webpack_require__(5602);

exports.grammar = grammar;
exports.write = writer;
exports.parse = parser.parse;
exports.parseParams = parser.parseParams;
exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;
exports.parseImageAttributes = parser.parseImageAttributes;
exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;


/***/ }),

/***/ 7504:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataProducer = void 0;
const Logger_1 = __webpack_require__(2994);
const enhancedEvents_1 = __webpack_require__(3953);
const errors_1 = __webpack_require__(4893);
const logger = new Logger_1.Logger('DataProducer');
class DataProducer extends enhancedEvents_1.EnhancedEventEmitter {
    // Id.
    _id;
    // The underlying RTCDataChannel instance.
    _dataChannel;
    // Closed flag.
    _closed = false;
    // SCTP stream parameters.
    _sctpStreamParameters;
    // App custom data.
    _appData;
    // Observer instance.
    _observer = new enhancedEvents_1.EnhancedEventEmitter();
    constructor({ id, dataChannel, sctpStreamParameters, appData, }) {
        super();
        logger.debug('constructor()');
        this._id = id;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData ?? {};
        this.handleDataChannel();
    }
    /**
     * DataProducer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Whether the DataProducer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel bufferedAmount.
     */
    get bufferedAmount() {
        return this._dataChannel.bufferedAmount;
    }
    /**
     * DataChannel bufferedAmountLowThreshold.
     */
    get bufferedAmountLowThreshold() {
        return this._dataChannel.bufferedAmountLowThreshold;
    }
    /**
     * Set DataChannel bufferedAmountLowThreshold.
     */
    set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataProducer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this._dataChannel.close();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
        this._observer.close();
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    send(data) {
        logger.debug('send()');
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        this._dataChannel.send(data);
    }
    handleDataChannel() {
        this._dataChannel.addEventListener('open', () => {
            if (this._closed) {
                return;
            }
            logger.debug('DataChannel "open" event');
            this.safeEmit('open');
        });
        this._dataChannel.addEventListener('error', event => {
            if (this._closed) {
                return;
            }
            const error = event.error ?? new Error('unknown DataChannel error');
            if (event.error?.errorDetail === 'sctp-failure') {
                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', event.error?.sctpCauseCode, event.error.message);
            }
            else {
                logger.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit('error', error);
        });
        this._dataChannel.addEventListener('close', () => {
            if (this._closed) {
                return;
            }
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit('@close');
            this.safeEmit('close');
            // Emit observer event.
            this._observer.safeEmit('close');
        });
        this._dataChannel.addEventListener('message', () => {
            if (this._closed) {
                return;
            }
            logger.warn('DataChannel "message" event in a DataProducer, message discarded');
        });
        this._dataChannel.addEventListener('bufferedamountlow', () => {
            if (this._closed) {
                return;
            }
            this.safeEmit('bufferedamountlow');
        });
    }
}
exports.DataProducer = DataProducer;


/***/ }),

/***/ 7628:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(754), __webpack_require__(4636), __webpack_require__(9506), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            // Make sure the key length is valid (64, 128 or >= 192 bit)
	            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
	                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
	            }

	            // Extend the key according to the keying options defined in 3DES standard
	            var key1 = keyWords.slice(0, 2);
	            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
	            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(key1));
	            this._des2 = DES.createEncryptor(WordArray.create(key2));
	            this._des3 = DES.createEncryptor(WordArray.create(key3));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));

/***/ }),

/***/ 7654:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = memoize;


/***/ }),

/***/ 7800:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ _unsupportedIterableToArray)
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3145);

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(r, a) : void 0;
  }
}


/***/ }),

/***/ 7833:
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	// eslint-disable-next-line no-return-assign
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(736)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 8046:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateAndNormalizeRtpCapabilities = validateAndNormalizeRtpCapabilities;
exports.validateAndNormalizeRtpParameters = validateAndNormalizeRtpParameters;
exports.validateAndNormalizeSctpStreamParameters = validateAndNormalizeSctpStreamParameters;
exports.validateSctpCapabilities = validateSctpCapabilities;
exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
exports.getSendingRtpParameters = getSendingRtpParameters;
exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
exports.reduceCodecs = reduceCodecs;
exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
exports.canSend = canSend;
exports.canReceive = canReceive;
const h264 = __webpack_require__(3200);
const utils = __webpack_require__(1765);
const RTP_PROBATOR_MID = 'probator';
const RTP_PROBATOR_SSRC = 1234;
const RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
/**
 * Validates RtpCapabilities. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpCapabilities(caps) {
    if (typeof caps !== 'object') {
        throw new TypeError('caps is not an object');
    }
    // codecs is optional. If unset, fill with an empty array.
    if (caps.codecs && !Array.isArray(caps.codecs)) {
        throw new TypeError('caps.codecs is not an array');
    }
    else if (!caps.codecs) {
        caps.codecs = [];
    }
    for (const codec of caps.codecs) {
        validateAndNormalizeRtpCodecCapability(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
        throw new TypeError('caps.headerExtensions is not an array');
    }
    else if (!caps.headerExtensions) {
        caps.headerExtensions = [];
    }
    for (const ext of caps.headerExtensions) {
        validateAndNormalizeRtpHeaderExtension(ext);
    }
}
/**
 * Validates RtpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpParameters(params) {
    if (typeof params !== 'object') {
        throw new TypeError('params is not an object');
    }
    // mid is optional.
    if (params.mid && typeof params.mid !== 'string') {
        throw new TypeError('params.mid is not a string');
    }
    // codecs is mandatory.
    if (!Array.isArray(params.codecs)) {
        throw new TypeError('missing params.codecs');
    }
    for (const codec of params.codecs) {
        validateAndNormalizeRtpCodecParameters(codec);
    }
    // headerExtensions is optional. If unset, fill with an empty array.
    if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
        throw new TypeError('params.headerExtensions is not an array');
    }
    else if (!params.headerExtensions) {
        params.headerExtensions = [];
    }
    for (const ext of params.headerExtensions) {
        validateRtpHeaderExtensionParameters(ext);
    }
    // encodings is optional. If unset, fill with an empty array.
    if (params.encodings && !Array.isArray(params.encodings)) {
        throw new TypeError('params.encodings is not an array');
    }
    else if (!params.encodings) {
        params.encodings = [];
    }
    for (const encoding of params.encodings) {
        validateAndNormalizeRtpEncodingParameters(encoding);
    }
    // rtcp is optional. If unset, fill with an empty object.
    if (params.rtcp && typeof params.rtcp !== 'object') {
        throw new TypeError('params.rtcp is not an object');
    }
    else if (!params.rtcp) {
        params.rtcp = {};
    }
    validateAndNormalizeRtcpParameters(params.rtcp);
}
/**
 * Validates SctpStreamParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeSctpStreamParameters(params) {
    if (typeof params !== 'object') {
        throw new TypeError('params is not an object');
    }
    // streamId is mandatory.
    if (typeof params.streamId !== 'number') {
        throw new TypeError('missing params.streamId');
    }
    // ordered is optional.
    let orderedGiven = false;
    if (typeof params.ordered === 'boolean') {
        orderedGiven = true;
    }
    else {
        params.ordered = true;
    }
    // maxPacketLifeTime is optional.
    if (params.maxPacketLifeTime &&
        typeof params.maxPacketLifeTime !== 'number') {
        throw new TypeError('invalid params.maxPacketLifeTime');
    }
    // maxRetransmits is optional.
    if (params.maxRetransmits && typeof params.maxRetransmits !== 'number') {
        throw new TypeError('invalid params.maxRetransmits');
    }
    if (params.maxPacketLifeTime && params.maxRetransmits) {
        throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
    }
    if (orderedGiven &&
        params.ordered &&
        (params.maxPacketLifeTime || params.maxRetransmits)) {
        throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
    }
    else if (!orderedGiven &&
        (params.maxPacketLifeTime || params.maxRetransmits)) {
        params.ordered = false;
    }
    // label is optional.
    if (params.label && typeof params.label !== 'string') {
        throw new TypeError('invalid params.label');
    }
    // protocol is optional.
    if (params.protocol && typeof params.protocol !== 'string') {
        throw new TypeError('invalid params.protocol');
    }
}
/**
 * Validates SctpCapabilities.
 * It throws if invalid.
 */
function validateSctpCapabilities(caps) {
    if (typeof caps !== 'object') {
        throw new TypeError('caps is not an object');
    }
    // numStreams is mandatory.
    if (!caps.numStreams || typeof caps.numStreams !== 'object') {
        throw new TypeError('missing caps.numStreams');
    }
    validateNumSctpStreams(caps.numStreams);
}
/**
 * Generate extended RTP capabilities for sending and receiving.
 *
 * Resulting codecs keep order preferred by local or remote capabilities
 * depending on `preferLocalCodecsOrder`.
 */
function getExtendedRtpCapabilities(localCaps, remoteCaps, preferLocalCodecsOrder) {
    const extendedRtpCapabilities = {
        codecs: [],
        headerExtensions: [],
    };
    // Match media codecs and keep the order preferred by local capabilities.
    if (preferLocalCodecsOrder) {
        for (const localCodec of localCaps.codecs ?? []) {
            if (isRtxCodec(localCodec)) {
                continue;
            }
            const matchingRemoteCodec = (remoteCaps.codecs ?? []).find((remoteCodec) => matchCodecs(remoteCodec, localCodec, { strict: true, modify: true }));
            if (!matchingRemoteCodec) {
                continue;
            }
            const extendedCodec = {
                kind: localCodec.kind,
                mimeType: localCodec.mimeType,
                clockRate: localCodec.clockRate,
                channels: localCodec.channels,
                localPayloadType: localCodec.preferredPayloadType,
                localRtxPayloadType: undefined,
                remotePayloadType: matchingRemoteCodec.preferredPayloadType,
                remoteRtxPayloadType: undefined,
                localParameters: localCodec.parameters ?? {},
                remoteParameters: matchingRemoteCodec.parameters ?? {},
                rtcpFeedback: reduceRtcpFeedback(localCodec, matchingRemoteCodec),
            };
            extendedRtpCapabilities.codecs.push(extendedCodec);
        }
    }
    // Match media codecs and keep the order preferred by remote capabilities.
    else {
        for (const remoteCodec of remoteCaps.codecs ?? []) {
            if (isRtxCodec(remoteCodec)) {
                continue;
            }
            const matchingLocalCodec = (localCaps.codecs ?? []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));
            if (!matchingLocalCodec) {
                continue;
            }
            const extendedCodec = {
                kind: matchingLocalCodec.kind,
                mimeType: matchingLocalCodec.mimeType,
                clockRate: matchingLocalCodec.clockRate,
                channels: matchingLocalCodec.channels,
                localPayloadType: matchingLocalCodec.preferredPayloadType,
                localRtxPayloadType: undefined,
                remotePayloadType: remoteCodec.preferredPayloadType,
                remoteRtxPayloadType: undefined,
                localParameters: matchingLocalCodec.parameters ?? {},
                remoteParameters: remoteCodec.parameters ?? {},
                rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec),
            };
            extendedRtpCapabilities.codecs.push(extendedCodec);
        }
    }
    // Match RTX codecs.
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => isRtxCodec(localCodec) &&
            localCodec.parameters?.['apt'] === extendedCodec.localPayloadType);
        const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => isRtxCodec(remoteCodec) &&
            remoteCodec.parameters?.['apt'] === extendedCodec.remotePayloadType);
        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
            extendedCodec.localRtxPayloadType =
                matchingLocalRtxCodec.preferredPayloadType;
            extendedCodec.remoteRtxPayloadType =
                matchingRemoteRtxCodec.preferredPayloadType;
        }
    }
    // Match header extensions.
    for (const remoteExt of remoteCaps.headerExtensions) {
        const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));
        if (!matchingLocalExt) {
            continue;
        }
        const extendedExt = {
            kind: remoteExt.kind,
            uri: remoteExt.uri,
            sendId: matchingLocalExt.preferredId,
            recvId: remoteExt.preferredId,
            encrypt: matchingLocalExt.preferredEncrypt ?? false,
            direction: 'sendrecv',
        };
        switch (remoteExt.direction) {
            case 'sendrecv': {
                extendedExt.direction = 'sendrecv';
                break;
            }
            case 'recvonly': {
                extendedExt.direction = 'sendonly';
                break;
            }
            case 'sendonly': {
                extendedExt.direction = 'recvonly';
                break;
            }
            case 'inactive': {
                extendedExt.direction = 'inactive';
                break;
            }
        }
        extendedRtpCapabilities.headerExtensions.push(extendedExt);
    }
    return extendedRtpCapabilities;
}
/**
 * Generate RTP capabilities for receiving media based on the given extended
 * RTP capabilities.
 */
function getRecvRtpCapabilities(extendedRtpCapabilities) {
    const rtpCapabilities = {
        codecs: [],
        headerExtensions: [],
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const codec = {
            kind: extendedCodec.kind,
            mimeType: extendedCodec.mimeType,
            preferredPayloadType: extendedCodec.remotePayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback,
        };
        rtpCapabilities.codecs.push(codec);
        // Add RTX codec.
        if (!extendedCodec.remoteRtxPayloadType) {
            continue;
        }
        const rtxCodec = {
            kind: extendedCodec.kind,
            mimeType: `${extendedCodec.kind}/rtx`,
            preferredPayloadType: extendedCodec.remoteRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
                apt: extendedCodec.remotePayloadType,
            },
            rtcpFeedback: [],
        };
        rtpCapabilities.codecs.push(rtxCodec);
        // TODO: In the future, we need to add FEC, CN, etc, codecs.
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions not valid for receiving.
        if (extendedExtension.direction !== 'sendrecv' &&
            extendedExtension.direction !== 'recvonly') {
            continue;
        }
        const ext = {
            kind: extendedExtension.kind,
            uri: extendedExtension.uri,
            preferredId: extendedExtension.recvId,
            preferredEncrypt: extendedExtension.encrypt ?? false,
            direction: extendedExtension.direction,
        };
        rtpCapabilities.headerExtensions.push(ext);
    }
    return rtpCapabilities;
}
/**
 * Generate RTP parameters of the given kind for sending media.
 * NOTE: mid, encodings and rtcp fields are left empty.
 */
function getSendingRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {},
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind) {
            continue;
        }
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback,
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType,
                },
                rtcpFeedback: [],
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
            (extendedExtension.direction !== 'sendrecv' &&
                extendedExtension.direction !== 'sendonly')) {
            continue;
        }
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {},
        };
        rtpParameters.headerExtensions.push(ext);
    }
    return rtpParameters;
}
/**
 * Generate RTP parameters of the given kind suitable for the remote SDP answer.
 */
function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
        mid: undefined,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {},
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind) {
            continue;
        }
        const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.remoteParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback,
        };
        rtpParameters.codecs.push(codec);
        // Add RTX codec.
        if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
                mimeType: `${extendedCodec.kind}/rtx`,
                payloadType: extendedCodec.localRtxPayloadType,
                clockRate: extendedCodec.clockRate,
                parameters: {
                    apt: extendedCodec.localPayloadType,
                },
                rtcpFeedback: [],
            };
            rtpParameters.codecs.push(rtxCodec);
        }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        // Ignore RTP extensions of a different kind and those not valid for sending.
        if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
            (extendedExtension.direction !== 'sendrecv' &&
                extendedExtension.direction !== 'sendonly')) {
            continue;
        }
        const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {},
        };
        rtpParameters.headerExtensions.push(ext);
    }
    // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
    if (rtpParameters.headerExtensions.some(ext => ext.uri ===
        'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== 'goog-remb');
        }
    }
    else if (rtpParameters.headerExtensions.some(ext => ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter(fb => fb.type !== 'transport-cc');
        }
    }
    else {
        for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== 'transport-cc' && fb.type !== 'goog-remb');
        }
    }
    return rtpParameters;
}
/**
 * Reduce given codecs by returning an array of codecs "compatible" with the
 * given capability codec. If no capability codec is given, take the first
 * one(s).
 *
 * Given codecs must be generated by ortc.getSendingRtpParameters() or
 * ortc.getSendingRemoteRtpParameters().
 *
 * The returned array of codecs also include a RTX codec if available.
 */
function reduceCodecs(codecs, capCodec) {
    const filteredCodecs = [];
    // If no capability codec is given, take the first one (and RTX).
    if (!capCodec) {
        filteredCodecs.push(codecs[0]);
        if (isRtxCodec(codecs[1])) {
            filteredCodecs.push(codecs[1]);
        }
    }
    // Otherwise look for a compatible set of codecs.
    else {
        for (let idx = 0; idx < codecs.length; ++idx) {
            if (matchCodecs(codecs[idx], capCodec, { strict: true })) {
                filteredCodecs.push(codecs[idx]);
                if (isRtxCodec(codecs[idx + 1])) {
                    filteredCodecs.push(codecs[idx + 1]);
                }
                break;
            }
        }
        if (filteredCodecs.length === 0) {
            throw new TypeError('no matching codec found');
        }
    }
    return filteredCodecs;
}
/**
 * Create RTP parameters for a Consumer for the RTP probator.
 */
function generateProbatorRtpParameters(videoRtpParameters) {
    // Clone given reference video RTP parameters.
    videoRtpParameters = utils.clone(videoRtpParameters);
    // This may throw.
    validateAndNormalizeRtpParameters(videoRtpParameters);
    const rtpParameters = {
        mid: RTP_PROBATOR_MID,
        codecs: [],
        headerExtensions: [],
        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
        rtcp: { cname: 'probator' },
    };
    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
    return rtpParameters;
}
/**
 * Whether media can be sent based on the given RTP capabilities.
 */
function canSend(kind, rtpCapabilities) {
    return (rtpCapabilities.codecs ?? []).some(codec => codec.kind === kind);
}
/**
 * Whether the given RTP parameters can be received with the given RTP
 * capabilities.
 */
function canReceive(rtpParameters, rtpCapabilities) {
    // This may throw.
    validateAndNormalizeRtpParameters(rtpParameters);
    if (rtpParameters.codecs.length === 0) {
        return false;
    }
    const firstMediaCodec = rtpParameters.codecs[0];
    return (rtpCapabilities.codecs ?? []).some(codec => codec.preferredPayloadType === firstMediaCodec.payloadType);
}
/**
 * Validates RtpCodecCapability. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpCodecCapability(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object') {
        throw new TypeError('codec is not an object');
    }
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string') {
        throw new TypeError('missing codec.mimeType');
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    // Just override kind with media component of mimeType.
    codec.kind = mimeTypeMatch[1].toLowerCase();
    // preferredPayloadType is mandatory.
    if (typeof codec.preferredPayloadType !== 'number') {
        throw new TypeError('missing codec.preferredPayloadType');
    }
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number') {
        throw new TypeError('missing codec.clockRate');
    }
    // channels is optional. If unset, set it to 1 (just if audio).
    if (codec.kind === 'audio') {
        if (typeof codec.channels !== 'number') {
            codec.channels = 1;
        }
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object') {
        codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number') {
                throw new TypeError('invalid codec apt parameter');
            }
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
        validateAndNormalizeRtcpFeedback(fb);
    }
}
/**
 * Validates RtcpFeedback. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtcpFeedback(fb) {
    if (typeof fb !== 'object') {
        throw new TypeError('fb is not an object');
    }
    // type is mandatory.
    if (!fb.type || typeof fb.type !== 'string') {
        throw new TypeError('missing fb.type');
    }
    // parameter is optional. If unset set it to an empty string.
    if (!fb.parameter || typeof fb.parameter !== 'string') {
        fb.parameter = '';
    }
}
/**
 * Validates RtpHeaderExtension. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpHeaderExtension(ext) {
    if (typeof ext !== 'object') {
        throw new TypeError('ext is not an object');
    }
    // kind is mandatory.
    if (ext.kind !== 'audio' && ext.kind !== 'video') {
        throw new TypeError('invalid ext.kind');
    }
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string') {
        throw new TypeError('missing ext.uri');
    }
    // preferredId is mandatory.
    if (typeof ext.preferredId !== 'number') {
        throw new TypeError('missing ext.preferredId');
    }
    // preferredEncrypt is optional. If unset set it to false.
    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean') {
        throw new TypeError('invalid ext.preferredEncrypt');
    }
    else if (!ext.preferredEncrypt) {
        ext.preferredEncrypt = false;
    }
    // direction is optional. If unset set it to sendrecv.
    if (ext.direction && typeof ext.direction !== 'string') {
        throw new TypeError('invalid ext.direction');
    }
    else if (!ext.direction) {
        ext.direction = 'sendrecv';
    }
}
/**
 * Validates RtpCodecParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpCodecParameters(codec) {
    const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
    if (typeof codec !== 'object') {
        throw new TypeError('codec is not an object');
    }
    // mimeType is mandatory.
    if (!codec.mimeType || typeof codec.mimeType !== 'string') {
        throw new TypeError('missing codec.mimeType');
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
        throw new TypeError('invalid codec.mimeType');
    }
    // payloadType is mandatory.
    if (typeof codec.payloadType !== 'number') {
        throw new TypeError('missing codec.payloadType');
    }
    // clockRate is mandatory.
    if (typeof codec.clockRate !== 'number') {
        throw new TypeError('missing codec.clockRate');
    }
    const kind = mimeTypeMatch[1].toLowerCase();
    // channels is optional. If unset, set it to 1 (just if audio).
    if (kind === 'audio') {
        if (typeof codec.channels !== 'number') {
            codec.channels = 1;
        }
    }
    else {
        delete codec.channels;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!codec.parameters || typeof codec.parameters !== 'object') {
        codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === undefined) {
            codec.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        // Specific parameters validation.
        if (key === 'apt') {
            if (typeof value !== 'number') {
                throw new TypeError('invalid codec apt parameter');
            }
        }
    }
    // rtcpFeedback is optional. If unset, set it to an empty array.
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
        validateAndNormalizeRtcpFeedback(fb);
    }
}
/**
 * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateRtpHeaderExtensionParameters(ext) {
    if (typeof ext !== 'object') {
        throw new TypeError('ext is not an object');
    }
    // uri is mandatory.
    if (!ext.uri || typeof ext.uri !== 'string') {
        throw new TypeError('missing ext.uri');
    }
    // id is mandatory.
    if (typeof ext.id !== 'number') {
        throw new TypeError('missing ext.id');
    }
    // encrypt is optional. If unset set it to false.
    if (ext.encrypt && typeof ext.encrypt !== 'boolean') {
        throw new TypeError('invalid ext.encrypt');
    }
    else if (!ext.encrypt) {
        ext.encrypt = false;
    }
    // parameters is optional. If unset, set it to an empty object.
    if (!ext.parameters || typeof ext.parameters !== 'object') {
        ext.parameters = {};
    }
    for (const key of Object.keys(ext.parameters)) {
        let value = ext.parameters[key];
        if (value === undefined) {
            ext.parameters[key] = '';
            value = '';
        }
        if (typeof value !== 'string' && typeof value !== 'number') {
            throw new TypeError('invalid header extension parameter');
        }
    }
}
/**
 * Validates RtpEncodingParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtpEncodingParameters(encoding) {
    if (typeof encoding !== 'object') {
        throw new TypeError('encoding is not an object');
    }
    // ssrc is optional.
    if (encoding.ssrc && typeof encoding.ssrc !== 'number') {
        throw new TypeError('invalid encoding.ssrc');
    }
    // rid is optional.
    if (encoding.rid && typeof encoding.rid !== 'string') {
        throw new TypeError('invalid encoding.rid');
    }
    // rtx is optional.
    if (encoding.rtx && typeof encoding.rtx !== 'object') {
        throw new TypeError('invalid encoding.rtx');
    }
    else if (encoding.rtx) {
        // RTX ssrc is mandatory if rtx is present.
        if (typeof encoding.rtx.ssrc !== 'number') {
            throw new TypeError('missing encoding.rtx.ssrc');
        }
    }
    // dtx is optional. If unset set it to false.
    if (!encoding.dtx || typeof encoding.dtx !== 'boolean') {
        encoding.dtx = false;
    }
    // scalabilityMode is optional.
    if (encoding.scalabilityMode &&
        typeof encoding.scalabilityMode !== 'string') {
        throw new TypeError('invalid encoding.scalabilityMode');
    }
}
/**
 * Validates RtcpParameters. It may modify given data by adding missing
 * fields with default values.
 * It throws if invalid.
 */
function validateAndNormalizeRtcpParameters(rtcp) {
    if (typeof rtcp !== 'object') {
        throw new TypeError('rtcp is not an object');
    }
    // cname is optional.
    if (rtcp.cname && typeof rtcp.cname !== 'string') {
        throw new TypeError('invalid rtcp.cname');
    }
    // reducedSize is optional. If unset set it to true.
    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean') {
        rtcp.reducedSize = true;
    }
}
/**
 * Validates NumSctpStreams.
 * It throws if invalid.
 */
function validateNumSctpStreams(numStreams) {
    if (typeof numStreams !== 'object') {
        throw new TypeError('numStreams is not an object');
    }
    // OS is mandatory.
    if (typeof numStreams.OS !== 'number') {
        throw new TypeError('missing numStreams.OS');
    }
    // MIS is mandatory.
    if (typeof numStreams.MIS !== 'number') {
        throw new TypeError('missing numStreams.MIS');
    }
}
function isRtxCodec(codec) {
    if (!codec) {
        return false;
    }
    return /.+\/rtx$/i.test(codec.mimeType);
}
function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
    const aMimeType = aCodec.mimeType.toLowerCase();
    const bMimeType = bCodec.mimeType.toLowerCase();
    if (aMimeType !== bMimeType) {
        return false;
    }
    if (aCodec.clockRate !== bCodec.clockRate) {
        return false;
    }
    if (aCodec.channels !== bCodec.channels) {
        return false;
    }
    // Per codec special checks.
    switch (aMimeType) {
        case 'video/h264': {
            if (strict) {
                const aPacketizationMode = aCodec.parameters['packetization-mode'] ?? 0;
                const bPacketizationMode = bCodec.parameters['packetization-mode'] ?? 0;
                if (aPacketizationMode !== bPacketizationMode) {
                    return false;
                }
                if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
                    return false;
                }
                let selectedProfileLevelId;
                try {
                    selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
                }
                catch (error) {
                    return false;
                }
                if (modify) {
                    if (selectedProfileLevelId) {
                        aCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                        bCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                    }
                    else {
                        delete aCodec.parameters['profile-level-id'];
                        delete bCodec.parameters['profile-level-id'];
                    }
                }
            }
            break;
        }
        case 'video/vp9': {
            if (strict) {
                const aProfileId = aCodec.parameters['profile-id'] ?? 0;
                const bProfileId = bCodec.parameters['profile-id'] ?? 0;
                if (aProfileId !== bProfileId) {
                    return false;
                }
            }
            break;
        }
    }
    return true;
}
function matchHeaderExtensions(aExt, bExt) {
    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
        return false;
    }
    if (aExt.uri !== bExt.uri) {
        return false;
    }
    return true;
}
function reduceRtcpFeedback(codecA, codecB) {
    const reducedRtcpFeedback = [];
    for (const aFb of codecA.rtcpFeedback ?? []) {
        const matchingBFb = (codecB.rtcpFeedback ?? []).find((bFb) => bFb.type === aFb.type &&
            (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter)));
        if (matchingBFb) {
            reducedRtcpFeedback.push(matchingBFb);
        }
    }
    return reducedRtcpFeedback;
}


/***/ }),

/***/ 8056:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));

/***/ }),

/***/ 8057:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });


/***/ }),

/***/ 8124:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));

/***/ }),

/***/ 8274:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const debug = __webpack_require__(7833);
const LIB_NAME = 'awaitqueue';
class Logger {
    _debug;
    _warn;
    _error;
    constructor(prefix) {
        if (prefix) {
            this._debug = debug(`${LIB_NAME}:${prefix}`);
            this._warn = debug(`${LIB_NAME}:WARN:${prefix}`);
            this._error = debug(`${LIB_NAME}:ERROR:${prefix}`);
        }
        else {
            this._debug = debug(LIB_NAME);
            this._warn = debug(`${LIB_NAME}:WARN`);
            this._error = debug(`${LIB_NAME}:ERROR`);
        }
        /* eslint-disable no-console */
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
        /* eslint-enable no-console */
    }
    get debug() {
        return this._debug;
    }
    get warn() {
        return this._warn;
    }
    get error() {
        return this._error;
    }
}
exports.Logger = Logger;


/***/ }),

/***/ 8278:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ag: () => (/* binding */ isE2EESupported),
/* harmony export */   Wm: () => (/* binding */ isScriptTransformSupported),
/* harmony export */   sn: () => (/* binding */ createKeyMaterialFromString),
/* harmony export */   tr: () => (/* binding */ createKeyMaterialFromBuffer)
/* harmony export */ });
/* unused harmony exports isInsertableStreamSupported, isVideoFrame, importKey, deriveKeys, createE2EEKey, ratchet, needsRbspUnescaping, parseRbsp, writeRbsp, mimeTypeToVideoCodecString */
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(467);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4756);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1806);



function isE2EESupported() {
  return isInsertableStreamSupported() || isScriptTransformSupported();
}
function isScriptTransformSupported() {
  // @ts-ignore
  return typeof window.RTCRtpScriptTransform !== 'undefined';
}
function isInsertableStreamSupported() {
  return typeof window.RTCRtpSender !== 'undefined' &&
  // @ts-ignore
  typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined';
}
function isVideoFrame(frame) {
  return 'type' in frame;
}
function importKey(_x) {
  return _importKey.apply(this, arguments);
}
function _importKey() {
  _importKey = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(keyBytes) {
    var algorithm,
      usage,
      _args = arguments;
    return _regeneratorRuntime.wrap(function (_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          algorithm = _args.length > 1 && _args[1] !== undefined ? _args[1] : {
            name: ENCRYPTION_ALGORITHM
          };
          usage = _args.length > 2 && _args[2] !== undefined ? _args[2] : 'encrypt';
          return _context.abrupt("return", crypto.subtle.importKey('raw', keyBytes, algorithm, false, usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt']));
        case 1:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _importKey.apply(this, arguments);
}
function createKeyMaterialFromString(_x2) {
  return _createKeyMaterialFromString.apply(this, arguments);
}
function _createKeyMaterialFromString() {
  _createKeyMaterialFromString = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(password) {
    var enc, keyMaterial;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function (_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          enc = new TextEncoder();
          _context2.next = 1;
          return crypto.subtle.importKey('raw', enc.encode(password), {
            name: 'PBKDF2'
          }, false, ['deriveBits', 'deriveKey']);
        case 1:
          keyMaterial = _context2.sent;
          return _context2.abrupt("return", keyMaterial);
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _createKeyMaterialFromString.apply(this, arguments);
}
function createKeyMaterialFromBuffer(_x3) {
  return _createKeyMaterialFromBuffer.apply(this, arguments);
}
function _createKeyMaterialFromBuffer() {
  _createKeyMaterialFromBuffer = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee3(cryptoBuffer) {
    var keyMaterial;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function (_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 1;
          return crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, ['deriveBits', 'deriveKey']);
        case 1:
          keyMaterial = _context3.sent;
          return _context3.abrupt("return", keyMaterial);
        case 2:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _createKeyMaterialFromBuffer.apply(this, arguments);
}
function getAlgoOptions(algorithmName, salt) {
  var textEncoder = new TextEncoder();
  var encodedSalt = textEncoder.encode(salt);
  switch (algorithmName) {
    case 'HKDF':
      return {
        name: 'HKDF',
        salt: encodedSalt,
        hash: 'SHA-256',
        info: new ArrayBuffer(128)
      };
    case 'PBKDF2':
      {
        return {
          name: 'PBKDF2',
          salt: encodedSalt,
          hash: 'SHA-256',
          iterations: 100000
        };
      }
    default:
      throw new Error("algorithm ".concat(algorithmName, " is currently unsupported"));
  }
}
/**
 * Derives a set of keys from the master key.
 * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1
 */
function deriveKeys(_x4, _x5) {
  return _deriveKeys.apply(this, arguments);
}
function _deriveKeys() {
  _deriveKeys = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(material, salt) {
    var algorithmOptions, encryptionKey;
    return _regeneratorRuntime.wrap(function (_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          algorithmOptions = getAlgoOptions(material.algorithm.name, salt); // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF
          // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
          _context4.next = 1;
          return crypto.subtle.deriveKey(algorithmOptions, material, {
            name: ENCRYPTION_ALGORITHM,
            length: 128
          }, false, ['encrypt', 'decrypt']);
        case 1:
          encryptionKey = _context4.sent;
          return _context4.abrupt("return", {
            material: material,
            encryptionKey: encryptionKey
          });
        case 2:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _deriveKeys.apply(this, arguments);
}
function createE2EEKey() {
  return window.crypto.getRandomValues(new Uint8Array(32));
}
/**
 * Ratchets a key. See
 * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1
 */
function ratchet(_x6, _x7) {
  return _ratchet.apply(this, arguments);
}
function _ratchet() {
  _ratchet = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(material, salt) {
    var algorithmOptions;
    return _regeneratorRuntime.wrap(function (_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          algorithmOptions = getAlgoOptions(material.algorithm.name, salt); // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits
          return _context5.abrupt("return", crypto.subtle.deriveBits(algorithmOptions, material, 256));
        case 1:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _ratchet.apply(this, arguments);
}
function needsRbspUnescaping(frameData) {
  for (var i = 0; i < frameData.length - 3; i++) {
    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;
  }
  return false;
}
function parseRbsp(stream) {
  var dataOut = [];
  var length = stream.length;
  for (var i = 0; i < stream.length;) {
    // Be careful about over/underflow here. byte_length_ - 3 can underflow, and
    // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_
    // above, and that expression will produce the number of bytes left in
    // the stream including the byte at i.
    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {
      // Two rbsp bytes.
      dataOut.push(stream[i++]);
      dataOut.push(stream[i++]);
      // Skip the emulation byte.
      i++;
    } else {
      // Single rbsp byte.
      dataOut.push(stream[i++]);
    }
  }
  return new Uint8Array(dataOut);
}
var kZerosInStartSequence = 2;
var kEmulationByte = 3;
function writeRbsp(data_in) {
  var dataOut = [];
  var numConsecutiveZeros = 0;
  for (var i = 0; i < data_in.length; ++i) {
    var _byte = data_in[i];
    if (_byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {
      // Need to escape.
      dataOut.push(kEmulationByte);
      numConsecutiveZeros = 0;
    }
    dataOut.push(_byte);
    if (_byte == 0) {
      ++numConsecutiveZeros;
    } else {
      numConsecutiveZeros = 0;
    }
  }
  return new Uint8Array(dataOut);
}
function mimeTypeToVideoCodecString(mimeType) {
  return mimeType.split('/')[1].toLowerCase();
}

/***/ }),

/***/ 8454:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(7165));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));

/***/ }),

/***/ 8624:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DOMException: () => (/* binding */ DOMException),
/* harmony export */   Headers: () => (/* binding */ Headers),
/* harmony export */   Request: () => (/* binding */ Request),
/* harmony export */   Response: () => (/* binding */ Response),
/* harmony export */   fetch: () => (/* binding */ fetch)
/* harmony export */ });
/* eslint-disable no-prototype-builtins */
var g =
  (typeof globalThis !== 'undefined' && globalThis) ||
  (typeof self !== 'undefined' && self) ||
  // eslint-disable-next-line no-undef
  (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g) ||
  {}

var support = {
  searchParams: 'URLSearchParams' in g,
  iterable: 'Symbol' in g && 'iterator' in Symbol,
  blob:
    'FileReader' in g &&
    'Blob' in g &&
    (function() {
      try {
        new Blob()
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in g,
  arrayBuffer: 'ArrayBuffer' in g
}

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ]

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
    throw new TypeError('Invalid character in header field name: "' + name + '"')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      if (header.length != 2) {
        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length)
      }
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries
}

function consumed(body) {
  if (body._noBody) return
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result)
    }
    reader.onerror = function() {
      reject(reader.error)
    }
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  reader.readAsArrayBuffer(blob)
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader()
  var promise = fileReaderReady(reader)
  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type)
  var encoding = match ? match[1] : 'utf-8'
  reader.readAsText(blob, encoding)
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf)
  var chars = new Array(view.length)

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i])
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength)
    view.set(new Uint8Array(buf))
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false

  this._initBody = function(body) {
    /*
      fetch-mock wraps the Response object in an ES6 Proxy to
      provide useful test harness features such as flush. However, on
      ES5 browsers without fetch or Proxy support pollyfills must be used;
      the proxy-pollyfill is unable to proxy an attribute unless it exists
      on the object before the Proxy is created. This change ensures
      Response.bodyUsed exists on the instance, while maintaining the
      semantic of setting Request.bodyUsed in the constructor before
      _initBody is called.
    */
    // eslint-disable-next-line no-self-assign
    this.bodyUsed = this.bodyUsed
    this._bodyInit = body
    if (!body) {
      this._noBody = true;
      this._bodyText = ''
    } else if (typeof body === 'string') {
      this._bodyText = body
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString()
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer)
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer])
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body)
    } else {
      this._bodyText = body = Object.prototype.toString.call(body)
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8')
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type)
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
      }
    }
  }

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    }
  }

  this.arrayBuffer = function() {
    if (this._bodyArrayBuffer) {
      var isConsumed = consumed(this)
      if (isConsumed) {
        return isConsumed
      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
        return Promise.resolve(
          this._bodyArrayBuffer.buffer.slice(
            this._bodyArrayBuffer.byteOffset,
            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
          )
        )
      } else {
        return Promise.resolve(this._bodyArrayBuffer)
      }
    } else if (support.blob) {
      return this.blob().then(readBlobAsArrayBuffer)
    } else {
      throw new Error('could not read as ArrayBuffer')
    }
  }

  this.text = function() {
    var rejected = consumed(this)
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  }

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    }
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }

  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url
    this.credentials = input.credentials
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    this.mode = input.mode
    this.signal = input.signal
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
      input.bodyUsed = true
    }
  } else {
    this.url = String(input)
  }

  this.credentials = options.credentials || this.credentials || 'same-origin'
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')
  this.mode = options.mode || this.mode || null
  this.signal = options.signal || this.signal || (function () {
    if ('AbortController' in g) {
      var ctrl = new AbortController();
      return ctrl.signal;
    }
  }());
  this.referrer = null

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)

  if (this.method === 'GET' || this.method === 'HEAD') {
    if (options.cache === 'no-store' || options.cache === 'no-cache') {
      // Search for a '_' parameter in the query string
      var reParamSearch = /([?&])_=[^&]*/
      if (reParamSearch.test(this.url)) {
        // If it already exists then set the value with the current time
        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())
      } else {
        // Otherwise add a new '_' parameter to the end with the current time
        var reQueryString = /\?/
        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
      }
    }
  }
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

function decode(body) {
  var form = new FormData()
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers()
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
  // https://github.com/github/fetch/issues/748
  // https://github.com/zloirock/core-js/issues/751
  preProcessedHeaders
    .split('\r')
    .map(function(header) {
      return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
    })
    .forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        try {
          headers.append(key, value)
        } catch (error) {
          console.warn('Response ' + error.message)
        }
      }
    })
  return headers
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
  }
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  if (this.status < 200 || this.status > 599) {
    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].")
  }
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = options.statusText === undefined ? '' : '' + options.statusText
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 200, statusText: ''})
  response.ok = false
  response.status = 0
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

var DOMException = g.DOMException
try {
  new DOMException()
} catch (err) {
  DOMException = function(message, name) {
    this.message = message
    this.name = name
    var error = Error(message)
    this.stack = error.stack
  }
  DOMException.prototype = Object.create(Error.prototype)
  DOMException.prototype.constructor = DOMException
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest()

    function abortXhr() {
      xhr.abort()
    }

    xhr.onload = function() {
      var options = {
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      }
      // This check if specifically for when a user fetches a file locally from the file system
      // Only if the status is out of a normal range
      if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
        options.status = 200;
      } else {
        options.status = xhr.status;
      }
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
      var body = 'response' in xhr ? xhr.response : xhr.responseText
      setTimeout(function() {
        resolve(new Response(body, options))
      }, 0)
    }

    xhr.onerror = function() {
      setTimeout(function() {
        reject(new TypeError('Network request failed'))
      }, 0)
    }

    xhr.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError('Network request timed out'))
      }, 0)
    }

    xhr.onabort = function() {
      setTimeout(function() {
        reject(new DOMException('Aborted', 'AbortError'))
      }, 0)
    }

    function fixUrl(url) {
      try {
        return url === '' && g.location.href ? g.location.href : url
      } catch (e) {
        return url
      }
    }

    xhr.open(request.method, fixUrl(request.url), true)

    if (request.credentials === 'include') {
      xhr.withCredentials = true
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false
    }

    if ('responseType' in xhr) {
      if (support.blob) {
        xhr.responseType = 'blob'
      } else if (
        support.arrayBuffer
      ) {
        xhr.responseType = 'arraybuffer'
      }
    }

    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {
      var names = [];
      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
        names.push(normalizeName(name))
        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))
      })
      request.headers.forEach(function(value, name) {
        if (names.indexOf(name) === -1) {
          xhr.setRequestHeader(name, value)
        }
      })
    } else {
      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })
    }

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr)

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr)
        }
      }
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
  })
}

fetch.polyfill = true

if (!g.fetch) {
  g.fetch = fetch
  g.Headers = Headers
  g.Request = Request
  g.Response = Response
}


/***/ }),

/***/ 8876:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = exports.AwaitQueue = void 0;
var AwaitQueue_1 = __webpack_require__(9275);
Object.defineProperty(exports, "AwaitQueue", ({ enumerable: true, get: function () { return AwaitQueue_1.AwaitQueue; } }));
var errors_1 = __webpack_require__(4253);
Object.defineProperty(exports, "AwaitQueueStoppedError", ({ enumerable: true, get: function () { return errors_1.AwaitQueueStoppedError; } }));
Object.defineProperty(exports, "AwaitQueueRemovedTaskError", ({ enumerable: true, get: function () { return errors_1.AwaitQueueRemovedTaskError; } }));


/***/ }),

/***/ 9021:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else // removed by dead control flow
{}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
	        crypto = __webpack_require__.g.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __webpack_require__(477);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ 9027:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ config)
/* harmony export */ });
var config = {
  /**
   * Network priorities
   * DSCP bits set by browser according this priority values.
   * ("high" means actually: EF for audio, and AF41 for Video in chrome)
   * https://en.wikipedia.org/wiki/Differentiated_services
   */
  networkPriorities: {
    audio: "high",
    dominatingVideo: "high",
    otherVideos: "medium",
    screenShare: "medium"
  },
  // The aspect ratio of the videos as shown on the screen.
  // This is changeable in client settings.
  // This value must match one of the defined values in
  // aspectRatios EXACTLY (e.g. 1.333)
  aspectRatios: {
    fourThree: {
      label: "fourThree",
      value: 1.333
    },
    oneSixNine: {
      label: "oneSixNine",
      value: 1.777
    }
  },
  audioProfiles: {
    speech_low_quality: {
      sampleRate: 16000,
      bitRate: 24,
      sampleSize: 16,
      stereo: false,
      dtx: true,
      fec: true,
      maxPlaybackRate: 16000,
      packetTime: 20,
      autoGainControl: true,
      echoCancellation: true,
      noiseSuppression: true,
      channelCount: 1
    },
    speech_standard: {
      sampleRate: 32000,
      bitRate: 24,
      sampleSize: 24,
      stereo: false,
      dtx: true,
      fec: true,
      maxPlaybackRate: 32000,
      packetTime: 30,
      autoGainControl: true,
      echoCancellation: true,
      noiseSuppression: true,
      channelCount: 1
    },
    music_standard: {
      sampleRate: 48000,
      bitRate: 40,
      sampleSize: 32,
      stereo: false,
      dtx: false,
      fec: true,
      maxPlaybackRate: 48000,
      packetTime: 40,
      autoGainControl: false,
      echoCancellation: false,
      noiseSuppression: false,
      channelCount: 1
    },
    standard_stereo: {
      sampleRate: 48000,
      sampleSize: 32,
      bitRate: 64,
      stereo: true,
      dtx: false,
      fec: true,
      maxPlaybackRate: 48000,
      packetTime: 40,
      autoGainControl: false,
      echoCancellation: false,
      noiseSuppression: false,
      channelCount: 2
    },
    high_quality: {
      sampleRate: 48000,
      sampleSize: 32,
      bitRate: 128,
      stereo: false,
      dtx: false,
      fec: true,
      maxPlaybackRate: 48000,
      packetTime: 60,
      autoGainControl: false,
      echoCancellation: false,
      noiseSuppression: false,
      channelCount: 1
    },
    high_quality_stereo: {
      sampleRate: 48000,
      sampleSize: 32,
      bitRate: 192,
      stereo: true,
      dtx: false,
      fec: true,
      maxPlaybackRate: 48000,
      packetTime: 60,
      autoGainControl: false,
      echoCancellation: false,
      noiseSuppression: false,
      channelCount: 2
    }
  },
  videoProfiles: {
    // TODO: portrait mode
    h90p_w160p: {
      width: 160,
      height: 90,
      bitRate: 60 * 1000,
      frameRate: 15,
      aspectRatio: "oneSixNine"
    },
    h180p_w320p: {
      width: 320,
      height: 180,
      bitRate: 120 * 1000,
      frameRate: 15,
      aspectRatio: "oneSixNine"
    },
    h216p_w384p: {
      width: 384,
      height: 216,
      bitRate: 180 * 1000,
      frameRate: 15,
      aspectRatio: "oneSixNine"
    },
    h360p_w640p: {
      width: 640,
      height: 360,
      bitRate: 300 * 1000,
      frameRate: 20,
      aspectRatio: "oneSixNine"
    },
    h360p_w640p_150kbps: {
      width: 640,
      height: 360,
      bitRate: 150 * 1000,
      frameRate: 15,
      aspectRatio: "oneSixNine"
    },
    h540p_w960p: {
      width: 960,
      height: 540,
      bitRate: 600 * 1000,
      frameRate: 25,
      aspectRatio: "oneSixNine"
    },
    h540p_w960p_500kbps: {
      width: 960,
      height: 540,
      bitRate: 500 * 1000,
      frameRate: 25,
      aspectRatio: "oneSixNine"
    },
    h720p_w1280p: {
      width: 1280,
      height: 720,
      bitRate: 2000 * 1000,
      frameRate: 30,
      aspectRatio: "oneSixNine"
    },
    h1080p_w1920p: {
      width: 1920,
      height: 1080,
      bitRate: 3000 * 1000,
      frameRate: 30,
      aspectRatio: "oneSixNine"
    },
    h1440p_w2560p: {
      width: 2560,
      height: 1440,
      bitRate: 5000 * 1000,
      frameRate: 30,
      aspectRatio: "oneSixNine"
    },
    h2160p_w3840p: {
      width: 3840,
      height: 2160,
      bitRate: 8000 * 1000,
      frameRate: 30,
      aspectRatio: "oneSixNine"
    },
    h120p_w160p: {
      width: 160,
      height: 120,
      bitRate: 80 * 1000,
      frameRate: 15,
      aspectRatio: "fourThree"
    },
    h180p_w240p: {
      width: 240,
      height: 180,
      bitRate: 100 * 1000,
      frameRate: 15,
      aspectRatio: "fourThree"
    },
    h240p_w320p: {
      width: 320,
      height: 240,
      bitRate: 150 * 1000,
      frameRate: 15,
      aspectRatio: "fourThree"
    },
    h360p_w480p: {
      width: 480,
      height: 360,
      bitRate: 225 * 1000,
      frameRate: 20,
      aspectRatio: "fourThree"
    },
    h480p_w640p: {
      width: 640,
      height: 480,
      bitRate: 300 * 1000,
      frameRate: 25,
      aspectRatio: "fourThree"
    },
    h540p_w720p: {
      width: 720,
      height: 540,
      bitRate: 450 * 1000,
      frameRate: 30,
      aspectRatio: "fourThree"
    },
    h720p_w960p: {
      width: 960,
      height: 720,
      bitRate: 1500 * 1000,
      frameRate: 30,
      aspectRatio: "fourThree"
    },
    h1080p_w1440p: {
      width: 1440,
      height: 1080,
      bitRate: 2500 * 1000,
      frameRate: 30,
      aspectRatio: "fourThree"
    },
    h1440p_w1920p: {
      width: 1920,
      height: 1440,
      bitRate: 3500 * 1000,
      frameRate: 30,
      aspectRatio: "fourThree"
    }
  },
  // OLD Profiles
  // screenShareProfiles: {
  //   h360p_30fps: {
  //     width: 640,
  //     height: 360,
  //     bitRate: 200 * 1000,
  //     frameRate: 30,
  //   },
  //   h720p_5fps: {
  //     width: 1280,
  //     height: 720,
  //     bitRate: 400 * 1000,
  //     frameRate: 5,
  //   },
  //   h720p_15fps: {
  //     width: 1280,
  //     height: 720,
  //     bitRate: 1000 * 1000,
  //     frameRate: 15,
  //   },
  //   h1080p_15fps: {
  //     width: 1920,
  //     height: 1080,
  //     bitRate: 1500 * 1000,
  //     frameRate: 15,
  //   },
  //   h1080p_30fps: {
  //     width: 1920,
  //     height: 1080,
  //     bitRate: 1000 * 1000,
  //     frameRate: 30,
  //   },
  // },
  // Define different encodings for various resolutions of the video.
  // New Profiles
  screenShareProfiles: {
    h360p_30fps: {
      resolution: {
        width: 640,
        height: 360
      },
      frameRate: 30,
      bitrates: {
        high: 400000,
        // 400 kbps
        medium: 200000,
        // 200 kbps
        low: 100000 // 100 kbps
      }
    },
    h480p_15fps: {
      resolution: {
        width: 854,
        height: 480
      },
      frameRate: 15,
      bitrates: {
        high: 300000,
        medium: 150000,
        low: 75000
      }
    },
    h480p_30fps: {
      resolution: {
        width: 854,
        height: 480
      },
      frameRate: 30,
      bitrates: {
        high: 500000,
        medium: 250000,
        low: 125000
      }
    },
    h720p_5fps: {
      resolution: {
        width: 1280,
        height: 720
      },
      frameRate: 5,
      bitrates: {
        high: 400000,
        medium: 200000,
        low: 100000
      }
    },
    h720p_15fps: {
      resolution: {
        width: 1280,
        height: 720
      },
      frameRate: 15,
      bitrates: {
        high: 1000000,
        medium: 500000,
        low: 250000
      }
    },
    h720p_30fps: {
      resolution: {
        width: 1280,
        height: 720
      },
      frameRate: 30,
      bitrates: {
        high: 1500000,
        medium: 750000,
        low: 375000
      }
    },
    h1080p_15fps: {
      resolution: {
        width: 1920,
        height: 1080
      },
      frameRate: 15,
      bitrates: {
        high: 1500000,
        medium: 750000,
        low: 300000
      }
    },
    h1080p_30fps: {
      resolution: {
        width: 1920,
        height: 1080
      },
      frameRate: 30,
      bitrates: {
        high: 2000000,
        // 2 Mbps
        medium: 1000000,
        // 1 Mbps
        low: 500000 // 500 kbps
      }
    }
  },
  simulcastProfiles: {
    3840: [{
      scaleResolutionDownBy: 12,
      maxBitRate: 150 * 1000
    }, {
      scaleResolutionDownBy: 6,
      maxBitRate: 500 * 1000
    }, {
      scaleResolutionDownBy: 1,
      maxBitRate: 1000 * 10000
    }],
    1920: [{
      scaleResolutionDownBy: 6,
      maxBitRate: 150 * 1000
    }, {
      scaleResolutionDownBy: 3,
      maxBitRate: 500 * 1000
    }, {
      scaleResolutionDownBy: 1,
      maxBitRate: 350 * 10000
    }],
    1280: [{
      scaleResolutionDownBy: 4,
      maxBitRate: 150 * 1000
    }, {
      scaleResolutionDownBy: 2,
      maxBitRate: 500 * 1000
    }, {
      scaleResolutionDownBy: 1,
      maxBitRate: 120 * 10000
    }],
    640: [{
      scaleResolutionDownBy: 2,
      maxBitRate: 150 * 1000
    }, {
      scaleResolutionDownBy: 1,
      maxBitRate: 500 * 1000
    }],
    320: [{
      scaleResolutionDownBy: 1,
      maxBitRate: 150 * 1000
    }]
  },
  // The Socket.io request timeout.
  requestTimeout: 20000,
  // The Socket.io request maximum retries.
  requestRetries: 3,
  // The Mediasoup transport options.
  transportOptions: {
    tcp: true
  },
  // Used for VP9 webcam video.
  videoKSVCEncodings: [{
    scalabilityMode: "S3T3_KEY"
  }],
  // Used for VP9 desktop sharing.
  videoSVCEncodings: [{
    scalabilityMode: "S3T3",
    dtx: true
  }]
};

/***/ }),

/***/ 9166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataConsumer = void 0;
const Logger_1 = __webpack_require__(2994);
const enhancedEvents_1 = __webpack_require__(3953);
const logger = new Logger_1.Logger('DataConsumer');
class DataConsumer extends enhancedEvents_1.EnhancedEventEmitter {
    // Id.
    _id;
    // Associated DataProducer Id.
    _dataProducerId;
    // The underlying RTCDataChannel instance.
    _dataChannel;
    // Closed flag.
    _closed = false;
    // SCTP stream parameters.
    _sctpStreamParameters;
    // App custom data.
    _appData;
    // Observer instance.
    _observer = new enhancedEvents_1.EnhancedEventEmitter();
    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData, }) {
        super();
        logger.debug('constructor()');
        this._id = id;
        this._dataProducerId = dataProducerId;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData ?? {};
        this.handleDataChannel();
    }
    /**
     * DataConsumer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Associated DataProducer id.
     */
    get dataProducerId() {
        return this._dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
        return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
        return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
        return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
        return this._dataChannel.protocol;
    }
    /**
     * DataChannel binaryType.
     */
    get binaryType() {
        return this._dataChannel.binaryType;
    }
    /**
     * Set DataChannel binaryType.
     */
    set binaryType(binaryType) {
        this._dataChannel.binaryType = binaryType;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the DataConsumer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this._dataChannel.close();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
        this._observer.close();
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    handleDataChannel() {
        this._dataChannel.addEventListener('open', () => {
            if (this._closed) {
                return;
            }
            logger.debug('DataChannel "open" event');
            this.safeEmit('open');
        });
        this._dataChannel.addEventListener('error', event => {
            if (this._closed) {
                return;
            }
            const error = event.error ?? new Error('unknown DataChannel error');
            if (event.error?.errorDetail === 'sctp-failure') {
                logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', event.error?.sctpCauseCode, event.error.message);
            }
            else {
                logger.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit('error', error);
        });
        this._dataChannel.addEventListener('close', () => {
            if (this._closed) {
                return;
            }
            logger.warn('DataChannel "close" event');
            this._closed = true;
            this.emit('@close');
            this.safeEmit('close');
            // Emit observer event.
            this._observer.safeEmit('close');
        });
        this._dataChannel.addEventListener('message', event => {
            if (this._closed) {
                return;
            }
            this.safeEmit('message', event.data);
        });
    }
}
exports.DataConsumer = DataConsumer;


/***/ }),

/***/ 9275:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwaitQueue = void 0;
const Logger_1 = __webpack_require__(8274);
const errors_1 = __webpack_require__(4253);
const logger = new Logger_1.Logger('AwaitQueue');
class AwaitQueue {
    // Queue of pending tasks (map of PendingTasks indexed by id).
    pendingTasks = new Map();
    // Incrementing PendingTask id.
    nextTaskId = 0;
    constructor() {
        logger.debug('constructor()');
    }
    get size() {
        return this.pendingTasks.size;
    }
    async push(task, name, options) {
        name = name ?? task.name;
        logger.debug(`push() [name:${name}, options:%o]`, options);
        if (typeof task !== 'function') {
            throw new TypeError('given task is not a function');
        }
        if (name) {
            try {
                Object.defineProperty(task, 'name', { value: name });
            }
            catch (error) { }
        }
        return new Promise((resolve, reject) => {
            if (name && options?.removeOngoingTasksWithSameName) {
                for (const pendingTask of this.pendingTasks.values()) {
                    if (pendingTask.name === name) {
                        pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError(), {
                            canExecuteNextTask: false,
                        });
                    }
                }
            }
            const pendingTask = {
                id: this.nextTaskId++,
                task: task,
                name: name,
                enqueuedAt: Date.now(),
                executedAt: undefined,
                completed: false,
                resolve: (result) => {
                    // pendingTask.resolve() can only be called in execute() method. Since
                    // resolve() was called it means that the task successfully completed.
                    // However the task may have been stopped before it completed (via
                    // stop() or remove()) so its completed flag was already set. If this
                    // is the case, abort here since next task (if any) is already being
                    // executed.
                    if (pendingTask.completed) {
                        return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    this.pendingTasks.delete(pendingTask.id);
                    logger.debug(`resolving task [name:${pendingTask.name}]`);
                    // Resolve the task with the obtained result.
                    resolve(result);
                    // Execute the next pending task (if any).
                    const [nextPendingTask] = this.pendingTasks.values();
                    // NOTE: During the resolve() callback the user app may have interacted
                    // with the queue. For instance, the app may have pushed a task while
                    // the queue was empty so such a task is already being executed. If so,
                    // don't execute it twice.
                    if (nextPendingTask && !nextPendingTask.executedAt) {
                        void this.execute(nextPendingTask);
                    }
                },
                reject: (error, { canExecuteNextTask }) => {
                    // pendingTask.reject() can be called within execute() method if the
                    // task completed with error. However it may have also been called in
                    // stop() or remove() methods (before or while being executed) so its
                    // completed flag was already set. If so, abort here since next task
                    // (if any) is already being executed.
                    if (pendingTask.completed) {
                        return;
                    }
                    pendingTask.completed = true;
                    // Remove the task from the queue.
                    this.pendingTasks.delete(pendingTask.id);
                    logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));
                    // Reject the task with the obtained error.
                    reject(error);
                    // May execute next pending task (if any).
                    if (canExecuteNextTask) {
                        const [nextPendingTask] = this.pendingTasks.values();
                        // NOTE: During the reject() callback the user app may have interacted
                        // with the queue. For instance, the app may have pushed a task while
                        // the queue was empty so such a task is already being executed. If so,
                        // don't execute it twice.
                        if (nextPendingTask && !nextPendingTask.executedAt) {
                            void this.execute(nextPendingTask);
                        }
                    }
                },
            };
            // Append task to the queue.
            this.pendingTasks.set(pendingTask.id, pendingTask);
            // And execute it if this is the only task in the queue.
            if (this.pendingTasks.size === 1) {
                void this.execute(pendingTask);
            }
        });
    }
    stop() {
        logger.debug('stop()');
        for (const pendingTask of this.pendingTasks.values()) {
            logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);
            pendingTask.reject(new errors_1.AwaitQueueStoppedError(), {
                canExecuteNextTask: false,
            });
        }
    }
    remove(taskIdx) {
        logger.debug(`remove() [taskIdx:${taskIdx}]`);
        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
        if (!pendingTask) {
            logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
            return;
        }
        pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError(), {
            canExecuteNextTask: true,
        });
    }
    dump() {
        const now = Date.now();
        let idx = 0;
        return Array.from(this.pendingTasks.values()).map(pendingTask => ({
            idx: idx++,
            task: pendingTask.task,
            name: pendingTask.name,
            enqueuedTime: pendingTask.executedAt
                ? pendingTask.executedAt - pendingTask.enqueuedAt
                : now - pendingTask.enqueuedAt,
            executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0,
        }));
    }
    async execute(pendingTask) {
        logger.debug(`execute() [name:${pendingTask.name}]`);
        if (pendingTask.executedAt) {
            throw new Error('task already being executed');
        }
        pendingTask.executedAt = Date.now();
        try {
            const result = await pendingTask.task();
            // Resolve the task with its resolved result (if any).
            pendingTask.resolve(result);
        }
        catch (error) {
            // Reject the task with its rejected error.
            pendingTask.reject(error, { canExecuteNextTask: true });
        }
    }
}
exports.AwaitQueue = AwaitQueue;


/***/ }),

/***/ 9506:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(5471), __webpack_require__(1025));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),

/***/ 9557:
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory, undef) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(9021), __webpack_require__(3240), __webpack_require__(1380));
	}
	else // removed by dead control flow
{}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));

/***/ }),

/***/ 9633:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   l: () => (/* binding */ ExternalE2EEKeyProvider)
/* harmony export */ });
/* unused harmony export BaseKeyProvider */
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(467);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3029);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2901);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(388);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3954);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5501);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4756);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7007);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1806);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6746);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8278);







function _callSuper(t, o, e) { return o = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(o), (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }




/**
 * @experimental
 */
var BaseKeyProvider = /*#__PURE__*/function (_EventEmitter) {
  function BaseKeyProvider() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this, BaseKeyProvider);
    _this = _callSuper(this, BaseKeyProvider);
    /**
     * callback being invoked after a ratchet request has been performed on a participant
     * that surfaces the new key material.
     * @param material
     * @param keyIndex
     */
    _this.onKeyRatcheted = function (material, keyIndex) {
      console.debug('key ratcheted event received', {
        material: material,
        keyIndex: keyIndex
      });
    };
    _this.keyInfoMap = new Map();
    _this.options = Object.assign(Object.assign({}, _constants__WEBPACK_IMPORTED_MODULE_8__/* .KEY_PROVIDER_DEFAULTS */ .T4), options);
    _this.on(_events__WEBPACK_IMPORTED_MODULE_9__/* .KeyProviderEvent */ .fo.KeyRatcheted, _this.onKeyRatcheted);
    return _this;
  }
  /**
   * callback to invoke once a key has been set for a participant
   * @param key
   * @param participantIdentity
   * @param keyIndex
   */
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(BaseKeyProvider, _EventEmitter);
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(BaseKeyProvider, [{
    key: "onSetEncryptionKey",
    value: function onSetEncryptionKey(key, participantIdentity, keyIndex) {
      var keyInfo = {
        key: key,
        participantIdentity: participantIdentity,
        keyIndex: keyIndex
      };
      if (!this.options.sharedKey && !participantIdentity) {
        throw new Error('participant identity needs to be passed for encryption key if sharedKey option is false');
      }
      this.keyInfoMap.set("".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : 'shared', "-").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);
      this.emit(_events__WEBPACK_IMPORTED_MODULE_9__/* .KeyProviderEvent */ .fo.SetKey, keyInfo);
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      return Array.from(this.keyInfoMap.values());
    }
  }, {
    key: "getOptions",
    value: function getOptions() {
      return this.options;
    }
  }, {
    key: "ratchetKey",
    value: function ratchetKey(participantIdentity, keyIndex) {
      this.emit(_events__WEBPACK_IMPORTED_MODULE_9__/* .KeyProviderEvent */ .fo.RatchetRequest, participantIdentity, keyIndex);
    }
  }]);
}(events__WEBPACK_IMPORTED_MODULE_7__.EventEmitter);
/**
 * A basic KeyProvider implementation intended for a single shared
 * passphrase between all participants
 * @experimental
 */
var ExternalE2EEKeyProvider = /*#__PURE__*/function (_BaseKeyProvider) {
  function ExternalE2EEKeyProvider() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this, ExternalE2EEKeyProvider);
    var opts = Object.assign(Object.assign({}, options), {
      sharedKey: true,
      // for a shared key provider failing to decrypt for a specific participant
      // should not mark the key as invalid, so we accept wrong keys forever
      // and won't try to auto-ratchet
      ratchetWindowSize: 0,
      failureTolerance: -1
    });
    return _callSuper(this, ExternalE2EEKeyProvider, [opts]);
  }
  /**
   * Accepts a passphrase that's used to create the crypto keys.
   * When passing in a string, PBKDF2 is used.
   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)
   * @param key
   */
  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(ExternalE2EEKeyProvider, _BaseKeyProvider);
  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(ExternalE2EEKeyProvider, [{
    key: "setSharedKey",
    value: (function () {
      var _setSharedKey = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(/*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().mark(function _callee(key) {
        var derivedKey, _t;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().wrap(function (_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof key === 'string')) {
                _context.next = 2;
                break;
              }
              _context.next = 1;
              return (0,_utils__WEBPACK_IMPORTED_MODULE_10__/* .createKeyMaterialFromString */ .sn)(key);
            case 1:
              _t = _context.sent;
              _context.next = 4;
              break;
            case 2:
              _context.next = 3;
              return (0,_utils__WEBPACK_IMPORTED_MODULE_10__/* .createKeyMaterialFromBuffer */ .tr)(key);
            case 3:
              _t = _context.sent;
            case 4:
              derivedKey = _t;
              this.onSetEncryptionKey(derivedKey);
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function setSharedKey(_x) {
        return _setSharedKey.apply(this, arguments);
      }
      return setSharedKey;
    }())
  }]);
}(BaseKeyProvider);

/***/ }),

/***/ 9792:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Producer = void 0;
const Logger_1 = __webpack_require__(2994);
const enhancedEvents_1 = __webpack_require__(3953);
const errors_1 = __webpack_require__(4893);
const logger = new Logger_1.Logger('Producer');
class Producer extends enhancedEvents_1.EnhancedEventEmitter {
    // Id.
    _id;
    // Local id.
    _localId;
    // Closed flag.
    _closed = false;
    // Associated RTCRtpSender.
    _rtpSender;
    // Local track.
    _track;
    // Producer kind.
    _kind;
    // RTP parameters.
    _rtpParameters;
    // Paused flag.
    _paused;
    // Video max spatial layer.
    _maxSpatialLayer;
    // Whether the Producer should call stop() in given tracks.
    _stopTracks;
    // Whether the Producer should set track.enabled = false when paused.
    _disableTrackOnPause;
    // Whether we should replace the RTCRtpSender.track with null when paused.
    _zeroRtpOnPause;
    // App custom data.
    _appData;
    // Observer instance.
    _observer = new enhancedEvents_1.EnhancedEventEmitter();
    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData, }) {
        super();
        logger.debug('constructor()');
        this._id = id;
        this._localId = localId;
        this._rtpSender = rtpSender;
        this._track = track;
        this._kind = track.kind;
        this._rtpParameters = rtpParameters;
        this._paused = disableTrackOnPause ? !track.enabled : false;
        this._maxSpatialLayer = undefined;
        this._stopTracks = stopTracks;
        this._disableTrackOnPause = disableTrackOnPause;
        this._zeroRtpOnPause = zeroRtpOnPause;
        this._appData = appData ?? {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
        // '@replacetrack' event here, so RTCRtpSender.track won't be null.
        this.handleTrack();
    }
    /**
     * Producer id.
     */
    get id() {
        return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
        return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */
    get closed() {
        return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
        return this._kind;
    }
    /**
     * Associated RTCRtpSender.
     */
    get rtpSender() {
        return this._rtpSender;
    }
    /**
     * The associated track.
     */
    get track() {
        return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
        return this._rtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */
    get paused() {
        return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */
    get maxSpatialLayer() {
        return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */
    get appData() {
        return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
        this._appData = appData;
    }
    get observer() {
        return this._observer;
    }
    /**
     * Closes the Producer.
     */
    close() {
        if (this._closed) {
            return;
        }
        logger.debug('close()');
        this._closed = true;
        this.destroyTrack();
        this.emit('@close');
        // Emit observer event.
        this._observer.safeEmit('close');
        // Invoke close() in EnhancedEventEmitter classes.
        super.close();
        this._observer.close();
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
        if (this._closed) {
            return;
        }
        logger.debug('transportClosed()');
        this._closed = true;
        this.destroyTrack();
        this.safeEmit('transportclose');
        // Emit observer event.
        this._observer.safeEmit('close');
    }
    /**
     * Get associated RTCRtpSender stats.
     */
    async getStats() {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        return new Promise((resolve, reject) => {
            this.safeEmit('@getstats', resolve, reject);
        });
    }
    /**
     * Pauses sending media.
     */
    pause() {
        logger.debug('pause()');
        if (this._closed) {
            logger.error('pause() | Producer closed');
            return;
        }
        this._paused = true;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = false;
        }
        if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
                this.safeEmit('@pause', resolve, reject);
            }).catch(() => { });
        }
        // Emit observer event.
        this._observer.safeEmit('pause');
    }
    /**
     * Resumes sending media.
     */
    resume() {
        logger.debug('resume()');
        if (this._closed) {
            logger.error('resume() | Producer closed');
            return;
        }
        this._paused = false;
        if (this._track && this._disableTrackOnPause) {
            this._track.enabled = true;
        }
        if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
                this.safeEmit('@resume', resolve, reject);
            }).catch(() => { });
        }
        // Emit observer event.
        this._observer.safeEmit('resume');
    }
    /**
     * Replaces the current track with a new one or null.
     */
    async replaceTrack({ track, }) {
        logger.debug('replaceTrack() [track:%o]', track);
        if (this._closed) {
            // This must be done here. Otherwise there is no chance to stop the given
            // track.
            if (track && this._stopTracks) {
                try {
                    track.stop();
                }
                catch (error) { }
            }
            throw new errors_1.InvalidStateError('closed');
        }
        else if (track && track.readyState === 'ended') {
            throw new errors_1.InvalidStateError('track ended');
        }
        // Do nothing if this is the same track as the current handled one.
        if (track === this._track) {
            logger.debug('replaceTrack() | same track, ignored');
            return;
        }
        await new Promise((resolve, reject) => {
            this.safeEmit('@replacetrack', track, resolve, reject);
        });
        // Destroy the previous track.
        this.destroyTrack();
        // Set the new track.
        this._track = track;
        // If this Producer was paused/resumed and the state of the new
        // track does not match, fix it.
        if (this._track && this._disableTrackOnPause) {
            if (!this._paused) {
                this._track.enabled = true;
            }
            else if (this._paused) {
                this._track.enabled = false;
            }
        }
        // Handle the effective track.
        this.handleTrack();
    }
    /**
     * Sets the video max spatial layer to be sent.
     */
    async setMaxSpatialLayer(spatialLayer) {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (this._kind !== 'video') {
            throw new errors_1.UnsupportedError('not a video Producer');
        }
        else if (typeof spatialLayer !== 'number') {
            throw new TypeError('invalid spatialLayer');
        }
        if (spatialLayer === this._maxSpatialLayer) {
            return;
        }
        await new Promise((resolve, reject) => {
            this.safeEmit('@setmaxspatiallayer', spatialLayer, resolve, reject);
        }).catch(() => { });
        this._maxSpatialLayer = spatialLayer;
    }
    async setRtpEncodingParameters(params) {
        if (this._closed) {
            throw new errors_1.InvalidStateError('closed');
        }
        else if (typeof params !== 'object') {
            throw new TypeError('invalid params');
        }
        await new Promise((resolve, reject) => {
            this.safeEmit('@setrtpencodingparameters', params, resolve, reject);
        });
    }
    onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit('trackended');
        // Emit observer event.
        this._observer.safeEmit('trackended');
    }
    handleTrack() {
        if (!this._track) {
            return;
        }
        this._track.addEventListener('ended', this.onTrackEnded);
    }
    destroyTrack() {
        if (!this._track) {
            return;
        }
        try {
            this._track.removeEventListener('ended', this.onTrackEnded);
            // Just stop the track unless the app set stopTracks: false.
            if (this._stopTracks) {
                this._track.stop();
            }
        }
        catch (error) { }
    }
}
exports.Producer = Producer;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(1853);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});