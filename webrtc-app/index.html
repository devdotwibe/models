<!DOCTYPE html>
<html>
<head>
  <title>WebRTC Broadcast</title>
</head>
<body>
  <h2>WebRTC Live Broadcast</h2>

  <video id="localVideo" autoplay muted playsinline width="400" height="300" style="border:1px solid black;"></video>
  <video id="remoteVideo" autoplay muted playsinline width="400" height="300" style="border:1px solid black;"></video>

  <script>
    window.onload = () => {
      const params = new URLSearchParams(window.location.search);
      const roomId = params.get('room_id');
      const role = params.get('role'); // 'streamer' or 'viewer'

      if (!roomId || !role) {
        alert("Missing room_id or role in URL");
        return;
      }

      // const config = {
        
      //     iceServers: [
      //    {
      //         urls: [
      //           'stun:stun.l.google.com:19302',
      //           'stun:stun1.l.google.com:19302',
      //           'stun:stun2.l.google.com:19302'
      //         ]
      //       }
      //     ]
      //   };

    // const config = {
    //       iceServers: [
    //         {
    //           urls: "stun:stun.l.google.com:19302" 
    //         },
    //         {
    //           urls: 'turn:openrelay.metered.ca:80',
    //           username: 'openrelayproject',
    //           credential: 'openrelayproject'
    //         }
    //       ]
    // };
    
    const config = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.voiceeclipse.net:3478" },
        { urls: "stun:stun2.l.google.com:19302" },
        { urls: "stun:stun3.l.google.com:19302" },
        {
          urls: "turn.speed.cloudflare.com:50000",
          username: "e95ced883c1e5161e3478b5a01ef7e23acbc37ad79fa1a65ce9a73d6f1b557a390e3d3890957ee27d57c58183848965c4c15d723252904880aa08231947d4034@live.com",
          credential: "aba9b169546eb6dcc7bfb1cdf34544cf95b5161d602e3b5fa7c8342b2e9802fb"
        }
      ],
      iceTransportPolicy: "all"
    };


      // const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };


      let viewerId = Math.floor(Math.random() * 100000);
      let localStream;
      let roomConnections = {};
      let pc;

      // ---- STREAMER ----
      async function startBroadcast() {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          document.getElementById('localVideo').srcObject = localStream;

          setInterval(pollViewers, 2000);
          // pollViewers();
          
        } catch (err) {
          console.error("Error accessing media devices:", err);
        }
      }

      async function pollViewers() {
        const res = await fetch(`signal.php?action=get_viewers&room_id=${roomId}`);
        const viewers = await res.json();

        for (const vId in viewers) {
          const v = viewers[vId];

          if (!roomConnections[vId]) {
            const peer = new RTCPeerConnection(config);
            roomConnections[vId] = peer;

            localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

            peer.onicecandidate = e => {
              if (e.candidate) {
                sendSignal("ice", vId, e.candidate);
              }
            };

            const offer = await peer.createOffer();
            await peer.setLocalDescription(offer);
            sendSignal("offer", vId, offer);
          }

          if (v.answer && !roomConnections[vId].remoteDescription) {
            try {
              await roomConnections[vId].setRemoteDescription(new RTCSessionDescription(v.answer));
            } catch (err) {
              console.error("Error setting remote answer:", err);
            }
          }
        }
      }

        // async function pollViewers() {
        //   const res = await fetch(`signal.php?action=get_viewers&room_id=${roomId}`);
        //   const viewers = await res.json();

        //   for (const vId in viewers) {
        //     const v = viewers[vId];

        //     // Only create connection once per viewer
        //     if (!roomConnections[vId]) {
        //       const peer = new RTCPeerConnection(config);
        //       roomConnections[vId] = peer;

        //       // Add local media tracks
        //       localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

        //       // Send ICE candidates to viewer
        //       peer.onicecandidate = e => {
        //         if (e.candidate) {
        //           sendSignal("ice", vId, e.candidate);
        //         }
        //       };

        //       // Create offer and send to viewer
        //       const offer = await peer.createOffer();
        //       await peer.setLocalDescription(offer);
        //       sendSignal("offer", vId, offer);
        //     }

        //     // Set viewer's answer if available and not yet set
        //     const peerConnection = roomConnections[vId];
        //     if (v.answer && !peerConnection.remoteDescription) {
        //       try {
        //         await peerConnection.setRemoteDescription(new RTCSessionDescription(v.answer));
        //       } catch (err) {
        //         console.error(`Error setting remote answer for viewer ${vId}:`, err);
        //       }
        //     }
        //   }
        // }



      function sendSignal(type, viewer, data) {
        fetch("signal.php", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action: type, room_id: roomId, viewer, data })
        });
      }

      // ---- VIEWER ----
      async function startViewer() {
        pc = new RTCPeerConnection(config);
        const remoteVideo = document.getElementById('remoteVideo');

        pc.ontrack = e => {
          if (!remoteVideo.srcObject) {
            console.log("Stream received:", e.streams[0]);
            remoteVideo.srcObject = e.streams[0];
            remoteVideo.onloadedmetadata = () => {
              remoteVideo.play().catch(err => console.warn("Autoplay failed:", err));
            };
          }
        };

        pc.onicecandidate = e => {
          if (e.candidate) {
            sendViewerSignal("ice", e.candidate);
          }
        };

        await fetch("signal.php", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            action: "register_viewer",
            room_id: roomId,
            viewer: viewerId
          })
        });

        const receivedIce = new Set();

        setInterval(async () => {
          const res = await fetch(`signal.php?action=get_offer&room_id=${roomId}&viewer=${viewerId}`);
          const data = await res.json();

          if (data.offer && !pc.remoteDescription) {
            try {
              await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              sendViewerSignal("answer", answer);
            } catch (err) {
              console.error("Failed to handle offer:", err);
            }
          }

          if (Array.isArray(data.ice)) {
            for (const candidate of data.ice) {
              const key = JSON.stringify(candidate);
              if (!receivedIce.has(key)) {
                receivedIce.add(key);
                try {
                  await pc.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (err) {
                  console.warn("Failed to add ICE:", err);
                }
              }
            }
          }
        }, 2000);
      }

      function sendViewerSignal(type, data) {
        fetch("signal.php", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action: type, room_id: roomId, viewer: viewerId, data })
        });
      }

      // Start role
      if (role === 'streamer') {
        startBroadcast();
      } else if (role === 'viewer') {
        startViewer();
      }
    };
  </script>
</body>
</html>
