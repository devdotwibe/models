<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Streamer (AJAX signaling)</title>
<style>
  body{font-family:Arial;padding:12px}
  video{width:48%;border-radius:8px;background:#000}
  #log{height:220px;background:#0b1220;color:#bdf;padding:8px;overflow:auto;border-radius:6px;margin-top:8px}
  input,button{padding:8px;margin:6px}
</style>
</head>
<body>
  <h2>Streamer</h2>
  <label>Room: <input id="room" value="room123"></label>
  <button id="startBtn">Start Stream (mark room started)</button>
  <div>
    <video id="localVideo" autoplay playsinline muted></video>
  </div>
  <h3>Log</h3><pre id="log"></pre>

<script>
const SIGNAL = 'signaling.php';
const ICE = [{ urls: 'stun:stun.l.google.com:19302' }]; // add TURN for public internet
let room = null;
let localStream = null;
const pcs = {}; // peerId -> pc

const logEl = document.getElementById('log');
function log(...a){ console.log(...a); logEl.textContent += a.map(x=> typeof x==='object'? JSON.stringify(x): String(x)).join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }

async function postJson(body){
  const res = await fetch(`${SIGNAL}?room=${encodeURIComponent(room)}`, {
    method:'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body)
  });
  return res.json();
}
async function getJson(params){
  const qs = new URLSearchParams(params);
  const res = await fetch(`${SIGNAL}?${qs}`);
  return res.json();
}

document.getElementById('startBtn').addEventListener('click', start);

async function start(){
  room = document.getElementById('room').value.trim();
  if (!room) return alert('Enter room');
  // mark room started (won't delete existing offers)
  await postJson({ type:'start' });
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
    document.getElementById('localVideo').srcObject = localStream;
  } catch(e) { return alert('getUserMedia failed: '+e.message); }

  // poll for viewer offers and for candidates
  pollOffers();
  setInterval(pollOffers, 1200);
  setInterval(pollCandidates, 1400);
  log('Streamer started and polling for viewer offers...');
}

async function pollOffers(){
  if (!room) return;
  try{
    const res = await getJson({ room, action:'streamer', consume:1 }); // consume offers + those peers' candidates
    if (!res || !res.offers) return;
    for (const peerId in res.offers) {
      if (!res.offers.hasOwnProperty(peerId)) continue;
      if (pcs[peerId]) { log('Already answering', peerId); continue; }
      const offer = res.offers[peerId];
      const preCands = res.candidates && res.candidates[peerId] ? res.candidates[peerId] : [];
      handleOffer(peerId, offer, preCands).catch(e=> log('handleOffer err', e));
    }
  } catch(e){ log('pollOffers error', e); }
}

async function handleOffer(peerId, offerPayload, initialCandidates){
  log('New viewer offer', peerId);
  const pc = new RTCPeerConnection({ iceServers: ICE });
  pcs[peerId] = pc;

  // add local tracks
  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  pc.onicecandidate = e => {
    if (e.candidate) {
      postJson({ type:'candidate', peer:peerId, payload: e.candidate }).catch(()=>{});
    }
  };

  // apply any pre-sent candidates viewer made
  for (const c of (initialCandidates||[])) {
    try { await pc.addIceCandidate(new RTCIceCandidate(c)); } catch(e){ /* ignore */ }
  }

  try {
    await pc.setRemoteDescription(offerPayload);
  } catch(e) {
    log('setRemoteDescription failed for', peerId, e);
    try { pc.close(); } catch(_) {}
    delete pcs[peerId];
    return;
  }

  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  // post answer
  await postJson({ type:'answer', peer: peerId, payload: pc.localDescription });
  log('Answer posted for', peerId);

  // poll for later candidates for this peer and apply then cleanup
  const candInterval = setInterval(async ()=>{
    if (!pcs[peerId]) { clearInterval(candInterval); return; }
    try {
      const state = await getJson({ room, action:'streamer', consume:0 });
      const list = (state.candidates && state.candidates[peerId]) ? state.candidates[peerId] : [];
      if (list && list.length) {
        for (const cc of list) {
          try { await pc.addIceCandidate(cc); } catch(e){}
        }
        // remove those applied candidates from server
        await postJson({ type:'cleanup', peer: peerId });
      }
    } catch(e){ /* ignore */ }
  }, 1500);

  pc.onconnectionstatechange = ()=> {
    log('pc state', peerId, pc.connectionState);
    if (['failed','disconnected','closed'].includes(pc.connectionState)) {
      try { pc.close(); } catch(_){}
      delete pcs[peerId];
      clearInterval(candInterval);
      postJson({ type:'cleanup', peer: peerId }).catch(()=>{});
    }
  };
}

async function pollCandidates(){
  // streamer may also need to apply candidate lists targeted at streamer id if you used that pattern.
  // (Not necessary in this design; we use per-peer candidates.)
}
</script>
</body>
</html>
