<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Streamer (AJAX signaling)</title>
  <style>body{font-family:Arial;padding:16px}video{width:46%;margin-right:2%;}</style>
</head>
<body>
  <h1>Streamer</h1>
  <label>Room ID: <input id="room" value="room123"></label>
  <button id="startBtn">Start Stream (create/clean room)</button>
  <div style="margin-top:12px;">
    <video id="localVideo" autoplay playsinline muted></video>
  </div>
  <pre id="log" style="background:#111;color:#bde;padding:8px;height:160px;overflow:auto;"></pre>

<script>
const SIGNAL_URL = 'signaling.php';
const ICE = [{urls:'stun:stun.l.google.com:19302'}];
// For a production internet-ready deployment add TURN server entry here.

let room = null;
let localStream = null;
// peerId -> RTCPeerConnection
const pcs = {};

const logEl = document.getElementById('log');
function log(...args){ console.log(...args); logEl.textContent += args.map(a=> typeof a==='object' ? JSON.stringify(a) : String(a)).join(' ') + '\\n'; logEl.scrollTop = 99999; }

async function ajaxGET(params){
  const q = new URLSearchParams(params);
  const r = await fetch(`${SIGNAL_URL}?${q.toString()}`);
  return r.json();
}
async function ajaxPOST(params){
  const body = new URLSearchParams(params);
  const r = await fetch(SIGNAL_URL + '?room=' + encodeURIComponent(room), { method: 'POST', body });
  return r.json();
}

document.getElementById('startBtn').addEventListener('click', startStream);

async function startStream(){
  room = document.getElementById('room').value.trim();
  if (!room) return alert('Enter room id');

  // tell server to start/reset room
  await ajaxPOST({ type:'start_streamer', peer: 'streamer_' + Math.floor(Math.random()*1000000) });

  // get local media
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
    document.getElementById('localVideo').srcObject = localStream;
  } catch (e) {
    return alert('getUserMedia failed: ' + e.message);
  }

  // start polling for viewer offers
  pollOffers();
  setInterval(pollOffers, 1200);
  log('Streamer started, polling for offers...');
}

async function pollOffers(){
  if (!room) return;
  const data = await ajaxGET({ room, role:'streamer', consume:1 });
  if (!data || !data.offers) return;

  // data.offers is object { peerId: offerPayload }
  for (const peerId in data.offers) {
    if (!data.offers.hasOwnProperty(peerId)) continue;
    // If we already have pc for this peer skip
    if (pcs[peerId]) {
      log('Already answered peer', peerId);
      continue;
    }
    const offerPayload = data.offers[peerId];
    const candidates = (data.candidates && data.candidates[peerId]) || [];
    handleViewerOffer(peerId, offerPayload, candidates).catch(err=> log('handle error', err));
  }
}

async function handleViewerOffer(peerId, offerPayload, initialCandidates){
  log('New viewer offer for peer', peerId);
  const pc = new RTCPeerConnection({ iceServers: ICE });
  pcs[peerId] = pc;

  // add local tracks
  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  // when streamer has ice candidates, send them to server targeting that peer
  pc.onicecandidate = e => {
    if (e.candidate) {
      ajaxPOST({ type:'candidate', peer:peerId, payload: JSON.stringify(e.candidate) }).catch(()=>{});
    }
  };

  // Add any candidate(s the viewer already posted before we created pc
  for (const c of (initialCandidates || [])) {
    try { await pc.addIceCandidate(JSON.parse(c)); } catch(e){ /* ignore */ }
  }

  // set remote description (viewer offer)
  await pc.setRemoteDescription(JSON.parse(offerPayload));

  // create answer and post it
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await ajaxPOST({ type:'answer', peer:peerId, payload: JSON.stringify(pc.localDescription) });

  log('Answered peer', peerId);

  // Also poll for additional candidates specifically for this peer periodically
  const candInterval = setInterval(async ()=>{
    // fetch any remaining candidates for this peer (viewer->streamer)
    const res = await ajaxGET({ room, role:'streamer', consume:0 });
    // res.candidates may contain entries for many peers; apply only peerId ones
    if (res && res.candidates && res.candidates[peerId]) {
      for (const c of res.candidates[peerId]) {
        try { await pc.addIceCandidate(JSON.parse(c)); } catch(_) {}
      }
      // remove those candidates after applying
      await ajaxPOST({ type:'cleanup_peer', peer: peerId, payload:'1' });
    }
    // if pc closed, cleanup
    if (pc.iceConnectionState === 'closed' || pc.connectionState === 'closed') {
      clearInterval(candInterval);
      delete pcs[peerId];
    }
  }, 1500);

  pc.onconnectionstatechange = ()=> {
    log('pc state', peerId, pc.connectionState);
    if (pc.connectionState === 'failed' || pc.connectionState === 'closed' || pc.connectionState === 'disconnected') {
      try { pc.close(); } catch(e){}
      delete pcs[peerId];
    }
  };
}
</script>
</body>
</html>
