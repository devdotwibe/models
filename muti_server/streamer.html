<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Streamer (AJAX signaling)</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; padding:16px; }
    video { width:48%; display:inline-block; vertical-align:top; border-radius:8px; background:#111; }
    #log { background:#0b1220; color:#9fd; padding:8px; height:220px; overflow:auto; border-radius:6px; }
    input, button { padding:8px 10px; margin:6px; font-size:14px; }
  </style>
</head>
<body>
  <h2>Streamer</h2>
  <label>Room ID: <input id="room" value="room123"></label>
  <button id="startBtn">Start Stream (reset room)</button>
  <div style="margin-top:12px;">
    <video id="localVideo" autoplay playsinline muted></video>
  </div>
  <h3>Log</h3>
  <pre id="log"></pre>

<script>
const SIGNAL = 'signaling.php';
const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }]; // add TURN for internet

let room = null;
let localStream = null;
const pcs = {}; // peerId -> RTCPeerConnection

const logEl = document.getElementById('log');
function log(...args){ console.log(...args); logEl.textContent += args.map(a => (typeof a==='object'?JSON.stringify(a):String(a))).join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }

async function ajaxGET(params){
  const qs = new URLSearchParams(params).toString();
  const res = await fetch(`${SIGNAL}?${qs}`);
  return res.json();
}
async function ajaxPOST(params){
  const body = new URLSearchParams(params);
  const res = await fetch(`${SIGNAL}?room=${encodeURIComponent(room)}`, { method:'POST', body });
  return res.json();
}

document.getElementById('startBtn').addEventListener('click', startStreamer);

async function startStreamer(){
  room = document.getElementById('room').value.trim();
  if (!room) return alert('Enter room id');

  // reset/create room and mark streamer started
  await ajaxPOST({ type:'start_streamer', peer: 'streamer_' + Date.now() });

  // get local camera/mic
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
    document.getElementById('localVideo').srcObject = localStream;
  } catch (err) {
    return alert('getUserMedia failed: ' + err.message);
  }

  // poll for viewer offers regularly
  pollOffers();
  setInterval(pollOffers, 1200);
  log('Streamer started, polling for viewer offers...');
}

async function pollOffers(){
  if (!room) return;
  try {
    const data = await ajaxGET({ room, role:'streamer', consume:1 }); // consume offers and those peers' candidates
    if (!data) return;
    const offers = data.offers || {};
    const candidatesMap = data.candidates || {};

    for (const peerId in offers) {
      if (!offers.hasOwnProperty(peerId)) continue;
      if (pcs[peerId]) {
        log('Already handling peer', peerId);
        continue;
      }
      const offerPayload = offers[peerId];
      const preCandidates = candidatesMap[peerId] || [];
      handleViewerOffer(peerId, offerPayload, preCandidates).catch(e => log('handle error', e));
    }
  } catch(e) {
    log('pollOffers error', e);
  }
}

async function handleViewerOffer(peerId, offerPayload, initialCandidates){
  log('Received offer from', peerId);
  const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
  pcs[peerId] = pc;

  // add local tracks (streamer -> viewers)
  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  pc.onicecandidate = e => {
    if (e.candidate) {
      // post candidate targeted at the viewer peer id
      ajaxPOST({ type:'candidate', peer:peerId, payload: JSON.stringify(e.candidate) }).catch(()=>{});
    }
  };

  // apply any candidate viewer already sent before pc creation
  for (const c of (initialCandidates || [])) {
    try { await pc.addIceCandidate(JSON.parse(c)); } catch(e){ /* ignore */ }
  }

  // set remote description (viewer offer)
  try {
    await pc.setRemoteDescription(JSON.parse(offerPayload));
  } catch(e) {
    log('setRemoteDescription error', e);
    try { pc.close(); } catch(_) {}
    delete pcs[peerId];
    re
